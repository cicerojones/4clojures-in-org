
* ;; 4Clojure Question 1
;; This is a clojure form. Enter a value which will make the form
;; evaluate to true. Don't over think it! If you are confused, see the
;; <a href='/directions'>getting started</a> page. Hint: true is equal
;; to true. Use M-x 4clojure-check-answers when you're done!

#+BEGIN_SRC clojure
(= __ true)
#+END_SRC


** solutions

Solutions:

true
0x89's solution:
true

------------------------------------------------------------------------------------------------
_pcl's solution:
(not false)

------------------------------------------------------------------------------------------------
amcnamara's solution:
(reify Object (equals [_ _] (= _)))

------------------------------------------------------------------------------------------------
ctzsm's solution:
(= (clojure-version) "1.4.0")

* ;; 4Clojure Question 2

(= (- 10 (* 2 3)) __)

** solutions


Solutions:

4
------------------------------------------------------------------------------------------------
_pcl's solution:
(- 10 (* 2 3))


* ;; 4Clojure Question 3

#+BEGIN_SRC clojure


;; Clojure strings are Java strings. This means that you can use any
;; of the Java string methods on Clojure strings. 

(= __ (.toUpperCase "hello world"))
#+END_SRC

** solutions

Solutions:

"HELLO WORLD"

------------------------------------------------------------------------------------------------
adereth's solution:
(reify Object (equals [_ _] (= _)))
----------------------------------------------------------------------------
jimm's solution:
"HELLO WORLD"
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
(.toUpperCase "hello world")
------------------------------------------------------------------------------------------------

* ;; 4Clojure Question 4

#+BEGIN_SRC clojure


;; Lists can be constructed with either a function or a quoted form.
;; Use M-x 4clojure-check-answers when you're done!

(= (list __) '(:a :b :c))
#+END_SRC

** solutions

Solutions:

:a :b :c


* ;; 4Clojure Question 5

#+BEGIN_SRC clojure


;; When operating on a list, the conj function will return a new list
;; with one or more items "added" to the front. 

(= __ (conj '(2 3 4) 1))

(= __ (conj '(3 4) 2 1))
#+END_SRC

** solutions

Solutions:

'(1 2 3 4)
0x89's solution:
[1 2 3 4]

* ;; 4Clojure Question 6

#+BEGIN_SRC clojure


;; Vectors can be constructed several ways. You can compare them with
;; lists. Use M-x 4clojure-check-answers when you're done!

(= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
#+END_SRC

** solutions

Solutions:

:a :b :c

* ;; 4Clojure Question 7

#+BEGIN_SRC clojure


;; When operating on a Vector, the conj function will return a new
;; vector with one or more items "added" to the end. 

(= __ (conj [1 2 3] 4))

(= __ (conj [1 2] 3 4))
#+END_SRC

** solutions



Solutions:

[1 2 3 4]

* ;; 4Clojure Question 8

#+BEGIN_SRC clojure


;; Sets are collections of unique values. 

(= __ (set '(:a :a :b :c :c :c :c :d :d)))

(= __ (clojure.set/union #{:a :b :c} #{:b :c :d}))
#+END_SRC

** solutions



Solutions:

#{:a :b :c :d}
0x89's solution:
#{:a :b :c :d}
------------------------------------------------------------------------------------------------
_pcl's solution:
(set '(:a :b :c :d))
------------------------------------------------------------------------------------------------
darren's solution:
#{:a :b :c :d}
------------------------------------------------------------------------------------------------
amcnamara's solution:
#{:a :b :c :d}
------------------------------------------------------------------------------------------------
wills's solution:
#{:a :b :c :d}
------------------------------------------------------------------------------------------------
foantell's solution:
'#{:a :b :c :d}

* ;; 4Clojure Question 9

#+BEGIN_SRC clojure
;; When operating on a set, the conj function returns a new set with
;; one or more keys "added". 


(= #{1 2 3 4} (conj #{1 4 3} __))
#+END_SRC

** solutions
Solutions:

2
0x89's solution:
2
------------------------------------------------------------------------------------------------
_pcl's solution:
2
------------------------------------------------------------------------------------------------
darren's solution:
2
------------------------------------------------------------------------------------------------
amcnamara's solution:
2
------------------------------------------------------------------------------------------------
wills's solution:
2 3
------------------------------------------------------------------------------------------------
foantell's solution:
2
------------------------------------------------------------------------------------------------
aceeca1's solution:
1 2 3
------------------------------------------------------------------------------------------------

* ;; 4Clojure Question 10

#+BEGIN_SRC clojure


;; Maps store key-value pairs. Both maps and keywords can be used as
;; lookup functions. Commas can be used to make maps more readable,
;; but they are not required. 

(= __ ((hash-map :a 10, :b 20, :c 30) :b))

(= __ (:b {:a 10, :b 20, :c 30}))
#+END_SRC

** solutions
Solutions:

20

* ;; 4Clojure Question 11

#+BEGIN_SRC clojure


;; When operating on a map, the conj function returns a new map with
;; one or more key-value pairs "added". Use M-x 4clojure-check-answers
;; when you're done!

(= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
#+END_SRC

** solutions

Solutions:

{:b 2}
0x89's solution:

[:b 2]]]
* ;; 4Clojure Question 12

#+BEGIN_SRC clojure


;; All Clojure collections support sequencing. You can operate on
;; sequences with functions like first, second, and last. 

(= __ (first '(3 2 1)))

(= __ (second [2 3 4]))

(= __ (last (list 1 2 3)))
#+END_SRC

** solutions

Solutions:

3

* ;; 4Clojure Question 13

#+BEGIN_SRC clojure


;; The rest function will return all the items of a sequence except
;; the first. Use M-x 4clojure-check-answers when you're done!

(= __ (rest [10 20 30 40]))
#+END_SRC

** solutions



Solutions:

[20 30 40]

* ;; 4Clojure Question 14

#+BEGIN_SRC clojure


;; Clojure has many different ways to create functions. 

(= __ ((fn add-five [x] (+ x 5)) 3))

(= __ ((fn [x] (+ x 5)) 3))

(= __ (#(+ % 5) 3))

(= __ ((partial + 5) 3))
#+END_SRC

** solutions

Solutions:

8

* ;; 4Clojure Question 15

#+BEGIN_SRC clojure


;; Write a function which doubles a number. 

(= (__ 2) 4)

(= (__ 3) 6)

(= (__ 11) 22)

(= (__ 7) 14)
#+END_SRC

** solutions

#(* % 2)

------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [x] (* x 2))

------------------------------------------------------------------------------------------------
wills's solution:
#(* % 2)
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [x] (* x 2))
------------------------------------------------------------------------------------------------
aceeca1's solution:
\* 2
------------------------------------------------------------------------------------------------
adereth's solution:
\* 2
------------------------------------------------------------------------------------------------
austintaylor's solution:
(partial * 2)
------------------------------------------------------------------------------------------------
ming's solution:
#(* 2 %)
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [n] (+ n n))

* ;; 4Clojure Question 16

#+BEGIN_SRC clojure


;; Write a function which returns a personalized greeting. 

(= (__ "Dave") "Hello, Dave!")

(= (__ "Jenn") "Hello, Jenn!")

(= (__ "Rhea") "Hello, Rhea!")
#+END_SRC

** solutions

#(str "Hello," " " % "!")

0x89's solution:
#(str "Hello, " % \!)
------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [n] (str "Hello, " n "!"))
------------------------------------------------------------------------------------------------
darren's solution:
#(str "Hello, " % \!)
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(str "Hello, " % \!)
------------------------------------------------------------------------------------------------
wills's solution:
#(str "Hello, " % "!" )
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [string] (str "Hello, " string "!"))
------------------------------------------------------------------------------------------------
dlee's solution:
#(str "Hello, " % "!")
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [s] (str "Hello, " s "!"))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(str "Hello, " % "!")
------------------------------------------------------------------------------------------------
icamts's solution:
#(str "Hello, " % "!")
------------------------------------------------------------------------------------------------
ming's solution:
(partial format "Hello, %s!")
------------------------------------------------------------------------------------------------
ramo's solution:
#(str "Hello, " % "!")
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [n] (str "Hello, " n "!"))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [name]
  (str "Hello, " name "!"))

* ;; 4Clojure Question 17

#+BEGIN_SRC clojure


;; The map function takes two arguments: a function (f) and a sequence
;; (s). Map returns a new sequence consisting of the result of
;; applying f to each item of s. Do not confuse the map function with
;; the map data structure. 

(= __ (map #(+ % 5) '(1 2 3)))
#+END_SRC

** solutions



Solutions:

'(6 7 8)
0x89's solution:

* ;; 4Clojure Question 18

#+BEGIN_SRC clojure


;; The filter function takes two arguments: a predicate function (f)
;; and a sequence (s). Filter returns a new sequence consisting of all
;; the items of s for which (f item) returns true. 

(= __ (filter #(> % 5) '(3 4 5 6 7)))
#+END_SRC

** solutions



Solutions:

'(6 7)
0x89's solution:
[6 7]
------------------------------------------------------------------------------------------------
_pcl's solution:
'(6 7)
------------------------------------------------------------------------------------------------
darren's solution:
[6 7]
------------------------------------------------------------------------------------------------
amcnamara's solution:
[6 7]
------------------------------------------------------------------------------------------------
wills's solution:
'(6 7)
------------------------------------------------------------------------------------------------
foantell's solution:
'(6 7)

* ;; 4Clojure Question 19

#+BEGIN_SRC clojure


;; Write a function which returns the last element in a sequence.
;; Restrictions (please don't use these function(s)): last 

(= (__ [1 2 3 4 5]) 5)

(= (__ '(5 4 3)) 3)

(= (__ ["b" "c" "d"]) "d")
#+END_SRC

** solutions

(fn [x] (first (reverse x)))

0x89's solution:
(comp first reverse)
------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [x] (first (reverse x)))
------------------------------------------------------------------------------------------------
darren's solution:
(comp peek vec)
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(first (reverse %))
------------------------------------------------------------------------------------------------
wills's solution:
(fn [[x & more]]
  (if more
    (recur more)
    x))
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [coll]
  (loop [remaining coll]
    (let [[head & rest] remaining]
    (if (empty? rest)
      head
      (recur rest)))))
------------------------------------------------------------------------------------------------
aceeca1's solution:
(fn [s]
        (if (next s)
          (recur (next s))
          (first s)))
------------------------------------------------------------------------------------------------
adereth's solution:
(comp first reverse)
------------------------------------------------------------------------------------------------
austintaylor's solution:
(comp first reverse)
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [coll] (first (reverse coll)) )
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(first (reverse %))
------------------------------------------------------------------------------------------------
dlee's solution:
(comp first reverse)
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [ aseq ](first (reverse aseq)))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(first (reverse %))
------------------------------------------------------------------------------------------------
icamts's solution:
#(if (next %) (recur (next %)) (first %))
------------------------------------------------------------------------------------------------
jimm's solution:
(fn [coll] (first (reverse coll)))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(reduce (fn [a b] b) %)
------------------------------------------------------------------------------------------------
ming's solution:
#(nth % (dec (count %)))
------------------------------------------------------------------------------------------------
ramo's solution:
(comp first reverse)
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [in]
  (if-let [r (next in)]
    (recur r)
    (first in)))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [lst]
  (reduce (fn [a b] b) nil lst))

* ;; 4Clojure Question 20

#+BEGIN_SRC clojure


;; Write a function which returns the second to last element from a
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= (__ (list 1 2 3 4 5)) 4)

(= (__ ["a" "b" "c"]) "b")

(= (__ [[1 2] [3 4]]) [1 2])
#+END_SRC

** solutions
#(first (rest (reverse %)))
0x89's solution:
(comp peek pop vec)
------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [x] (first (rest (reverse x))))
------------------------------------------------------------------------------------------------
darren's solution:
#(-> % vec pop peek)
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(nth (reverse %) 1)
------------------------------------------------------------------------------------------------
wills's solution:
(comp second reverse)
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [coll]
  (loop [remaining coll]
    (let [[head & rest] remaining]
    (if (= 1 (count rest))
      head
      (recur rest)))))
------------------------------------------------------------------------------------------------
aceeca1's solution:
(comp first next reverse)
------------------------------------------------------------------------------------------------
adereth's solution:
(comp second reverse)
------------------------------------------------------------------------------------------------
austintaylor's solution:
(comp first rest reverse)
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [x] (first (rest (reverse x))))
------------------------------------------------------------------------------------------------
ctzsm's solution:
(comp first rest reverse)
------------------------------------------------------------------------------------------------
dlee's solution:
(comp second reverse)
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [ aseq ](second (reverse aseq)))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(last (butlast %))
------------------------------------------------------------------------------------------------
icamts's solution:
(comp first last #(partition 2 1 %))
------------------------------------------------------------------------------------------------
jimm's solution:
#(second (reverse %))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(first (drop 1 (reverse %)))
------------------------------------------------------------------------------------------------
ming's solution:
#(nth % (dec (dec (count %))))
------------------------------------------------------------------------------------------------
ramo's solution:
(comp second reverse)
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [[pu l & more :as in]]
  (if more
    (recur (next in))
    pu))
------------------------------------------------------------------------------------------------
benizi's solution:
#_(blech fn [lst]
  (loop [f (first lst)
         l (rest lst)]
    (if (< 1 (count l))
        (recur (first l) (rest l))
        f)))

(comp fnext reverse)

* ;; 4Clojure Question 21

#+BEGIN_SRC clojure


;; Write a function which returns the Nth element from a sequence.
;; Restrictions (lpease don't use these function(s)): nth 
(= (__ '(4 5 6 7) 2) 6)

(= (__ [:a :b :c] 0) :a)

(= (__ [1 2 3 4] 1) 2)

(= (__ '([1 2] [3 4] [5 6]) 2) [5 6])
#+END_SRC

** solutions
(fn my-nth [lat n] 
  (cond (= n 0) (first lat)
      :else (my-nth (rest lat) (dec n))))

0x89's solution:
#(first (drop %2 %))
------------------------------------------------------------------------------------------------
_pcl's solution:
(fn self [xs i] (cond (= i 0) (first xs) true (self (rest xs) (- i 1))))
------------------------------------------------------------------------------------------------
darren's solution:
#(first (drop %2 %))
------------------------------------------------------------------------------------------------
amcnamara's solution:
#((vec %) %2)
------------------------------------------------------------------------------------------------
wills's solution:
(fn [as pos]
(last (take (+ pos 1) as)))
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [seq pos]
  (last (take (+ pos 1) seq)))
------------------------------------------------------------------------------------------------
aceeca1's solution:
#((vec %1) %2)
------------------------------------------------------------------------------------------------
adereth's solution:
#(first(drop %2 %1))
------------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [s n]
  (first (drop n s)))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [coll n] 
  (if (= n 0)
    (first coll)
    (recur (rest coll) (dec n))
  )
)
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(last (take (+ %2 1) %1))
------------------------------------------------------------------------------------------------
dlee's solution:
#(first (drop %2 %1))
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [s i] (if (= i 0) (first s) (recur (rest s) (- i 1))))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(first (drop %2 %1))
------------------------------------------------------------------------------------------------
icamts's solution:
#(first (drop %2 %))
------------------------------------------------------------------------------------------------
jimm's solution:
#(loop [count %2, coll %1]
  (if (zero? count) (first coll)
   (recur (dec count) (next coll))))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(first (drop %2 %1))
------------------------------------------------------------------------------------------------
ming's solution:
#(loop [coll %1
        idx 0]
   (if (= idx %2)
     (first coll)
     (recur (rest coll) (inc idx))))
------------------------------------------------------------------------------------------------
ramo's solution:
(comp first nthrest)
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [s n]
  (if (zero? n)
(first s)
(recur (next s) (dec n))))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [lst n]
  (loop [n n
         el (first lst)
         l (rest lst)]
    (if (zero? n)
        el
        (recur (dec n) (first l) (rest l)))))

* ;; 4Clojure Question 22

#+BEGIN_SRC clojure


;; Write a function which returns the total number of elements in a
;; sequence. Restrictions (please don't use these function(s)): count
;; Use M-x 4clojure-check-answers when you're done!

(= (__ '(1 2 3 3 1)) 5)

(= (__ "Hello World") 11)

(= (__ [[1 2] [3 4] [5 6]]) 3)

(= (__ '(13)) 1)

(= (__ '(:a :b :c)) 3)
#+END_SRC

** solutions

(fn size [lst]
  (if (empty? lst)
    0
    (inc (size (rest lst)))))

0x89's solution:
#(reduce (fn [x _] (+ 1 x)) 0 %)
------------------------------------------------------------------------------------------------
_pcl's solution:
reduce (fn [m i] (+ m 1)) 0
------------------------------------------------------------------------------------------------
darren's solution:
reduce (fn [c _] (+ c 1)) 0
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(-> (map-indexed list %) last first inc)
------------------------------------------------------------------------------------------------
wills's solution:
(fn [x] 
  (loop [ans 0
         lst x]
    (if (empty? lst)
      ans
      (recur (inc ans) (rest lst)))))
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [seq]
  (->> (map (fn [x] 1) seq)
       (reduce +)))
------------------------------------------------------------------------------------------------
aceeca1's solution:
(comp (partial apply +) (partial map #(do % 1)))
------------------------------------------------------------------------------------------------
adereth's solution:
(fn [sequence] (reduce (fn [acc v] (inc acc)) 0 sequence))
------------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [s]
  (reduce + (map (constantly 1) s)))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [xs] (reduce + (map (fn [x] 1) xs) ) )
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(loop [s % n 0]
  (if (empty? s)
    n
    (recur (rest s) (inc n))
    )
  )
------------------------------------------------------------------------------------------------
dlee's solution:
(partial reduce (fn[x y] (inc x)) 0)
------------------------------------------------------------------------------------------------
echevarria's solution:
(partial (fn [i s] (if (empty? s) i (recur (+ i 1) (rest s)))) 0)
------------------------------------------------------------------------------------------------
glchapman's solution:
#(reduce (fn [tot _] (inc tot)) 0 %)
------------------------------------------------------------------------------------------------
icamts's solution:
#(-> % (interleave (range)) last inc)
------------------------------------------------------------------------------------------------
jimm's solution:
#(reduce + (map (fn [_] 1) %))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(reduce + (map (fn [x] 1) %))
------------------------------------------------------------------------------------------------
ming's solution:
(fn [s] 
  (loop [idx 0]
    (if (= :not-found (nth s idx :not-found))
      idx
      (recur (inc idx)))))
------------------------------------------------------------------------------------------------
ramo's solution:
reduce (fn [x _] (inc x)) 0
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [in]
  (reduce (fn [c _] (inc c)) 0  in))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [lst]
  (reduce + (map (constantly 1) lst)))

* ;; 4Clojure Question 23

#+BEGIN_SRC clojure


;; Write a function which reverses a sequence. Restrictions (please
;; don't use these function(s)): reverse, rseq 

(= (__ [1 2 3 4 5]) [5 4 3 2 1])

(= (__ (sorted-set 5 7 2 7)) '(7 5 2))

(= (__ [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]])
#+END_SRC

** solutions

#+BEGIN_SRC clojure
(fn my-reverse [lst]
  (cond (empty? lst)()
        :else (cons (last lst)
                    (my-reverse (butlast lst)))))
#+END_SRC

0x89's solution:
#(into () %)
------------------------------------------------------------------------------------------------
_pcl's solution:
reduce #(conj %1 %2) '()
------------------------------------------------------------------------------------------------
darren's solution:
into ()
------------------------------------------------------------------------------------------------
amcnamara's solution:
into ()
------------------------------------------------------------------------------------------------
wills's solution:
reduce #(cons %2 %1) []
------------------------------------------------------------------------------------------------
foantell's solution:
#(into '() %)
------------------------------------------------------------------------------------------------
aceeca1's solution:
#(map (vec %) (range (dec (count %)) -1 -1))
------------------------------------------------------------------------------------------------
adereth's solution:
(fn [s]
  (loop [result []
         s s]
    (if (seq s)
      (recur (concat [(first s)] result) (rest s))
      result)))
------------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [s]
  (reduce conj '() s))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [xs]
  (reduce 
    (fn [first second] (cons second first))
    nil
    xs
  )
)
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(loop [n (count %) ret [] res %]
  (if (zero? n)
    ret 
    (recur (dec n) (conj ret (last res)) (take (- n 1) res)))
)
------------------------------------------------------------------------------------------------
dlee's solution:
apply (partial conj ())
------------------------------------------------------------------------------------------------
echevarria's solution:
(partial (fn [rs is] (if (empty? is) rs (recur (conj rs (first is)) (rest is)))) ())
------------------------------------------------------------------------------------------------
glchapman's solution:
#(reduce conj () %)
------------------------------------------------------------------------------------------------
icamts's solution:
into '()
------------------------------------------------------------------------------------------------
jimm's solution:
#(loop [coll % v ()]
              (if coll (recur (next coll) (conj v (first coll)))
                v))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(reduce conj '() %)
------------------------------------------------------------------------------------------------
ming's solution:
(fn [s] 
  (loop [idx (dec (count s))
         ret []]
    (if (not (neg? idx))
      (recur (dec idx) (conj ret (nth (vec s) idx)))
      ret)))
------------------------------------------------------------------------------------------------
ramo's solution:
#(reduce conj () %)
------------------------------------------------------------------------------------------------
thegeez's solution:
into '()
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [lst]
  (reduce conj '() lst))

* ;; 4Clojure Question 24

#+BEGIN_SRC clojure

;; Write a function which returns the sum of a sequence of numbers.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3]) 6)

(= (__ (list 0 -2 5 5)) 8)

(= (__ #{4 2 1}) 7)

(= (__ '(0 0 -1)) -1)

(= (__ '(1 10 3)) 14)
#+END_SRC

** solutions



Solutions:

reduce +
0x89's solution:
#(apply + %)
------------------------------------------------------------------------------------------------
_pcl's solution:
apply +
------------------------------------------------------------------------------------------------
darren's solution:
apply +
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(apply + %)
------------------------------------------------------------------------------------------------
wills's solution:
reduce + 0
------------------------------------------------------------------------------------------------
foantell's solution:
#(reduce + %1)
------------------------------------------------------------------------------------------------
aceeca1's solution:
apply +
------------------------------------------------------------------------------------------------
adereth's solution:
apply +
------------------------------------------------------------------------------------------------
austintaylor's solution:
reduce +
------------------------------------------------------------------------------------------------
bradkaiser's solution:
reduce +
------------------------------------------------------------------------------------------------
ctzsm's solution:
apply +
------------------------------------------------------------------------------------------------
dlee's solution:
reduce +
------------------------------------------------------------------------------------------------
echevarria's solution:
reduce +
------------------------------------------------------------------------------------------------
glchapman's solution:
#(apply + %)
------------------------------------------------------------------------------------------------
icamts's solution:
reduce +
------------------------------------------------------------------------------------------------
jimm's solution:
#(reduce + %)

* ;; 4Clojure Question 25

#+BEGIN_SRC clojure


;; Write a function which returns only the odd numbers from a
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= (__ #{1 2 3 4 5}) '(1 3 5))

(= (__ [4 2 1 6]) '(1))

(= (__ [2 2 4 6]) '())

(= (__ [1 1 1 3]) '(1 1 1 3))
#+END_SRC

** solutions

(fn build-odd [lst]
  (cond (empty? lst) ()
        (= 1 (mod (first lst) 2)) (cons (first lst) (build-odd (rest lst)))
        :else (build-odd (rest lst))))

0x89's solution:
#(filter odd? %)
------------------------------------------------------------------------------------------------
_pcl's solution:
filter #(= 1 (mod % 2))
------------------------------------------------------------------------------------------------
darren's solution:
filter odd?
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(filter odd? %)
------------------------------------------------------------------------------------------------
wills's solution:
filter odd?
------------------------------------------------------------------------------------------------
foantell's solution:
filter odd?
------------------------------------------------------------------------------------------------
austintaylor's solution:
filter #(== (mod % 2) 1)
------------------------------------------------------------------------------------------------
bradkaiser's solution:
filter (fn [x] (= 1 (rem x 2)))
------------------------------------------------------------------------------------------------
ctzsm's solution:
filter odd?
------------------------------------------------------------------------------------------------
dlee's solution:
filter odd?
------------------------------------------------------------------------------------------------
echevarria's solution:
filter (fn [x] (= 1 (mod x 2)))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(filter odd? %)
------------------------------------------------------------------------------------------------
icamts's solution:
#(for [x % :when (odd? x)] x)
------------------------------------------------------------------------------------------------
jimm's solution:
#(filter odd? %)
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
filter #(= 1 (rem % 2))
------------------------------------------------------------------------------------------------
ming's solution:
filter #(= 1 (rem % 2))

* ;; 4Clojure Question 26

#+BEGIN_SRC clojure


;; Write a function which returns the first X fibonacci numbers. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ 3) '(1 1 2))

(= (__ 6) '(1 1 2 3 5 8))

(= (__ 8) '(1 1 2 3 5 8 13 21))
#+END_SRC

** solutions
(fn fibs [x]
   (cond (= x 2) '(1 1)
         :else ((fn [x y] 
                  	(reverse (cons x (reverse y))))
                (+ (last (fibs (dec x)))
                   (last (butlast (fibs (dec x)))))
		(fibs (dec x)))))

0x89's solution:
(fn* [p1__2673#] (take p1__2673# ((fn fibs [] (lazy-cat [1 1] (map + (fibs) (rest (fibs))))))))
------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [i] (take i '(1 1 2 3 5 8 13 21)))
------------------------------------------------------------------------------------------------
darren's solution:
#(letfn [(f [a b] (lazy-seq (cons a (f b (+ a b)))))]
    (take % (f 1 1)))
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(take %
   (concat [1 1]
     ((fn f [i j] (lazy-cat [(+ i j)] (f j (+ i j)))) 1 1)))
------------------------------------------------------------------------------------------------
wills's solution:
(fn [x] 
  (loop [l 1
         c 1
   	     total_length (- x 2)
         result [1 1]]
    (if (= total_length 0)
      result
      (recur c (+ c l) (- total_length 1) (conj result (+ c l))))))
------------------------------------------------------------------------------------------------
foantell's solution:
#(take % (map first (iterate (fn [[x y]]
                        [y (+ x y)]) [1 1])))
------------------------------------------------------------------------------------------------
aceeca1's solution:
#((apply comp (repeat (- % 2) (fn [x] (conj x (+ (peek x) (peek (pop x))))))) [1 1])
------------------------------------------------------------------------------------------------
adereth's solution:
#(take %
  (map first
    (iterate (fn [[i1 i2]]
      [i2 (+ i1 i2)])
      [1 1])))
------------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [n]
  (map first (reductions
    (fn [[a b] _] [b (+ a b)]) [1 1] (range 1 n))))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [n]   
 (reverse ((fn  [x coll] 
   (cond
     (= x 0) coll
     true (recur 
       (dec x)
       (cons 
         (+ (first coll) (first (rest coll)))
         coll
       )
     )
   )
 ) (- n 2) (list 1 1) )
))
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(take % (map first (iterate (fn [[a b]] [b (+ a b)]) [1 1])))
------------------------------------------------------------------------------------------------
dlee's solution:
#(take % (map first (iterate (fn [[a b]] [b (+ a b)]) [1 1])))
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [ n ] 
    (take n ((fn fibonacci 
                ([] (cons 1 (lazy-seq (fibonacci 0 1))))
                ([a b] (cons (+ a b) (lazy-seq (fibonacci b (+ a b))))))))
)
------------------------------------------------------------------------------------------------
glchapman's solution:
#(take % (list* 1 (map first
    (iterate (fn [[m n]] [(+ m n) m]) [1 1]))))
------------------------------------------------------------------------------------------------
icamts's solution:
#(take % (map first (iterate (fn [x] (list (second x) (+ (first x) (second x)))) '(1 1))))
------------------------------------------------------------------------------------------------
jimm's solution:
#(take % (drop 1 (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1]))))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(reduce (fn [a b] 
            (conj a (+ (nth a (- (count a) 2)) (last a)))) [1 1] (range (- % 2)))
------------------------------------------------------------------------------------------------
ming's solution:
(fn [n]
  (map first (take n (iterate (fn [v] [(apply + v) (first v)]) [1 0]))))
------------------------------------------------------------------------------------------------
ramo's solution:
#(take % ((fn fib [a b] (cons a (lazy-seq (fib b (+ a b))))) 1 1))
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [n]
    (take n (map first (iterate (fn [[l r]]
                                  [r (+ l r)])
                                [1 1]))))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [n]
  (loop [a 1
         b 1
         l [a b]
         n (- n 2)]
    (if (pos? n)
      (recur b (+ a b) (conj l (+ a b)) (dec n))
      l)))

* ;; 4Clojure Question 27

#+BEGIN_SRC clojure


;; Write a function which returns true if the given sequence is a
;; palindrome.<br/><br> Hint: "racecar" does not equal '(\r \a \c \e
;; \c \a \r) Use M-x 4clojure-check-answers when you're done!

(false? (__ '(1 2 3 4 5)))

(true? (__ "racecar"))

(true? (__ [:foo :bar :foo]))

(true? (__ '(1 1 3 3 1 1)))

(false? (__ '(:a :b :c)))
#+END_SRC

** solutions
(fn palin [lst] 
   (if 
     (string? lst)
     (cond 
      (= lst (clojure.string/join (reverse lst))) true
      :else false)
     (cond 
      (= lst (reverse lst)) true
      :else false)))

------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [xs] (= (map identity xs) (reverse xs)))
------------------------------------------------------------------------------------------------
darren's solution:
#(= (seq %) (reverse %))
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(= (seq %) (reverse %))
------------------------------------------------------------------------------------------------
wills's solution:
#( if (string? %)
    (= (str %) (reduce str (reverse %)))
    (= % (reverse %)))
------------------------------------------------------------------------------------------------
foantell's solution:
#(= (seq %) (reverse %))
------------------------------------------------------------------------------------------------
aceeca1's solution:
#(= (reverse %) (seq %))
------------------------------------------------------------------------------------------------
adereth's solution:
#(= (reverse %) (seq %))
------------------------------------------------------------------------------------------------
austintaylor's solution:
#(= (reverse %) (seq %))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn palindrome [xs]
  ((fn helper [ys zs]
    (cond
      (and (empty? ys) (empty? zs)) true
      (or (empty? ys) (empty? zs)) false
      (= (first ys) (first zs)) (helper (rest ys) (rest zs))
      true false
    )
  )  xs (reverse xs) )
)
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(= (apply str (reverse %)) (apply str %))
------------------------------------------------------------------------------------------------
dlee's solution:
#(= (apply str (reverse %)) (apply str %))
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [x] (= (reverse x) (seq x)))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(= (seq %) (reverse %))
------------------------------------------------------------------------------------------------
icamts's solution:
#(= (seq %) (reverse %))
------------------------------------------------------------------------------------------------
jimm's solution:
#(= (seq %) (reverse (seq %)))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s] 
  (let [v (vec s)] 
    (let [l (int (/ (count v) 2))] 
      (= (take l v) (reverse (take-last l v))))))
------------------------------------------------------------------------------------------------
ming's solution:
(fn [s]
  (let [s (vec s)]
  	(= (reverse s) s)))
------------------------------------------------------------------------------------------------
ramo's solution:
#(= (reverse %) (seq %))
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn [in] (= (seq in) (reverse in)))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [lst]
  (loop [l (seq lst)]
    (cond
      (= (last l) (first l))
        (if (< 1 (count l))
          (recur (drop 1 (butlast l)))
          true)
      :else false)))

* ;; 4Clojure Question 28

#+BEGIN_SRC clojure


;; Write a function which flattens a sequence. Restrictions (please
;; don't use these function(s)): flatten 

(= (__ '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6))

(= (__ ["a" ["b"] "c"]) '("a" "b" "c"))

(= (__ '((((:a))))) '(:a))
#+END_SRC

** solutions



Solutions:

(fn [lst] (filter (complement sequential?)
          	(rest (tree-seq sequential? seq lst))))
0x89's solution:
Scored 118, before 4clojure started saving solutions.
------------------------------------------------------------------------------------------------
_pcl's solution:
reduce
(fn self [xs e] (concat xs (cond (coll? e) (reduce self '() e) true (list e))))
'()
------------------------------------------------------------------------------------------------
darren's solution:
#(remove % (tree-seq % seq %2)) sequential?
------------------------------------------------------------------------------------------------
amcnamara's solution:
(fn f [r [a & b]]
  (if a
    (if (coll? a)
      (f (into r (f [] a)) b)
      (f (into r [a]) b))
    r))
[]
------------------------------------------------------------------------------------------------
wills's solution:
#(filter (complement sequential?)
   (rest (tree-seq sequential? seq %)))
------------------------------------------------------------------------------------------------
foantell's solution:
(fn [coll] 
  (filter (complement sequential?)
          (rest (tree-seq sequential? identity coll))))
------------------------------------------------------------------------------------------------
aceeca1's solution:
#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))
------------------------------------------------------------------------------------------------
adereth's solution:
(fn [s]
  (loop [s s]
    (if (some sequential? s)
      (recur (reduce (fn [acc v]
                (if (sequential? v)
                  (concat acc v)
                  (concat acc [v])
                  ))
              []
              s))
      s)
    )
)
------------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [s]
  (filter (complement sequential?)
    (tree-seq sequential? seq s)))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn fake [xs]
  (cond
    (empty? xs)
      (list )
    (or (list? (first xs)) (vector? (first xs)))
      (concat (fake (first xs)) (fake (rest xs)))
    true
      (concat (list (first xs)) (fake (rest xs)))
  )
)
------------------------------------------------------------------------------------------------
ctzsm's solution:
(fn fla [x]
  (if (coll? x)
    (when (seq x) (concat (fla (first x)) (fla (rest x))))
    [x])
  )
------------------------------------------------------------------------------------------------
dlee's solution:
(fn [a] (loop [t a]  
           (if (empty? (for [x t :when (coll? x)] x))
            t
            (recur (reduce concat (for [x t] (if(coll? x) x (list x)))))
           )
         )
)
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn my-flatten
    [ r s ]
    (if (not (or (list? s) (vector? s)))
        (conj r s)
        (reduce my-flatten r (reverse s)))) ()
------------------------------------------------------------------------------------------------
glchapman's solution:
(letfn [
  (myflatten [coll]
    (mapcat #(if (coll? %) (myflatten %) [%]) coll)
  )]
  #(myflatten %))
------------------------------------------------------------------------------------------------
icamts's solution:
#(filter (complement sequential?) (tree-seq sequential? identity %))
------------------------------------------------------------------------------------------------
jimm's solution:
(fn [coll]
    (letfn [(f [coll]
              (loop [coll coll
                     answer []]
                (cond
                 (nil? coll) answer
                 (seq? (first coll)) (recur (next coll) (vec (concat (f (first coll)) answer)))
                 (vector? (first coll)) (recur (next coll) (vec (concat answer (f (first coll)))))
                 :else (recur (next coll) (conj answer (first coll))))))]
      (f coll)))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s]
  (loop [remaining s
         result []]
    (if (empty? remaining)
      result
      (let [x (first remaining)]
        (if (sequential? x)
          (recur (concat x (rest remaining)) result)
          (recur (rest remaining) (conj result x)))))))
------------------------------------------------------------------------------------------------
ming's solution:
#(some (fn [s] (if (not-any? coll? s) s false)) (iterate 
                                (fn [s] 
                                  (loop [ret []
                                         tmp s]
                            		(if (empty? tmp)
                                      ret
                                      (recur (if (coll? (first tmp)) 
                                                (into ret (first tmp))
                                                (conj ret (first tmp)) )
                                             (rest tmp))))) 
                                %))
------------------------------------------------------------------------------------------------
ramo's solution:
(fn flat [x]
   (mapcat 
    #(if (coll? %)
       (flat %)
       (list %))
    x))
------------------------------------------------------------------------------------------------
thegeez's solution:
(fn fl [in]
  (mapcat (fn [item]
    (if (sequential? item)
(fl (seq item))
[item])) in))
------------------------------------------------------------------------------------------------
benizi's solution:
(fn [l]
  (loop [q l
         acc []]
    (if (empty? q)
      acc
      (let [f (first q)
            r (rest q)]
        (if (sequential? f)
          (recur (concat f r) acc)
          (recur r (conj acc f)))))))

* ;; 4Clojure Question 29

#+BEGIN_SRC clojure


;; Write a function which takes a string and returns a new string
;; containing only the capital letters. Use M-x 4clojure-check-answers
;; when you're done!

(= (__ "HeLlO, WoRlD!") "HLOWRD")

(empty? (__ "nothing"))

(= (__ "$#A(*&987Zf") "AZ")
#+END_SRC

** solutions



Solutions:

(fn [x] (apply str (re-seq #"[A-Z]" x)))
0x89's solution:
Scored 115, before 4clojure started saving solutions.
------------------------------------------------------------------------------------------------
_pcl's solution:
(fn [s] (apply str (filter #(not= (.toLowerCase (str %)) (str %)) s)))
------------------------------------------------------------------------------------------------
darren's solution:
#(apply str (filter (fn [c] (< 64 (int c) 91)) %))
------------------------------------------------------------------------------------------------
amcnamara's solution:
#(apply str (re-seq #"[A-Z]" %))
------------------------------------------------------------------------------------------------
wills's solution:
(fn [x] 
     (loop [lst (re-seq #"[A-Z]" x)
            ans ""] 
        (if (empty? lst)
          ans
          (recur (rest lst) (str ans (first lst))))))
------------------------------------------------------------------------------------------------
foantell's solution:
#(apply str (re-seq #"[A-Z]" %))
------------------------------------------------------------------------------------------------
aceeca1's solution:
#(clojure.string/replace % #"[^A-Z]" "")
------------------------------------------------------------------------------------------------
adereth's solution:
(fn [s] (reduce str (filter #(Character/isUpperCase %) s)))
------------------------------------------------------------------------------------------------
austintaylor's solution:
#(apply str (re-seq #"[A-Z]" %))
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [x] (.replaceAll x "[^A-Z]" "") )
------------------------------------------------------------------------------------------------
ctzsm's solution:
#(apply str (clojure.string/split % #"[^A-Z]"))
------------------------------------------------------------------------------------------------
dlee's solution:
#(apply str (re-seq #"[A-Z]+" %))
------------------------------------------------------------------------------------------------
echevarria's solution:
(fn [s] (reduce str (re-seq #"[A-Z]" s)))
------------------------------------------------------------------------------------------------
glchapman's solution:
#(clojure.string/replace % #"[^A-Z]+" "")
------------------------------------------------------------------------------------------------
icamts's solution:
#(reduce str (re-seq #"[A-Z]" %))
------------------------------------------------------------------------------------------------
jimm's solution:
(fn [s]
    (apply str (for [c s :when (Character/isUpperCase c)] c)))
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s]
  (apply str (re-seq #"[A-Z]" s)))
------------------------------------------------------------------------------------------------
ming's solution:
(fn [s] (apply str (filter #(<= 65 (int %) 90) s)))
------------------------------------------------------------------------------------------------
ramo's solution:
#(apply str (re-seq #"[A-Z]" %))
------------------------------------------------------------------------------------------------
thegeez's solution:
#(apply str (filter (fn [c] (Character/isUpperCase c)) %))
------------------------------------------------------------------------------------------------
benizi's solution:
#(apply str (re-seq #"[A-Z]" %))

* ;; 4Clojure Question 30

#+BEGIN_SRC clojure


;; Write a function which removes consecutive duplicates from a
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= (apply str (__ "Leeeeeerrroyyy")) "Leroy")

(= (__ [1 1 2 3 3 2 2 3]) '(1 2 3 2 3))

(= (__ [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2]))
#+END_SRC

** solutions



Solutions:

partition-by (fn [x] x)
0x89's solution:
Scored 29, before 4clojure started saving solutions.
------------------------------------------------------------------------------------------------
_pcl's solution:
partition-by identity
------------------------------------------------------------------------------------------------
darren's solution:
partition-by str
------------------------------------------------------------------------------------------------
amcnamara's solution:
partition-by identity
------------------------------------------------------------------------------------------------
wills's solution:
(fn [x] (reverse 
                (reduce #(if (= (first (first %1)) %2)
                            (conj  (rest %) (cons %2 (first %)))
                            (conj % (list %2))) () x)))
------------------------------------------------------------------------------------------------
foantell's solution:
#(partition-by identity %)
------------------------------------------------------------------------------------------------
aceeca1's solution:
partition-by identity
------------------------------------------------------------------------------------------------
adereth's solution:
partition-by identity
------------------------------------------------------------------------------------------------
austintaylor's solution:
(partial partition-by identity)
------------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn pack [xs]
   (reverse ((fn helper [xs last accu]
     (cond
      (empty? xs) (cons last accu)
      (= (first xs) (first last)) 
        (recur (rest xs) (cons (first xs) last) accu)
      :else 
        (recur (rest xs) (list (first xs)) (cons last accu))))
    (rest xs) (list (first xs)) nil)))
------------------------------------------------------------------------------------------------
ctzsm's solution:
partition-by identity
------------------------------------------------------------------------------------------------
dlee's solution:
partition-by identity
------------------------------------------------------------------------------------------------
echevarria's solution:
partition-by identity
------------------------------------------------------------------------------------------------
glchapman's solution:
#(partition-by identity %)
------------------------------------------------------------------------------------------------
icamts's solution:
partition-by identity
------------------------------------------------------------------------------------------------
jimm's solution:
#(partition-by identity %)
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s]
  (reduce 
    (fn [a b] 
      (if (= (last (last a)) b) 
        (conj (subvec a 0 (dec (count a))) (conj (last a) b))
        (conj a [b]))) [] s))
------------------------------------------------------------------------------------------------
ming's solution:
partition-by identity
------------------------------------------------------------------------------------------------
ramo's solution:
partition-by identity
------------------------------------------------------------------------------------------------
thegeez's solution:
partition-by identity
------------------------------------------------------------------------------------------------
benizi's solution:
#(partition-by identity %)

* ;; 4Clojure Question 31

#+BEGIN_SRC clojure


;; Write a function which packs consecutive duplicates into sub-lists.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ [1 1 2 1 1 1 3 3]) '((1 1) (2) (1 1 1) (3 3)))

(= (__ [:a :a :b :b :c]) '((:a :a) (:b :b) (:c)))

(= (__ [[1 2] [1 2] [3 4]]) '(([1 2] [1 2]) ([3 4])))
#+END_SRC

** solutions
Solutions:

partition-by (fn [x] x)
0x89's solution:
Scored 29, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
partition-by identity
----------------------------------------------------------------------------------------------
darren's solution:
partition-by str
----------------------------------------------------------------------------------------------
amcnamara's solution:
partition-by identity
----------------------------------------------------------------------------------------------
wills's solution:
(fn [x] (reverse 
                (reduce #(if (= (first (first %1)) %2)
                            (conj  (rest %) (cons %2 (first %)))
                            (conj % (list %2))) () x)))
----------------------------------------------------------------------------------------------
foantell's solution:
#(partition-by identity %)
----------------------------------------------------------------------------------------------


austintaylor's solution:
(partial partition-by identity)
----------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn pack [xs]
   (reverse ((fn helper [xs last accu]
     (cond
      (empty? xs) (cons last accu)
      (= (first xs) (first last)) 
        (recur (rest xs) (cons (first xs) last) accu)
      :else 
        (recur (rest xs) (list (first xs)) (cons last accu))))
    (rest xs) (list (first xs)) nil)))
----------------------------------------------------------------------------------------------
ctzsm's solution:
partition-by identity

----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s]
  (reduce 
    (fn [a b] 
      (if (= (last (last a)) b) 
        (conj (subvec a 0 (dec (count a))) (conj (last a) b))
        (conj a [b]))) [] s))

* ;; 4Clojure Question 32

#+BEGIN_SRC clojure


;; Write a function which duplicates each element of a sequence. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3]) '(1 1 2 2 3 3))

(= (__ [:a :a :b :b]) '(:a :a :a :a :b :b :b :b))

(= (__ [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))

(= (__ [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))
#+END_SRC

** Solutions
Account SettingsLeaguesSubmit a Problem

Solutions:

(fn dupps [lst]
   (cond (empty? lst) ()
         :else (cons (first lst)
                     (cons (first lst)
                           (dupps (rest lst))))))
0x89's solution:
Scored 43, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
reduce #(conj %1 %2 %2) []
----------------------------------------------------------------------------------------------
darren's solution:
mapcat #(list % %)
----------------------------------------------------------------------------------------------
amcnamara's solution:
#(mapcat list % %)
----------------------------------------------------------------------------------------------
wills's solution:
#(reduce (fn [lst x] (concat lst [x x])) [] %)
----------------------------------------------------------------------------------------------
foantell's solution:
#(interleave % %)
----------------------------------------------------------------------------------------------
aceeca1's solution:
mapcat #(list % %)
----------------------------------------------------------------------------------------------
adereth's solution:
(fn [s] (loop [s s r '()]
          (if (seq s)
            (recur (rest s) (concat r [(first s) 
                                       (first s)]))
                                    
            r)
          )
  )
----------------------------------------------------------------------------------------------
austintaylor's solution:
#(interleave % %)
----------------------------------------------------------------------------------------------
bradkaiser's solution:
mapcat (fn [x] (list x x))
----------------------------------------------------------------------------------------------
ctzsm's solution:
#(interleave % %)
----------------------------------------------------------------------------------------------
dlee's solution:
mapcat (partial repeat 2)
----------------------------------------------------------------------------------------------
echevarria's solution:
reduce (fn [l x] (concat l (list x x))) ()
----------------------------------------------------------------------------------------------
glchapman's solution:
#(mapcat (fn [x] [x x]) %)
----------------------------------------------------------------------------------------------
icamts's solution:
#(interleave % %)
----------------------------------------------------------------------------------------------
jimm's solution:
(fn [coll]
    (mapcat #(list % %) coll))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#(reduce (fn [a b] (conj a b b)) [] %)
----------------------------------------------------------------------------------------------
ming's solution:
#(reduce 
   into
   (for [x %]
     [x x]))
----------------------------------------------------------------------------------------------
ramo's solution:
#(interleave % %)
----------------------------------------------------------------------------------------------
thegeez's solution:
(partial mapcat (juxt identity identity))
----------------------------------------------------------------------------------------------
benizi's solution:
#(mapcat (fn [a] (list a a)) %)
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 33

#+BEGIN_SRC clojure


;; Write a function which replicates each element of a sequence a
;; variable number of times. 

(= (__ [1 2 3] 2) '(1 1 2 2 3 3))

(= (__ [:a :b] 4) '(:a :a :a :a :b :b :b :b))

(= (__ [4 5 6] 1) '(4 5 6))

(= (__ [[1 2] [3 4]] 2) '([1 2] [1 2] [3 4] [3 4]))

(= (__ [44 33] 2) [44 44 33 33])
#+END_SRC

** Solutions

Solutions:

(fn [lst n] 
  (if (> n 1) 
    (apply interleave (take n (repeat lst)))
  	lst))
0x89's solution:
Scored 44, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(fn [xs i] (reduce #(concat %1 (replicate i %2)) [] xs))
----------------------------------------------------------------------------------------------
darren's solution:
#(mapcat (partial repeat %2) %)
----------------------------------------------------------------------------------------------
amcnamara's solution:
#(apply mapcat list (repeat %2 %))
----------------------------------------------------------------------------------------------
wills's solution:
(fn [lst n] (mapcat (fn [x] (repeat n x)) lst))
----------------------------------------------------------------------------------------------
foantell's solution:
#(mapcat (fn [x] (repeat %2 x)) %)
----------------------------------------------------------------------------------------------
aceeca1's solution:
(fn [x t] (mapcat (partial repeat t) x))
----------------------------------------------------------------------------------------------
adereth's solution:
(fn [s n]
  (if (= n 1) s
  	(apply interleave (repeat n s))))
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [s n]
  (mapcat (partial repeat n) s))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#(mapcat (fn [x] (repeat %2 x)) %)
----------------------------------------------------------------------------------------------
ctzsm's solution:
#(mapcat (partial repeat %2) %)
----------------------------------------------------------------------------------------------
dlee's solution:
(fn [x n] (mapcat (partial repeat n) x))
----------------------------------------------------------------------------------------------
echevarria's solution:
(fn [l n](mapcat #(apply conj [] (repeat n %1)) l))
----------------------------------------------------------------------------------------------
glchapman's solution:
#(mapcat (fn [x] (repeat %2 x)) %1)
----------------------------------------------------------------------------------------------
icamts's solution:
#(mapcat (fn [x] (repeat %2 x)) %1)
----------------------------------------------------------------------------------------------
jimm's solution:
(fn [coll n]
    (mapcat #(repeat n %) coll))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s n]
  (for [x s i (range n)]
    x))
----------------------------------------------------------------------------------------------
ming's solution:
#(apply concat (for [x %1]
   (repeat %2 x)))
----------------------------------------------------------------------------------------------
ramo's solution:
#(mapcat (partial repeat %2) %1)
----------------------------------------------------------------------------------------------
thegeez's solution:
(fn [items nrepeat]
  (mapcat (partial repeat nrepeat) items))
----------------------------------------------------------------------------------------------
benizi's solution:
(fn [lst n]
  (mapcat #(repeat n %) lst))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 34

#+BEGIN_SRC clojure


;; Write a function which creates a list of all integers in a given
;; range. Restrictions (please don't use these function(s)): range Use
;; M-x 4clojure-check-answers when you're done!

(= (__ 1 4) '(1 2 3))

(= (__ -2 2) '(-2 -1 0 1))

(= (__ 5 8) '(5 6 7))
#+END_SRC

** Solutions

Solutions:

(fn rng [x y]
	  (cond (= x y) ()
    	    :else (cons x (rng (inc x) y))))
0x89's solution:
Scored 52, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(fn [s e] (reduce #(conj %1 (+ s (count %1) %2)) [] (replicate (- e s) 0)))
----------------------------------------------------------------------------------------------
darren's solution:
#(take (- %2 %) (iterate inc %))
----------------------------------------------------------------------------------------------
amcnamara's solution:
#(take (- %2 %) (iterate inc %))
----------------------------------------------------------------------------------------------
wills's solution:
(fn [x y]
   (loop [ans [x]
          x (inc x)]
     (if (< (first ans) (dec y))
       (recur (cons x ans) (inc x))
       (reverse ans))))
----------------------------------------------------------------------------------------------
foantell's solution:
#(take (- %2 %) (iterate inc %))
----------------------------------------------------------------------------------------------
aceeca1's solution:
(fn [s t] (reductions + (merge (repeat (dec (- t s)) 1) s)))
----------------------------------------------------------------------------------------------
adereth's solution:
(fn [start end] (take-while #(< % end)
                            (iterate inc start)
                            )
  )
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [a b]
  (map-indexed + (repeat (- b a) a)))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn bob [min max]
  (if (>= min max) 
    nil
    (cons min (bob (inc min) max)
    )
  )
)
----------------------------------------------------------------------------------------------
ctzsm's solution:
#(take (- %2 %1) (iterate (fn [x] (+ x 1)) %1))
----------------------------------------------------------------------------------------------
dlee's solution:
#(reduce (fn [a b] (conj a (+ b (count a)))) [] (repeat (- %2 %1) %1))
----------------------------------------------------------------------------------------------
echevarria's solution:
(fn [b e] (take-while (partial > e) (iterate inc b)))
----------------------------------------------------------------------------------------------
glchapman's solution:
#(take-while (fn [x] (< x %2)) (iterate inc %1))
----------------------------------------------------------------------------------------------
icamts's solution:
#(take (- %2 %) (iterate inc %))
----------------------------------------------------------------------------------------------
jimm's solution:
(fn [start stop]
    (take (- stop start) (iterate inc start)))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [a b]
  (loop [x a r []]
    (if (< x b)
      (recur (inc x) (conj r x))
      r)))
----------------------------------------------------------------------------------------------
ming's solution:
#(take (- %2 %1) (iterate inc %1))
----------------------------------------------------------------------------------------------
ramo's solution:
(fn [a b] (take (- b a) (iterate #(inc %) a)))
----------------------------------------------------------------------------------------------
thegeez's solution:
(fn [lo up]
  (take-while #(< % up) (iterate inc lo)))
----------------------------------------------------------------------------------------------
benizi's solution:
(fn [low high]
  (loop [acc []
         n low]
    (if (= n high)
      acc
      (recur (conj acc n) (inc n)))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 35

#+BEGIN_SRC clojure


;; Clojure lets you give local names to values using the special
;; let-form. Use M-x 4clojure-check-answers when you're done!

(= __ (let [x 5] (+ 2 x)))

(= __ (let [x 3, y 10] (- y x)))

(= __ (let [x 21] (let [y 3] (/ x y))))
#+END_SRC

** Solutions

Solutions:

7
0x89's solution:
7
----------------------------------------------------------------------------------------------
_pcl's solution:
7
----------------------------------------------------------------------------------------------
darren's solution:
7
----------------------------------------------------------------------------------------------
amcnamara's solution:
7
----------------------------------------------------------------------------------------------
wills's solution:
7
----------------------------------------------------------------------------------------------
foantell's solution:
7
----------------------------------------------------------------------------------------------
aceeca1's solution:
7
----------------------------------------------------------------------------------------------
adereth's solution:
7
----------------------------------------------------------------------------------------------
austintaylor's solution:
7
----------------------------------------------------------------------------------------------
bradkaiser's solution:
7
----------------------------------------------------------------------------------------------
ctzsm's solution:
7
----------------------------------------------------------------------------------------------
dlee's solution:
7
----------------------------------------------------------------------------------------------
echevarria's solution:
7
----------------------------------------------------------------------------------------------
glchapman's solution:
7
----------------------------------------------------------------------------------------------
icamts's solution:
7
----------------------------------------------------------------------------------------------
jimm's solution:
7
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
7
----------------------------------------------------------------------------------------------
ming's solution:
7
----------------------------------------------------------------------------------------------
ramo's solution:
7
----------------------------------------------------------------------------------------------
thegeez's solution:
7
----------------------------------------------------------------------------------------------
benizi's solution:
7
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 36

#+BEGIN_SRC clojure


;; Can you bind x, y, and z so that these are all true? 

(= 10 (let __ (+ x y)))

(= 4 (let __ (+ y z)))

(= 1 (let __ z))
#+END_SRC

** Solutions

Solutions:

[z 1
 y 3
 x 7]
0x89's solution:
[z 1
 y 3
 x 7]
----------------------------------------------------------------------------------------------
_pcl's solution:
[x 7, y 3, z 1]
----------------------------------------------------------------------------------------------
darren's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
amcnamara's solution:
[x 7
 y 3
 z 1]
----------------------------------------------------------------------------------------------
wills's solution:
[z 1 
 y 3 
 x 7]
----------------------------------------------------------------------------------------------
foantell's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
aceeca1's solution:
[z 1 y 3 x 7]
----------------------------------------------------------------------------------------------
adereth's solution:
[z 1 y 3 x 7]
----------------------------------------------------------------------------------------------
austintaylor's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
bradkaiser's solution:
[z 1 y 3 x 7]
----------------------------------------------------------------------------------------------
ctzsm's solution:
[x 7, y 3, z 1]
----------------------------------------------------------------------------------------------
dlee's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
echevarria's solution:
[ x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
glchapman's solution:
[x 7, y 3, z 1]
----------------------------------------------------------------------------------------------
icamts's solution:
[ x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
jimm's solution:
[z 1 y 3 x 7]
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
ming's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
ramo's solution:
[z 1 y (- 4 z) x (- 10 y)]
----------------------------------------------------------------------------------------------
thegeez's solution:
[x 7 y 3 z 1]
----------------------------------------------------------------------------------------------
benizi's solution:
[z 1 y 3 x 7]
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 37

#+BEGIN_SRC clojure


;; Regex patterns are supported with a special reader macro. 

(= __ (apply str (re-seq #"[A-Z]+" "bA1B3Ce ")))
#+END_SRC

** Solutions

Solutions:

"ABC"
0x89's solution:
"ABC"
----------------------------------------------------------------------------------------------
_pcl's solution:
"ABC"
----------------------------------------------------------------------------------------------
darren's solution:
"ABC"
----------------------------------------------------------------------------------------------
amcnamara's solution:
"ABC"
----------------------------------------------------------------------------------------------
wills's solution:
"ABC"
----------------------------------------------------------------------------------------------
foantell's solution:
"ABC"
----------------------------------------------------------------------------------------------
aceeca1's solution:
"ABC"
----------------------------------------------------------------------------------------------
adereth's solution:
"ABC"
----------------------------------------------------------------------------------------------
austintaylor's solution:
"ABC"
----------------------------------------------------------------------------------------------
bradkaiser's solution:
"ABC"
----------------------------------------------------------------------------------------------
ctzsm's solution:
"ABC"
----------------------------------------------------------------------------------------------
dlee's solution:
"ABC"
----------------------------------------------------------------------------------------------
echevarria's solution:
"ABC"
----------------------------------------------------------------------------------------------
glchapman's solution:
"ABC"
----------------------------------------------------------------------------------------------
icamts's solution:
"ABC"
----------------------------------------------------------------------------------------------
jimm's solution:
"ABC"
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
"ABC"
----------------------------------------------------------------------------------------------
ming's solution:
"ABC"
----------------------------------------------------------------------------------------------
ramo's solution:
"ABC"
----------------------------------------------------------------------------------------------
thegeez's solution:
"ABC"
----------------------------------------------------------------------------------------------
benizi's solution:
"ABC"
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 38

#+BEGIN_SRC clojure


;; Write a function which takes a variable number of parameters and
;; returns the maximum value. Restrictions (please don't use these
;; function(s)): max, max-key 

(= (__ 1 8 3 4) 8)

(= (__ 30 20) 30)

(= (__ 45 67 11) 67)
#+END_SRC

** Solutions

Solutions:

(fn [& args]
	(first (sort > args)))
0x89's solution:
Scored 35, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(fn [x & xs] (reduce #(if (> %2 %1) %2 %1) x xs))
----------------------------------------------------------------------------------------------
darren's solution:
#(last (sort %&))
----------------------------------------------------------------------------------------------
amcnamara's solution:
#(last (sort %&))
----------------------------------------------------------------------------------------------
wills's solution:
(fn tess 
   ([x] x)
   ([x y] (if (> x y) x y))
   ([x y & more] (reduce tess (tess x y) more)))
----------------------------------------------------------------------------------------------
foantell's solution:
(fn [& args] (reduce #(if (> %1 %2) %1 %2) args))
----------------------------------------------------------------------------------------------
aceeca1's solution:
(comp - (partial apply min) (partial map -) list)
----------------------------------------------------------------------------------------------
adereth's solution:
(fn [ & xs ]
  (reduce #(if (> %1 %2) %1 %2) xs))
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [& xs]
  (reduce #(if (> %2 %1) %2 %1) xs))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [& coll] 
  (reduce (fn [a b] (if (> a b) a b)) coll)
)
----------------------------------------------------------------------------------------------
ctzsm's solution:
(fn [& coll] (reduce #(if (> %1 %2) %1 %2) coll))
----------------------------------------------------------------------------------------------
dlee's solution:
(comp last sort list)
----------------------------------------------------------------------------------------------
echevarria's solution:
(fn [ & xs] (last (apply sorted-set xs)))
----------------------------------------------------------------------------------------------
glchapman's solution:
(comp (partial reduce #(if (>= %1 %2) %1 %2)) vector)
----------------------------------------------------------------------------------------------
icamts's solution:
#(->> %& (reduce (fn [x y] (if (< x y) y x))))
----------------------------------------------------------------------------------------------
jimm's solution:
(fn [& coll] (loop [c coll mx -99999]
                   (if c (recur (next c) (if (> (first c) mx) (first c)
                                             mx))
                       mx)))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [& s] 
  (reduce (fn [a b] (if (> a b) a b)) s))
----------------------------------------------------------------------------------------------
ming's solution:
(fn [& args] (reduce #(if (> %1 %2) %1 %2) args))
----------------------------------------------------------------------------------------------
ramo's solution:
#(last (sort %&))
----------------------------------------------------------------------------------------------
thegeez's solution:
(fn [& args]
  (reduce (fn [a b] (if (< a b) b a)) args))
----------------------------------------------------------------------------------------------
benizi's solution:
(fn [& args]
  (reduce (fn [a b] (if (< a b) b a)) args))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 39

#+BEGIN_SRC clojure


;; Write a function which takes two sequences and returns the first
;; item from each, then the second item from each, then the third,
;; etc. Restrictions (please don't use these function(s)): interleave
;; Use M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))

(= (__ [1 2] [3 4 5 6]) '(1 3 2 4))

(= (__ [1 2 3 4] [5]) [1 5])

(= (__ [30 20] [25 15]) [30 25 20 15])
#+END_SRC

** Solutions

Solutions:

mapcat #(vec [%1 %2])
0x89's solution:
Scored 42, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(fn [xs ys]
    (reduce
      #(concat (rest %1) (list (first %1) %2))
      (take (count ys) xs)
      (take (count xs) ys)))
----------------------------------------------------------------------------------------------
darren's solution:
mapcat list
----------------------------------------------------------------------------------------------
amcnamara's solution:
mapcat list
----------------------------------------------------------------------------------------------
wills's solution:
mapcat (fn [x y] [x y])
----------------------------------------------------------------------------------------------
foantell's solution:
(fn [coll1 coll2]
  (mapcat vector coll1 coll2))
----------------------------------------------------------------------------------------------
aceeca1's solution:
mapcat #(list %1 %2)
----------------------------------------------------------------------------------------------
adereth's solution:
(fn [s1 s2]
  (flatten (map list s1 s2)))
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [a0 b0]
  (loop [a a0 b b0 result '()]
    (if (and (seq a) (seq b))
      (recur
        (rest a)
        (rest b)
        (conj result (first a) (first b)))
      (reverse result))))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn [xs ys]
   (mapcat (fn [x y] (list x y)) xs ys)
 )
----------------------------------------------------------------------------------------------
ctzsm's solution:
(fn [c1 c2] (apply concat (map #(conj [] % %2) c1 c2)))
----------------------------------------------------------------------------------------------
dlee's solution:
mapcat list
----------------------------------------------------------------------------------------------
echevarria's solution:
mapcat (fn [x y] [x y])
----------------------------------------------------------------------------------------------
glchapman's solution:
#(mapcat (fn [x y] [x y]) %1 %2)
----------------------------------------------------------------------------------------------
icamts's solution:
(fn [l1 l2] (loop [c1 l1 c2 l2 res []]
              (cond (or (empty? c1) (empty? c2)) res 
                    :else (recur (rest c1) (rest c2) (conj (conj res (first c1)) (first c2))))))
----------------------------------------------------------------------------------------------
jimm's solution:
(comp flatten map) #(list %1 %2)
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [a b]
  (loop [x a
         y b
         result []]
    (let [v1 (first x)
          v2 (first y)]
      (if (and v1 v2)
        (recur (rest x) (rest y) (conj result v1 v2))
        result))))
----------------------------------------------------------------------------------------------
ming's solution:
mapcat list
----------------------------------------------------------------------------------------------
ramo's solution:
mapcat #(list %1 %2)
----------------------------------------------------------------------------------------------
thegeez's solution:
mapcat list
----------------------------------------------------------------------------------------------
benizi's solution:
(fn [x y]
  (mapcat #(vector % %2) x y))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 40
;; Write a function which separates the items of a sequence by an
;; arbitrary value. Restrictions (please don't use these function(s)):
;; interpose Use M-x 4clojure-check-answers when you're done!

(= (__ 0 [1 2 3]) [1 0 2 0 3])

(= (apply str (__ ", " ["one" "two" "three"])) "one, two, three")

(= (__ :z [:a :b :c :d]) [:a :z :b :z :c :z :d])

** Solutions

Solutions:

(fn [x lst] 
	 (butlast (mapcat  (fn [y] (vector y x))  lst)))
0x89's solution:
Scored 73, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(fn [s xs] (drop-last (reduce #(concat %1 [%2 s]) [] xs)))
----------------------------------------------------------------------------------------------
darren's solution:
#(rest (interleave (repeat %) %2))
----------------------------------------------------------------------------------------------
amcnamara's solution:
#(butlast (mapcat (fn [i] [i %]) %2))
----------------------------------------------------------------------------------------------
wills's solution:
#(drop 1 (interleave (repeat %) %2))
----------------------------------------------------------------------------------------------
foantell's solution:
(fn [interposer coll]
  (butlast (mapcat (fn [x]
            [x interposer]) coll)))
----------------------------------------------------------------------------------------------
aceeca1's solution:
(fn [s x] (cons (first x) (mapcat #(list s %) (next x))))
----------------------------------------------------------------------------------------------
adereth's solution:
#(butlast (interleave %2 (repeat %1)))
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [x s]
  (butlast (interleave s (repeat (count s) x))))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#(into [] (drop-last 1 (mapcat (fn [x] (list x %)) %2)))
----------------------------------------------------------------------------------------------
ctzsm's solution:
#(take (dec (* (count %2) 2)) (interleave %2 (repeat %)))
----------------------------------------------------------------------------------------------
dlee's solution:
#(rest (mapcat (partial (fn [x y] (list x y)) %1) %2))
----------------------------------------------------------------------------------------------
echevarria's solution:
(fn [ v s ] (drop-last (mapcat (fn [x] [x v]) s)))
----------------------------------------------------------------------------------------------
glchapman's solution:
#(reduce (fn [v x] (conj v %1 x)) [(first %2)] (rest %2))
----------------------------------------------------------------------------------------------
icamts's solution:
#(rest (mapcat (fn [x y] [y x]) %2 (repeat %)))
----------------------------------------------------------------------------------------------
jimm's solution:
(fn [sep coll]
    (drop 1 (flatten (map #(list sep %) coll))))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [d s]
  (reduce (fn [a b] (conj a d b)) [(first s)] (rest s)))
----------------------------------------------------------------------------------------------
ming's solution:
#(butlast (interleave %2 (repeat %1)))
----------------------------------------------------------------------------------------------
ramo's solution:
(fn [s l] (rest (mapcat #(list s %) l)))
----------------------------------------------------------------------------------------------
thegeez's solution:
(fn [sep items] (rest (interleave (repeat sep) items)))
----------------------------------------------------------------------------------------------
benizi's solution:
(fn [sep xs]
  (loop [acc [(first xs)]
         left (rest xs)]
    (if (seq left)
      (recur (conj acc sep (first left)) (rest left))
      acc)))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 41
;; Write a function which drops every Nth item from a sequence. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3 4 5 6 7 8] 3) [1 2 4 5 7 8])

(= (__ [:a :b :c :d :e :f] 2) [:a :c :e])

(= (__ [1 2 3 4 5 6] 4) [1 2 3 5 6])

** Solutions

Solutions:

#(mapcat (fn [lst]  
	     (if (= (count lst) %2)
	       (butlast lst)
	       lst))
	     (partition-all %2 %1))
0x89's solution:
Scored 70, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(fn [xs s]
  (map last
    (filter #(not= 0 (mod (first %1) s))
      (map-indexed #(list (+ 1 %1) %2) xs))))
----------------------------------------------------------------------------------------------
darren's solution:
#(remove nil? (map-indexed (fn [i x] (if (= 0 (mod (inc i) %2)) nil x)) %))
----------------------------------------------------------------------------------------------
amcnamara's solution:
(fn [c n]
  (mapcat #(take (dec n) %) (partition-all n c)))
----------------------------------------------------------------------------------------------
wills's solution:
(fn [coll pos] 
  (flatten (reduce (fn [coll x] (if (= (rem (inc (count coll)) pos) 0)
                   (conj coll '())
                   (conj coll x)))
          [] 
          coll)))
----------------------------------------------------------------------------------------------
foantell's solution:
#(apply concat (partition-all (dec %2) %2 %))
----------------------------------------------------------------------------------------------
aceeca1's solution:
(fn [x s] (remove nil? (map #(if %2 %1 nil) x (cycle (concat (repeat (dec s) true) '(false))))))
----------------------------------------------------------------------------------------------
adereth's solution:
(fn [coll n]
  (->> (partition-all n coll)
       (map (partial take (dec n)))
       (flatten)))
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [s x]
  (keep-indexed
    (fn [i a] (when (> (mod (inc i) x) 0) a))
    s))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#(map first (filter (fn [pair] (not= 0 (mod (inc (last pair)) %2)))
           (map list % (range ))
 ))
----------------------------------------------------------------------------------------------
ctzsm's solution:
(fn [coll n]
  (loop [coll coll n n ret []]
    (if (empty? coll)
      ret
      (recur (drop n coll) n (into ret (take (dec n) coll))))))
----------------------------------------------------------------------------------------------
dlee's solution:
(fn [c n] (mapcat identity (partition-all (dec n) n c)))
----------------------------------------------------------------------------------------------
echevarria's solution:
#(flatten (partition (- %2 1) %2 nil %1))
----------------------------------------------------------------------------------------------
glchapman's solution:
#(apply concat (partition-all (dec %2) %2 %1))
----------------------------------------------------------------------------------------------
icamts's solution:
#(mapcat (partial take (dec %2)) (partition-all %2 %))
----------------------------------------------------------------------------------------------
jimm's solution:
(fn [coll n]
    (loop [coll coll
           i 0
           answer []]
      (cond
       (nil? coll) answer
       (= (dec n) (mod i n)) (recur (next coll) (inc i) answer)
       :else (recur (next coll) (inc i) (conj answer (first coll))))))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [s n]
  (loop [remaining s
         result []]
    (if (empty? remaining)
      result
      (recur (drop n remaining) (concat result (take (dec n) remaining))))))
----------------------------------------------------------------------------------------------
ming's solution:
#(mapcat (partial take (dec %2)) (partition-all %2 %1))
----------------------------------------------------------------------------------------------
ramo's solution:
(fn [s n] (keep-indexed #(if (< 0 (mod (inc %1) n)) %2) s))
----------------------------------------------------------------------------------------------
thegeez's solution:
(fn [col n]
  (->> col 
    (partition-all n)
    (mapcat (partial take (dec n)))))
----------------------------------------------------------------------------------------------
benizi's solution:
(fn [list n]
  (loop [acc []
         i 1
         left list]
    (if (seq left)
      (recur (if (zero? (mod i n))
               acc
               (conj acc (first left)))
             (inc i)
             (rest left))
      acc)))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 42
;; Write a function which calculates factorials. 

(= (__ 1) 1)

(= (__ 3) 6)

(= (__ 5) 120)

(= (__ 8) 40320)

** Solutions

Solutions:

(fn [n]
  (reduce * (range 1 (inc n))))
0x89's solution:
Scored 30, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
((fn [r] 
  ((fn [f] (f f)) 
    (fn [y] 
      (r (fn [x] ((y y) x)))))) 
  (fn [fact] 
    (fn [n] 
      (if 
        (= 0 n) 1 
        (* n (fact (- n 1)))))))
----------------------------------------------------------------------------------------------
darren's solution:
#(apply * % (range 2 %))
----------------------------------------------------------------------------------------------
amcnamara's solution:
#(apply * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
wills's solution:
(fn [x] 
  (loop [curr x
        total 1]
    (if (= curr 0)
      total
      (recur (dec curr) (* curr total)))))
----------------------------------------------------------------------------------------------
foantell's solution:
#(reduce * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
aceeca1's solution:
#(reduce * (range % 0 -1))
----------------------------------------------------------------------------------------------
adereth's solution:
#(reduce * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
austintaylor's solution:
(fn [x]
  (reduce * (range 1 (inc x))))
----------------------------------------------------------------------------------------------
bradkaiser's solution:
(fn factorial [x]
  (if (= x 1) 
    1
    (* x (factorial (dec x)))
  )
)
----------------------------------------------------------------------------------------------
ctzsm's solution:
#(apply * (range 2 (+ 1 %)))
----------------------------------------------------------------------------------------------
dlee's solution:
#(reduce * (rest (range (inc %))))
----------------------------------------------------------------------------------------------
echevarria's solution:
#(apply * (map inc (range %1)))
----------------------------------------------------------------------------------------------
glchapman's solution:
#(apply * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
icamts's solution:
#(reduce * (map inc (range %)))
----------------------------------------------------------------------------------------------
jimm's solution:
#(loop [cnt % acc 1]
     (if (or (zero? cnt) (== 1 cnt)) acc
         (recur (dec cnt) (* acc cnt))))
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
(fn [x]
  (loop [i 1 v 1]
    (if (<= i x)
      (recur (inc i) (* v i))
      v)))
----------------------------------------------------------------------------------------------
ming's solution:
#(reduce * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
ramo's solution:
#(reduce * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
thegeez's solution:
#(reduce * (range 1 (inc %)))
----------------------------------------------------------------------------------------------
benizi's solution:
(fn fac [x]
  (if (< x 2) x
    (* x (fac (dec x)))))
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 43
;; Write a function which reverses the interleave process into x
;; number of subsequences. 

(= (__ [1 2 3 4 5 6] 2) '((1 3 5) (2 4 6)))

(= (__ (range 9) 3) '((0 3 6) (1 4 7) (2 5 8)))

(= (__ (range 10) 5) '((0 5) (1 6) (2 7) (3 8) (4 9)))

* ;; 4Clojure Question 44
;; Write a function which can rotate a sequence in either direction.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2 [1 2 3 4 5]) '(3 4 5 1 2))

(= (__ -2 [1 2 3 4 5]) '(4 5 1 2 3))

(= (__ 6 [1 2 3 4 5]) '(2 3 4 5 1))

(= (__ 1 '(:a :b :c)) '(:b :c :a))

(= (__ -4 '(:a :b :c)) '(:c :a :b))

* ;; 4Clojure Question 45
;; The iterate function can be used to produce an infinite lazy
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= __ (take 5 (iterate #(+ 3 %) 1)))

** Solutions

Solutions:

'(1 4 7 10 13)
0x89's solution:
Scored 9, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
(take 5 (iterate #(+ 3 %) 1))
----------------------------------------------------------------------------------------------
darren's solution:
[1 4 7 10 13]
----------------------------------------------------------------------------------------------
amcnamara's solution:
[1 4 7 10 13]
----------------------------------------------------------------------------------------------
wills's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
foantell's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
aceeca1's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
adereth's solution:
[1 4 7 10 13]
----------------------------------------------------------------------------------------------
austintaylor's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
bradkaiser's solution:
(list 1 4 7 10 13)
----------------------------------------------------------------------------------------------
ctzsm's solution:
(range 1 16 3)
----------------------------------------------------------------------------------------------
dlee's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
echevarria's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
glchapman's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
icamts's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
jimm's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
[1 4 7 10 13]
----------------------------------------------------------------------------------------------
ming's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
ramo's solution:
'(1 4 7 10 13)
----------------------------------------------------------------------------------------------
thegeez's solution:
[1 4 7 10 13]
----------------------------------------------------------------------------------------------
benizi's solution:
[1 4 7 10 13]
The content on 4clojure.com is available under the EPL v 1.0 license.Contact us
(team@4clojure.com)

* ;; 4Clojure Question 46
;; Write a higher-order function which flips the order of the
;; arguments of an input function. 

(= 3 ((__ nth) 2 [1 2 3 4 5]))

(= true ((__ >) 7 8))

(= 4 ((__ quot) 2 8))

(= [1 2 3] ((__ take) [1 2 3 4 5] 3))

* ;; 4Clojure Question 47
;; The contains? function checks if a KEY is present in a given
;; collection. This often leads beginner clojurians to use it
;; incorrectly with numerically indexed collections like vectors and
;; lists. Use M-x 4clojure-check-answers when you're done!

(contains? #{4 5 6} __)

(contains? [1 1 1 1 1] __)

(contains? {4 :a 2 :b} __)

(not (contains? '(1 2 4) __))
 
* ;; 4Clojure Question 48
;; The some function takes a predicate function and a collection. It
;; returns the first logical true value of (predicate x) where x is an
;; item in the collection. 

(= __ (some #{2 7 6} [5 6 7 8]))

(= __ (some #(when (even? %) %) [5 6 7 8]))

* ;; 4Clojure Question 49
;; Write a function which will split a sequence into two parts.
;; Restrictions (please don't use these function(s)): split-at 

(= (__ 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]])

(= (__ 1 [:a :b :c :d]) [[:a] [:b :c :d]])

(= (__ 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]])

* ;; 4Clojure Question 50
;; Write a function which takes a sequence consisting of items with
;; different types and splits them up into a set of homogeneous
;; sub-sequences. The internal order of each sub-sequence should be
;; maintained, but the sub-sequences themselves can be returned in any
;; order (this is why 'set' is used in the test cases). 

(= (set (__ [1 :a 2 :b 3 :c])) #{[1 2 3] [:a :b :c]})

(= (set (__ [:a "foo"  "bar" :b])) #{[:a :b] ["foo" "bar"]})

(= (set (__ [[1 2] :a [3 4] 5 6 :b])) #{[[1 2] [3 4]] [:a :b] [5 6]})

* ;; 4Clojure Question 51
;; Here is an example of some more sophisticated destructuring. Use
;; M-x 4clojure-check-answers when you're done!

(= [1 2 [3 4 5] [1 2 3 4 5]] (let [[a b & c :as d] __] [a b c d]))

* ;; 4Clojure Question 52
;; Let bindings and function parameter lists support destructuring.
;; Use M-x 4clojure-check-answers when you're done!

(= [2 4] (let [[a b c d e f g] (range)] __))

* ;; 4Clojure Question 53
;; Given a vector of integers, find the longest consecutive
;; sub-sequence of increasing numbers. If two sub-sequences have the
;; same length, use the one that occurs first. An increasing
;; sub-sequence must have a length of 2 or greater to qualify. 

(= (__ [1 0 1 2 3 0 4 5]) [0 1 2 3])

(= (__ [5 6 1 3 2 7]) [5 6])

(= (__ [2 3 3 4 5]) [3 4 5])

(= (__ [7 6 5 4]) [])

* ;; 4Clojure Question 54
;; Write a function which returns a sequence of lists of x items each.
;; Lists of less than x items should not be returned. Restrictions
;; (please don't use these function(s)): partition, partition-all Use
;; M-x 4clojure-check-answers when you're done!

(= (__ 3 (range 9)) '((0 1 2) (3 4 5) (6 7 8)))

(= (__ 2 (range 8)) '((0 1) (2 3) (4 5) (6 7)))

(= (__ 3 (range 8)) '((0 1 2) (3 4 5)))

* ;; 4Clojure Question 55
;; Write a function which returns a map containing the number of
;; occurences of each distinct item in a sequence. Restrictions
;; (please don't use these function(s)): frequencies 

(= (__ [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})

(= (__ [:b :a :b :a :b]) {:a 2, :b 3})

(= (__ '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2})

* ;; 4Clojure Question 56
;; Write a function which removes the duplicates from a sequence.
;; Order of the items must be maintained. Restrictions (please don't
;; use these function(s)): distinct Use M-x 4clojure-check-answers
;; when you're done!

(= (__ [1 2 1 3 1 2 4]) [1 2 3 4])

(= (__ [:a :a :b :b :c :c]) [:a :b :c])

(= (__ '([2 4] [1 2] [1 3] [1 3])) '([2 4] [1 2] [1 3]))

(= (__ (range 50)) (range 50))

* ;; 4Clojure Question 57
;; A recursive function is a function which calls itself. This is one
;; of the fundamental techniques used in functional programming. Use
;; M-x 4clojure-check-answers when you're done!

(= __ ((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5))

* ;; 4Clojure Question 58
;; Write a function which allows you to create function compositions.
;; The parameter list should take a variable number of functions, and
;; create a function applies them from right-to-left. Restrictions
;; (please don't use these function(s)): comp 

(= [3 2 1] ((__ rest reverse) [1 2 3 4]))

(= 5 ((__ (partial + 3) second) [1 2 3 4]))

(= true ((__ zero? #(mod % 8) +) 3 5 7 9))

(= "HELLO" ((__ #(.toUpperCase %) #(apply str %) take) 5 "hello world"))

* ;; 4Clojure Question 59
;; Take a set of functions and return a new function that takes a
;; variable number of arguments and returns a sequence containing the
;; result of applying each function left-to-right to the argument
;; list. Restrictions (please don't use these function(s)): juxt Use
;; M-x 4clojure-check-answers when you're done!

(= [21 6 1] ((__ + max min) 2 3 5 1 6 4))

(= ["HELLO" 5] ((__ #(.toUpperCase %) count) "hello"))

(= [2 6 4] ((__ :a :c :b) {:a 2, :b 4, :c 6, :d 8 :e 10}))

* ;; 4Clojure Question 60
;; Write a function which behaves like reduce, but returns each
;; intermediate value of the reduction. Your function must accept
;; either two or three arguments, and the return sequence must be
;; lazy. Restrictions (please don't use these function(s)): reductions
;; Use M-x 4clojure-check-answers when you're done!

(= (take 5 (__ + (range))) [0 1 3 6 10])

(= (__ conj [1] [2 3 4]) [[1] [1 2] [1 2 3] [1 2 3 4]])

(= (last (__ * 2 [3 4 5])) (reduce * 2 [3 4 5]) 120)

* ;; 4Clojure Question 61
;; Write a function which takes a vector of keys and a vector of
;; values and constructs a map from them. Restrictions (please don't
;; use these function(s)): zipmap 

(= (__ [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3})

(= (__ [1 2 3 4] ["one" "two" "three"]) {1 "one", 2 "two", 3 "three"})

(= (__ [:foo :bar] ["foo" "bar" "baz"]) {:foo "foo", :bar "bar"})

* ;; 4Clojure Question 62
;; Given a side-effect free function f and an initial value x write a
;; function which returns an infinite lazy sequence of x, (f x), (f (f
;; x)), (f (f (f x))), etc. Restrictions (please don't use these
;; function(s)): iterate 

(= (take 5 (__ #(* 2 %) 1)) [1 2 4 8 16])

(= (take 100 (__ inc 0)) (take 100 (range)))

(= (take 9 (__ #(inc (mod % 3)) 1)) (take 9 (cycle [1 2 3])))

* ;; 4Clojure Question 63
;; Given a function f and a sequence s, write a function which returns
;; a map. The keys should be the values of f applied to each item
;; in s. The value at each key should be a vector of corresponding
;; items in the order they appear in s. Restrictions (please don't use
;; these function(s)): group-by 

(= (__ #(> % 5) [1 3 6 8]) {false [1 3], true [6 8]})

(= (__ #(apply / %) [[1 2] [2 4] [4 6] [3 6]])
   {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]})

(= (__ count [[1] [1 2] [3] [1 2 3] [2 3]])
   {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]})

* ;; 4Clojure Question 64
;; <a
;; href='http://clojuredocs.org/clojure_core/clojure.core/reduce'>Reduce</a>
;; takes a 2 argument function and an optional starting value. It then
;; applies the function to the first 2 items in the sequence (or the
;; starting value and the first element of the sequence). In the next
;; iteration the function will be called on the previous return value
;; and the next item from the sequence, thus reducing the entire
;; collection to one value. Don't worry, it's not as complicated as it
;; sounds. Use M-x 4clojure-check-answers when you're done!

(= 15 (reduce __ [1 2 3 4 5]))

(=  0 (reduce __ []))

(=  6 (reduce __ 1 [2 3]))

* ;; 4Clojure Question 65
;; Clojure has many sequence types, which act in subtly different
;; ways. The core functions typically convert them into a uniform
;; "sequence" type and work with them that way, but it can be
;; important to understand the behavioral and performance differences
;; so that you know which kind is appropriate for your application.<br
;; /><br />Write a function which takes a collection and returns one
;; of :map, :set, :list, or :vector - describing the type of
;; collection it was given.<br />You won't be allowed to inspect their
;; class or use the built-in predicates like list? - the point is to
;; poke at them and understand their behavior. Restrictions (please
;; don't use these function(s)): class, type, Class, vector?,
;; sequential?, list?, seq?, map?, set?, instance?, getClass 

(= :map (__ {:a 1, :b 2}))

(= :list (__ (range (rand-int 20))))

(= :vector (__ [1 2 3 4 5 6]))

(= :set (__ #{10 (rand-int 5)}))

(= [:map :set :vector :list] (map __ [{} #{} [] ()]))

* ;; 4Clojure Question 66
;; Given two integers, write a function which returns the greatest
;; common divisor. Use M-x 4clojure-check-answers when you're done!

(= (__ 2 4) 2)

(= (__ 10 5) 5)

(= (__ 5 7) 1)

(= (__ 1023 858) 33)

* ;; 4Clojure Question 67
;; Write a function which returns the first x number of prime numbers.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2) [2 3])

(= (__ 5) [2 3 5 7 11])

(= (last (__ 100)) 541)

* ;; 4Clojure Question 68
;; Clojure only has one non-stack-consuming looping construct: recur.
;; Either a function or a loop can be used as the recursion point.
;; Either way, recur rebinds the bindings of the recursion point to
;; the values it is passed. Recur must be called from the
;; tail-position, and calling it elsewhere will result in an error.
;; Use M-x 4clojure-check-answers when you're done!

(= __
  (loop [x 5
         result []]
    (if (> x 0)
      (recur (dec x) (conj result (+ 2 x)))
      result)))

* ;; 4Clojure Question 69
;; Write a function which takes a function f and a variable number of
;; maps. Your function should return a map that consists of the rest
;; of the maps conj-ed onto the first. If a key occurs in more than
;; one map, the mapping(s) from the latter (left-to-right) should be
;; combined with the mapping in the result by calling (f val-in-result
;; val-in-latter) Restrictions (please don't use these function(s)):
;; merge-with Use M-x 4clojure-check-answers when you're done!

(= (__ * {:a 2, :b 3, :c 4} {:a 2} {:b 2} {:c 5})
   {:a 4, :b 6, :c 20})

(= (__ - {1 10, 2 20} {1 3, 2 10, 3 15})
   {1 7, 2 10, 3 15})

(= (__ concat {:a [3], :b [6]} {:a [4 5], :c [8 9]} {:b [7]})
   {:a [3 4 5], :b [6 7], :c [8 9]})

* ;; 4Clojure Question 70
;; Write a function that splits a sentence up into a sorted list of
;; words. Capitalization should not affect sort order and punctuation
;; should be ignored. Use M-x 4clojure-check-answers when you're done!

(= (__  "Have a nice day.")
   ["a" "day" "Have" "nice"])

(= (__  "Clojure is a fun language!")
   ["a" "Clojure" "fun" "is" "language"])

(= (__  "Fools fall for foolish follies.")
   ["fall" "follies" "foolish" "Fools" "for"])

* ;; 4Clojure Question 71
;; The -> macro threads an expression x through a variable number of
;; forms. First, x is inserted as the second item in the first form,
;; making a list of it if it is not a list already. Then the first
;; form is inserted as the second item in the second form, making a
;; list of that form if necessary. This process continues for all the
;; forms. Using -> can sometimes make your code more readable. 

(= (__ (sort (rest (reverse [2 5 4 1 3 6]))))
   (-> [2 5 4 1 3 6] (reverse) (rest) (sort) (__))
   5)

* ;; 4Clojure Question 72
;; The ->> macro threads an expression x through a variable number of
;; forms. First, x is inserted as the last item in the first form,
;; making a list of it if it is not a list already. Then the first
;; form is inserted as the last item in the second form, making a list
;; of that form if necessary. This process continues for all the
;; forms. Using ->> can sometimes make your code more readable. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ (map inc (take 3 (drop 2 [2 5 4 1 3 6]))))
   (->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (__))
   11)

* ;; 4Clojure Question 73
;; A <a
;; href="http://en.wikipedia.org/wiki/Tic-tac-toe">tic-tac-toe</a>
;; board is represented by a two dimensional vector. X is represented
;; by :x, O is represented by :o, and empty is represented by :e. A
;; player wins by placing three Xs or three Os in a horizontal,
;; vertical, or diagonal row. Write a function which analyzes a
;; tic-tac-toe board and returns :x if X has won, :o if O has won, and
;; nil if neither player has won. 

(= nil (__ [[:e :e :e]
            [:e :e :e]
            [:e :e :e]]))

(= :x (__ [[:x :e :o]
           [:x :e :e]
           [:x :e :o]]))

(= :o (__ [[:e :x :e]
           [:o :o :o]
           [:x :e :x]]))

(= nil (__ [[:x :e :o]
            [:x :x :e]
            [:o :x :o]]))

(= :x (__ [[:x :e :e]
           [:o :x :e]
           [:o :e :x]]))

(= :o (__ [[:x :e :o]
           [:x :o :e]
           [:o :e :x]]))

(= nil (__ [[:x :o :x]
            [:x :o :x]
            [:o :x :o]]))

* ;; 4Clojure Question 74
;; Given a string of comma separated integers, write a function which
;; returns a new comma separated string that only contains the numbers
;; which are perfect squares. 

(= (__ "4,5,6,7,8,9") "4,9")

(= (__ "15,16,25,36,37") "16,25,36")

* ;; 4Clojure Question 75
;; Two numbers are coprime if their greatest common divisor equals 1.
;; Euler's totient function f(x) is defined as the number of positive
;; integers less than x which are coprime to x. The special case f(1)
;; equals 1. Write a function which calculates Euler's totient
;; function. Use M-x 4clojure-check-answers when you're done!

(= (__ 1) 1)

(= (__ 10) (count '(1 3 7 9)) 4)

(= (__ 40) 16)

(= (__ 99) 60)

* ;; 4Clojure Question 76
;; The trampoline function takes a function f and a variable number of
;; parameters. Trampoline calls f with any parameters that were
;; supplied. If f returns a function, trampoline calls that function
;; with no arguments. This is repeated, until the return value is not
;; a function, and then trampoline returns that non-function value.
;; This is useful for implementing mutually recursive algorithms in a
;; way that won't consume the stack. Use M-x 4clojure-check-answers
;; when you're done!

(= __
   (letfn
     [(foo [x y] #(bar (conj x y) y))
      (bar [x y] (if (> (last x) 10)
                   x
                   #(foo x (+ 2 y))))]
     (trampoline foo [] 1)))

* ;; 4Clojure Question 77
;; Write a function which finds all the anagrams in a vector of words.
;; A word x is an anagram of word y if all the letters in x can be
;; rearranged in a different order to form y. Your function should
;; return a set of sets, where each sub-set is a group of words which
;; are anagrams of each other. Each sub-set should have at least two
;; words. Words without any anagrams should not be included in the
;; result. Use M-x 4clojure-check-answers when you're done!

(= (__ ["meat" "mat" "team" "mate" "eat"])
   #{#{"meat" "team" "mate"}})

(= (__ ["veer" "lake" "item" "kale" "mite" "ever"])
   #{#{"veer" "ever"} #{"lake" "kale"} #{"mite" "item"}})

* ;; 4Clojure Question 78
;; Reimplement the function described in <a href="76"> "Intro to
;; Trampoline"</a>. Restrictions (please don't use these function(s)):
;; trampoline Use M-x 4clojure-check-answers when you're done!

(= (letfn [(triple [x] #(sub-two (* 3 x)))
          (sub-two [x] #(stop?(- x 2)))
          (stop? [x] (if (> x 50) x #(triple x)))]
    (__ triple 2))
  82)

(= (letfn [(my-even? [x] (if (zero? x) true #(my-odd? (dec x))))
          (my-odd? [x] (if (zero? x) false #(my-even? (dec x))))]
    (map (partial __ my-even?) (range 6)))
  [true false true false true false])

* ;; 4Clojure Question 79
;; Write a function which calculates the sum of the minimal path
;; through a triangle. The triangle is represented as a collection of
;; vectors. The path should start at the top of the triangle and move
;; to an adjacent number on the next row until the bottom of the
;; triangle is reached. 

(= 7 (__ '([1]
          [2 4]
         [5 1 4]
        [2 3 4 5]))) ; 1->2->1->3

(= 20 (__ '([3]
           [2 4]
          [1 9 3]
         [9 9 2 4]
        [4 6 6 7 8]
       [5 7 3 5 1 4]))) ; 3->4->3->2->7->1

* ;; 4Clojure Question 80
;; A number is "perfect" if the sum of its divisors equal the number
;; itself. 6 is a perfect number because 1+2+3=6. Write a function
;; which returns true for perfect numbers and false otherwise. 

(= (__ 6) true)

(= (__ 7) false)

(= (__ 496) true)

(= (__ 500) false)

(= (__ 8128) true)

* ;; 4Clojure Question 81
;; Write a function which returns the intersection of two sets. The
;; intersection is the sub-set of items that each set has in common.
;; Restrictions (please don't use these function(s)): intersection Use
;; M-x 4clojure-check-answers when you're done!

(= (__ #{0 1 2 3} #{2 3 4 5}) #{2 3})

(= (__ #{0 1 2} #{3 4 5}) #{})

(= (__ #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})

* ;; 4Clojure Question 82
;; A word chain consists of a set of words ordered so that each word
;; differs by only one letter from the words directly before and after
;; it. The one letter difference can be either an insertion, a
;; deletion, or a substitution. Here is an example word
;; chain:<br/><br/>cat -> cot -> coat -> oat -> hat -> hot -> hog ->
;; dog<br/><br/>Write a function which takes a sequence of words, and
;; returns true if they can be arranged into one continous word chain,
;; and false if they cannot. 

(= true (__ #{"hat" "coat" "dog" "cat" "oat" "cot" "hot" "hog"}))

(= false (__ #{"cot" "hot" "bat" "fat"}))

(= false (__ #{"to" "top" "stop" "tops" "toss"}))

(= true (__ #{"spout" "do" "pot" "pout" "spot" "dot"}))

(= true (__ #{"share" "hares" "shares" "hare" "are"}))

(= false (__ #{"share" "hares" "hare" "are"}))

* ;; 4Clojure Question 83
;; Write a function which takes a variable number of booleans. Your
;; function should return true if some of the parameters are true, but
;; not all of the parameters are true. Otherwise your function should
;; return false. Use M-x 4clojure-check-answers when you're done!

(= false (__ false false))

(= true (__ true false))

(= false (__ true))

(= true (__ false true false))

(= false (__ true true true))

(= true (__ true true true false))

* ;; 4Clojure Question 84
;; Write a function which generates the <a
;; href="http://en.wikipedia.org/wiki/Transitive_closure">transitive
;; closure</a> of a <a
;; href="http://en.wikipedia.org/wiki/Binary_relation">binary
;; relation</a>. The relation will be represented as a set of 2 item
;; vectors. Use M-x 4clojure-check-answers when you're done!

(let [divides #{[8 4] [9 3] [4 2] [27 9]}]
  (= (__ divides) #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}))

(let [more-legs
      #{["cat" "man"] ["man" "snake"] ["spider" "cat"]}]
  (= (__ more-legs)
     #{["cat" "man"] ["cat" "snake"] ["man" "snake"]
       ["spider" "cat"] ["spider" "man"] ["spider" "snake"]}))

(let [progeny
      #{["father" "son"] ["uncle" "cousin"] ["son" "grandson"]}]
  (= (__ progeny)
     #{["father" "son"] ["father" "grandson"]
       ["uncle" "cousin"] ["son" "grandson"]}))

* ;; 4Clojure Question 85
;; Write a function which generates the <a
;; href="http://en.wikipedia.org/wiki/Power_set">power set</a> of a
;; given set. The power set of a set x is the set of all subsets of x,
;; including the empty set and x itself. 

(= (__ #{1 :a}) #{#{1 :a} #{:a} #{} #{1}})

(= (__ #{}) #{#{}})

(= (__ #{1 2 3})
   #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}})

(= (count (__ (into #{} (range 10)))) 1024)

* ;; 4Clojure Question 86
;; Happy numbers are positive integers that follow a particular
;; formula: take each individual digit, square it, and then sum the
;; squares to get a new number. Repeat with the new number and
;; eventually, you might get to a number whose squared sum is 1. This
;; is a happy number. An unhappy number (or sad number) is one that
;; loops endlessly. Write a function that determines if a number is
;; happy or not. Use M-x 4clojure-check-answers when you're done!

(= (__ 7) true)

(= (__ 986543210) true)

(= (__ 2) false)

(= (__ 3) false)

* ;; 4Clojure Question 87
;; Happy numbers are positive integers that follow a particular
;; formula: take each individual digit, square it, and then sum the
;; squares to get a new number. Repeat with the new number and
;; eventually, you might get to a number whose squared sum is 1. This
;; is a happy number. An unhappy number (or sad number) is one that
;; loops endlessly. Write a function that determines if a number is
;; happy or not. Use M-x 4clojure-check-answers when you're done!

(= (__ 7) true)

(= (__ 986543210) true)

(= (__ 2) false)

(= (__ 3) false)

* ;; 4Clojure Question 88
;; Write a function which returns the symmetric difference of two
;; sets. The symmetric difference is the set of items belonging to one
;; but not both of the two sets. 

(= (__ #{1 2 3 4 5 6} #{1 3 5 7}) #{2 4 6 7})

(= (__ #{:a :b :c} #{}) #{:a :b :c})

(= (__ #{} #{4 5 6}) #{4 5 6})

(= (__ #{[1 2] [2 3]} #{[2 3] [3 4]}) #{[1 2] [3 4]})

* ;; 4Clojure Question 89
;; Starting with a graph you must write a function that returns true
;; if it is possible to make a tour of the graph in which every edge
;; is visited exactly once.<br/><br/>The graph is represented by a
;; vector of tuples, where each tuple represents a single
;; edge.<br/><br/>The rules are:<br/><br/>- You can start at any
;; node.<br/>- You must visit each edge exactly once.</br>- All edges
;; are undirected. Use M-x 4clojure-check-answers when you're done!

(= true (__ [[:a :b]]))

(= false (__ [[:a :a] [:b :b]]))

(= false (__ [[:a :b] [:a :b] [:a :c] [:c :a]
               [:a :d] [:b :d] [:c :d]]))

(= true (__ [[1 2] [2 3] [3 4] [4 1]]))

(= true (__ [[:a :b] [:a :c] [:c :b] [:a :e]
              [:b :e] [:a :d] [:b :d] [:c :e]
              [:d :e] [:c :f] [:d :f]]))

(= false (__ [[1 2] [2 3] [2 4] [2 5]]))

* ;; 4Clojure Question 90
;; Write a function which calculates the <a
;; href="http://en.wikipedia.org/wiki/Cartesian_product"> Cartesian
;; product</a> of two sets. 

(= (__ #{"ace" "king" "queen"} #{"&#9824;" "&#9829;" "&#9830;" "&#9827;"})
   #{["ace"   "&#9824;"] ["ace"   "&#9829;"] ["ace"   "&#9830;"] ["ace"   "&#9827;"]
     ["king"  "&#9824;"] ["king"  "&#9829;"] ["king"  "&#9830;"] ["king"  "&#9827;"]
     ["queen" "&#9824;"] ["queen" "&#9829;"] ["queen" "&#9830;"] ["queen" "&#9827;"]})

(= (__ #{1 2 3} #{4 5})
   #{[1 4] [2 4] [3 4] [1 5] [2 5] [3 5]})

(= 300 (count (__ (into #{} (range 10))
                  (into #{} (range 30)))))

* ;; 4Clojure Question 91
;; Given a graph, determine whether the graph is connected. A
;; connected graph is such that a path exists between any two given
;; nodes.<br/><br/>-Your function must return true if the graph is
;; connected and false otherwise.<br/><br/>-You will be given a set of
;; tuples representing the edges of a graph. Each member of a tuple
;; being a vertex/node in the graph.<br/><br/>-Each edge is undirected
;; (can be traversed either direction). Use M-x 4clojure-check-answers
;; when you're done!

(= true (__ #{[:a :a]}))

(= true (__ #{[:a :b]}))

(= false (__ #{[1 2] [2 3] [3 1]
               [4 5] [5 6] [6 4]}))

(= true (__ #{[1 2] [2 3] [3 1]
              [4 5] [5 6] [6 4] [3 4]}))

(= false (__ #{[:a :b] [:b :c] [:c :d]
               [:x :y] [:d :a] [:b :e]}))

(= true (__ #{[:a :b] [:b :c] [:c :d]
              [:x :y] [:d :a] [:b :e] [:x :a]}))

* ;; 4Clojure Question 92
;; Roman numerals are easy to recognize, but not everyone knows all
;; the rules necessary to work with them. Write a function to parse a
;; Roman-numeral string and return the number it represents. <br /><br
;; /> You can assume that the input will be well-formed, in
;; upper-case, and follow the <a
;; href="http://en.wikipedia.org/wiki/Roman_numerals#Subtractive_principle">subtractive
;; principle</a>. You don't need to handle any numbers greater than
;; MMMCMXCIX (3999), the largest number representable with ordinary
;; letters. Use M-x 4clojure-check-answers when you're done!

(= 14 (__ "XIV"))

(= 827 (__ "DCCCXXVII"))

(= 3999 (__ "MMMCMXCIX"))

(= 48 (__ "XLVIII"))


* ;; 4Clojure Question 93
;; Write a function which flattens any nested combination of
;; sequential things (lists, vectors, etc.), but maintains the lowest
;; level sequential items. The result should be a sequence of
;; sequences with only one level of nesting. 

(= (__ [["Do"] ["Nothing"]])
   [["Do"] ["Nothing"]])

(= (__ [[[[:a :b]]] [[:c :d]] [:e :f]])
   [[:a :b] [:c :d] [:e :f]])

(= (__ '((1 2)((3 4)((((5 6)))))))
   '((1 2)(3 4)(5 6)))

* ;; 4Clojure Question 94
;; The <a
;; href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">game of
;; life</a> is a cellular automaton devised by mathematician John
;; Conway. <br/><br/>The 'board' consists of both live (#) and dead (
;; ) cells. Each cell interacts with its eight neighbours (horizontal,
;; vertical, diagonal), and its next state is dependent on the
;; following rules:<br/><br/>1) Any live cell with fewer than two live
;; neighbours dies, as if caused by under-population.<br/>2) Any live
;; cell with two or three live neighbours lives on to the next
;; generation.<br/>3) Any live cell with more than three live
;; neighbours dies, as if by overcrowding.<br/>4) Any dead cell with
;; exactly three live neighbours becomes a live cell, as if by
;; reproduction.<br/><br/>Write a function that accepts a board, and
;; returns a board representing the next generation of cells. 

(= (__ ["      "  
        " ##   "
        " ##   "
        "   ## "
        "   ## "
        "      "])
   ["      "  
    " ##   "
    " #    "
    "    # "
    "   ## "
    "      "])

(= (__ ["     "
        "     "
        " ### "
        "     "
        "     "])
   ["     "
    "  #  "
    "  #  "
    "  #  "
    "     "])

(= (__ ["      "
        "      "
        "  ### "
        " ###  "
        "      "
        "      "])
   ["      "
    "   #  "
    " #  # "
    " #  # "
    "  #   "
    "      "])

* ;; 4Clojure Question 95
;; Write a predicate which checks whether or not a given sequence
;; represents a <a
;; href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a>.
;; Each node in the tree must have a value, a left child, and a right
;; child. Use M-x 4clojure-check-answers when you're done!

(= (__ '(:a (:b nil nil) nil))
   true)

(= (__ '(:a (:b nil nil)))
   false)

(= (__ [1 nil [2 [3 nil nil] [4 nil nil]]])
   true)

(= (__ [1 [2 nil nil] [3 nil nil] [4 nil nil]])
   false)

(= (__ [1 [2 [3 [4 nil nil] nil] nil] nil])
   true)

(= (__ [1 [2 [3 [4 false nil] nil] nil] nil])
   false)

(= (__ '(:a nil ()))
   false)


* ;; 4Clojure Question 96
;; Let us define a binary tree as "symmetric" if the left half of the
;; tree is the mirror image of the right half of the tree. Write a
;; predicate to determine whether or not a given binary tree is
;; symmetric. (see <a href='/problem/95'>To Tree, or not to Tree</a>
;; for a reminder on the tree representation we're using). 

(= (__ '(:a (:b nil nil) (:b nil nil))) true)

(= (__ '(:a (:b nil nil) nil)) false)

(= (__ '(:a (:b nil nil) (:c nil nil))) false)

(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])
   true)

(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
          [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])
   false)

(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
          [2 [3 nil [4 [6 nil nil] nil]] nil]])
   false)

* ;; 4Clojure Question 97
;; <a href="http://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's
;; triangle</a> is a triangle of numbers computed using the following
;; rules:<br/></br>- The first row is 1.</br>- Each successive row is
;; computed by adding together adjacent numbers in the row above, and
;; adding a 1 to the beginning and end of the row.<br/><br/>Write a
;; function which returns the nth row of Pascal's Triangle. 

(= (__ 1) [1])

(= (map __ (range 1 6))
   [     [1]
        [1 1]
       [1 2 1]
      [1 3 3 1]
     [1 4 6 4 1]])

(= (__ 11)
   [1 10 45 120 210 252 210 120 45 10 1])

* ;; 4Clojure Question 98
;; A function f defined on a domain D induces an <a
;; href="http://en.wikipedia.org/wiki/Equivalence_relation">equivalence
;; relation</a> on D, as follows: a is equivalent to b with respect to
;; f if and only if (f a) is equal to (f b). Write a function with
;; arguments f and D that computes the <a
;; href="http://en.wikipedia.org/wiki/Equivalence_class">equivalence
;; classes</a> of D with respect to f. Use M-x 4clojure-check-answers
;; when you're done!

(= (__ #(* % %) #{-2 -1 0 1 2})
   #{#{0} #{1 -1} #{2 -2}})

(= (__ #(rem % 3) #{0 1 2 3 4 5 })
   #{#{0 3} #{1 4} #{2 5}})

(= (__ identity #{0 1 2 3 4})
   #{#{0} #{1} #{2} #{3} #{4}})

(= (__ (constantly true) #{0 1 2 3 4})
   #{#{0 1 2 3 4}})


* ;; 4Clojure Question 99
;; Write a function which multiplies two numbers and returns the
;; result as a sequence of its digits. Use M-x 4clojure-check-answers
;; when you're done!

(= (__ 1 1) [1])

(= (__ 99 9) [8 9 1])

(= (__ 999 99) [9 8 9 0 1])

* ;; 4Clojure Question 100
;; Write a function which calculates the <a
;; href="http://en.wikipedia.org/wiki/Least_common_multiple">least
;; common multiple</a>. Your function should accept a variable number
;; of positive integers or ratios. 

(== (__ 2 3) 6)

(== (__ 5 3 7) 105)

(== (__ 1/3 2/5) 2)

(== (__ 3/4 1/6) 3/2)

(== (__ 7 5/7 2 3/5) 210)

* ;; 4Clojure Question 101
;; Given two sequences x and y, calculate the <a
;; href="https://secure.wikimedia.org/wikipedia/en/wiki/Levenshtein_distance">Levenshtein
;; distance</a> of x and y, i. e. the minimum number of edits needed
;; to transform x into y. The allowed edits are:<br/><br/>- insert a
;; single item<br/>- delete a single item<br/>- replace a single item
;; with another item<br/><br/>WARNING: Some of the test cases may
;; timeout if you write an inefficient solution! 

(= (__ "kitten" "sitting") 3)

(= (__ "closure" "clojure") (__ "clojure" "closure") 1)

(= (__ "xyx" "xyyyx") 2)

(= (__ "" "123456") 6)

(= (__ "Clojure" "Clojure") (__ "" "") (__ [] []) 0)

(= (__ [1 2 3 4] [0 2 3 4 5]) 2)

(= (__ '(:a :b :c :d) '(:a :d)) 2)

(= (__ "ttttattttctg" "tcaaccctaccat") 10)

(= (__ "gaattctaatctc" "caaacaaaaaattt") 9)

* ;; 4Clojure Question 102
;; When working with java, you often need to create an object with
;; <code>fieldsLikeThis</code>, but you'd rather work with a hashmap
;; that has <code>:keys-like-this</code> until it's time to convert.
;; Write a function which takes lower-case hyphen-separated strings
;; and converts them to camel-case strings. 

(= (__ "something") "something")

(= (__ "multi-word-key") "multiWordKey")

(= (__ "leaveMeAlone") "leaveMeAlone")

* ;; 4Clojure Question 103
;; Given a sequence S consisting of n elements generate all <a
;; href="https://secure.wikimedia.org/wikipedia/en/wiki/Combination">k-combinations</a>
;; of S, i. e. generate all possible sets consisting of k distinct
;; elements taken from S. The number of k-combinations for a sequence
;; is equal to the <a
;; href="https://secure.wikimedia.org/wikipedia/en/wiki/Binomial_coefficient">binomial
;; coefficient</a>. Use M-x 4clojure-check-answers when you're done!

(= (__ 1 #{4 5 6}) #{#{4} #{5} #{6}})

(= (__ 10 #{4 5 6}) #{})

(= (__ 2 #{0 1 2}) #{#{0 1} #{0 2} #{1 2}})

(= (__ 3 #{0 1 2 3 4}) #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4}
                         #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}})

(= (__ 4 #{[1 2 3] :a "abc" "efg"}) #{#{[1 2 3] :a "abc" "efg"}})

(= (__ 2 #{[1 2 3] :a "abc" "efg"}) #{#{[1 2 3] :a} #{[1 2 3] "abc"} #{[1 2 3] "efg"}
                                    #{:a "abc"} #{:a "efg"} #{"abc" "efg"}})

* ;; 4Clojure Question 104
;; This is the inverse of <a href='92'>Problem 92</a>, but much
;; easier. Given an integer smaller than 4000, return the
;; corresponding roman numeral in uppercase, adhering to the <a
;; href='http://www.numericana.com/answer/roman.htm#valid'>subtractive
;; principle</a>. Use M-x 4clojure-check-answers when you're done!

(= "I" (__ 1))

(= "XXX" (__ 30))

(= "IV" (__ 4))

(= "CXL" (__ 140))

(= "DCCCXXVII" (__ 827))

(= "MMMCMXCIX" (__ 3999))

(= "XLVIII" (__ 48))

* ;; 4Clojure Question 105
;; Given an input sequence of keywords and numbers, create a map such
;; that each key in the map is a keyword, and the value is a sequence
;; of all the numbers (if any) between it and the next keyword in the
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= {} (__ []))

(= {:a [1]} (__ [:a 1]))

(= {:a [1], :b [2]} (__ [:a 1, :b 2]))

(= {:a [1 2 3], :b [], :c [4]} (__ [:a 1 2 3 :b :c 4]))

* ;; 4Clojure Question 106
;; Given a pair of numbers, the start and end point, find a path
;; between the two using only three possible operations:<ul>
;; <li>double</li> <li>halve (odd numbers cannot be halved)</li>
;; <li>add 2</li></ul> Find the shortest path through the "maze".
;; Because there are multiple shortest paths, you must return the
;; length of the shortest path, not the path itself. 

(= 1 (__ 1 1))  ; 1

(= 3 (__ 3 12)) ; 3 6 12

(= 3 (__ 12 3)) ; 12 6 3

(= 3 (__ 5 9))  ; 5 7 9

(= 9 (__ 9 2))  ; 9 18 20 10 12 6 8 4 2

(= 5 (__ 9 12)) ; 9 11 22 24 12


* ;; 4Clojure Question 107
;; <p>Lexical scope and first-class functions are two of the most
;; basic building blocks of a functional language like Clojure. When
;; you combine the two together, you get something very powerful
;; called <strong>lexical closures</strong>. With these, you can
;; exercise a great deal of control over the lifetime of your local
;; bindings, saving their values for use later, long after the code
;; you're running now has finished.</p> <p>It can be hard to follow in
;; the abstract, so let's build a simple closure. Given a positive
;; integer <i>n</i>, return a function <code>(f x)</code> which
;; computes <i>x<sup>n</sup></i>. Observe that the effect of this is
;; to preserve the value of <i>n</i> for use outside the scope in
;; which it is defined.</p> 

(= 256 ((__ 2) 16),
       ((__ 8) 2))

(= [1 8 27 64] (map (__ 3) [1 2 3 4]))

(= [1 2 4 8 16] (map #((__ %) 2) [0 1 2 3 4]))

* ;; 4Clojure Question 108
;; <p>Given any number of sequences, each sorted from smallest to
;; largest, find the smallest single number which appears in all of
;; the sequences. The sequences may be infinite, so be careful to
;; search lazily.</p> Use M-x 4clojure-check-answers when you're done!

(= 3 (__ [3 4 5]))

(= 4 (__ [1 2 3 4 5 6 7] [0.5 3/2 4 19]))

(= 7 (__ (range) (range 0 100 7/6) [2 3 5 7 11 13]))

(= 64 (__ (map #(* % % %) (range)) ;; perfect cubes
          (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2
          (iterate inc 20))) ;; at least as large as 20

* ;; 4Clojure Question 109
;; <p>Given any number of sequences, each sorted from smallest to
;; largest, find the smallest single number which appears in all of
;; the sequences. The sequences may be infinite, so be careful to
;; search lazily.</p> Use M-x 4clojure-check-answers when you're done!

(= 3 (__ [3 4 5]))

(= 4 (__ [1 2 3 4 5 6 7] [0.5 3/2 4 19]))

(= 7 (__ (range) (range 0 100 7/6) [2 3 5 7 11 13]))

(= 64 (__ (map #(* % % %) (range)) ;; perfect cubes
          (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2
          (iterate inc 20))) ;; at least as large as 20

* ;; 4Clojure Question 110
;; <p>Write a function that returns a lazy sequence of
;; "pronunciations" of a sequence of numbers. A pronunciation of each
;; element in the sequence consists of the number of repeating
;; identical numbers and the number itself. For example, <code>[1
;; 1]</code> is pronounced as <code>[2 1]</code> ("two ones"), which
;; in turn is pronounced as <code>[1 2 1 1]</code> ("one two, one
;; one").</p><p>Your function should accept an initial sequence of
;; numbers, and return an infinite lazy sequence of pronunciations,
;; each element being a pronunciation of the previous element.</p> Use
;; M-x 4clojure-check-answers when you're done!

(= [[1 1] [2 1] [1 2 1 1]] (take 3 (__ [1])))

(= [3 1 2 4] (first (__ [1 1 1 4 4])))

(= [1 1 1 3 2 1 3 2 1 1] (nth (__ [1]) 6))

(= 338 (count (nth (__ [3 2]) 15)))


* ;; 4Clojure Question 111
;; Write a function that takes a string and a partially-filled
;; crossword puzzle board, and determines if the input string can be
;; legally placed onto the board. </br></br> The crossword puzzle
;; board consists of a collection of partially-filled rows. Empty
;; spaces are denoted with an underscore (_), unusable spaces are
;; denoted with a hash symbol (#), and pre-filled spaces have a
;; character in place; the whitespace characters are for legibility
;; and should be ignored. </br></br> For a word to be legally placed
;; on the board: </br> - It may use empty spaces (underscores) </br> -
;; It may use but must not conflict with any pre-filled characters.
;; </br> - It must not use any unusable spaces (hashes). </br> - There
;; must be no empty spaces (underscores) or extra characters before or
;; after the word (the word may be bound by unusable spaces though).
;; </br> - Characters are not case-sensitive. </br> - Words may be
;; placed vertically (proceeding top-down only), or horizontally
;; (proceeding left-right only). 

(= true  (__ "the" ["_ # _ _ e"]))

(= false (__ "the" ["c _ _ _"
                    "d _ # e"
                    "r y _ _"]))

(= true  (__ "joy" ["c _ _ _"
                    "d _ # e"
                    "r y _ _"]))

(= false (__ "joy" ["c o n j"
                    "_ _ y _"
                    "r _ _ #"]))

(= true  (__ "clojure" ["_ _ _ # j o y"
                        "_ _ o _ _ _ _"
                        "_ _ f _ # _ _"]))


* ;; 4Clojure Question 112
;; Create a function which takes an integer and a nested collection of
;; integers as arguments. Analyze the elements of the input collection
;; and return a sequence which maintains the nested structure, and
;; which includes all elements starting from the head whose sum is
;; less than or equal to the input integer. 

(=  (__ 10 [1 2 [3 [4 5] 6] 7])
   '(1 2 (3 (4))))

(=  (__ 30 [1 2 [3 [4 [5 [6 [7 8]] 9]] 10] 11])
   '(1 2 (3 (4 (5 (6 (7)))))))

(=  (__ 9 (range))
   '(0 1 2 3))

(=  (__ 1 [[[[[1]]]]])
   '(((((1))))))

(=  (__ 0 [1 2 [3 [4 5] 6] 7])
   '())

(=  (__ 0 [0 0 [0 [0]]])
   '(0 0 (0 (0))))

(=  (__ 1 [-10 [1 [2 3 [4 5 [6 7 [8]]]]]])
   '(-10 (1 (2 3 (4)))))

* ;; 4Clojure Question 113
;; Write a function that takes a variable number of integer arguments.
;; If the output is coerced into a string, it should return a comma
;; (and space) separated list of the inputs sorted smallest to
;; largest. If the output is coerced into a sequence, it should return
;; a seq of unique input elements in the same order as they were
;; entered. Restrictions (please don't use these function(s)): proxy
;; Use M-x 4clojure-check-answers when you're done!

(= "1, 2, 3" (str (__ 2 1 3)))

(= '(2 1 3) (seq (__ 2 1 3)))

(= '(2 1 3) (seq (__ 2 1 3 3 1 2)))

(= '(1) (seq (apply __ (repeat 5 1))))

(= "1, 1, 1, 1, 1" (str (apply __ (repeat 5 1))))

(and (= nil (seq (__)))
     (=  "" (str (__))))

* ;; 4Clojure Question 114
;; <p><a
;; href="http://clojuredocs.org/clojure_core/clojure.core/take-while">take-while</a>
;; is great for filtering sequences, but it limited: you can only
;; examine a single item of the sequence at a time. What if you need
;; to keep track of some state as you go over the sequence?</p>
;; <p>Write a function which accepts an integer <code>n</code>, a
;; predicate <code>p</code>, and a sequence. It should return a lazy
;; sequence of items in the list up to, but not including, the
;; <code>n</code>th item that satisfies the predicate.</p> 

(= [2 3 5 7 11 13]
   (__ 4 #(= 2 (mod % 3))
         [2 3 5 7 11 13 17 19 23]))

(= ["this" "is" "a" "sentence"]
   (__ 3 #(some #{\i} %)
         ["this" "is" "a" "sentence" "i" "wrote"]))

(= ["this" "is"]
   (__ 1 #{"a"}
         ["this" "is" "a" "sentence" "i" "wrote"]))

* ;; 4Clojure Question 115
;; A balanced number is one whose component digits have the same sum
;; on the left and right halves of the number. Write a function which
;; accepts an integer n, and returns true iff n is balanced. 

(= true (__ 11))

(= true (__ 121))

(= false (__ 123))

(= true (__ 0))

(= false (__ 88099))

(= true (__ 89098))

(= true (__ 89089))

(= (take 20 (filter __ (range)))
   [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101])  

* ;; 4Clojure Question 116
;; A <a href="http://en.wikipedia.org/wiki/Balanced_prime">balanced
;; prime</a> is a prime number which is also the mean of the primes
;; directly before and after it in the sequence of valid primes.
;; Create a function which takes an integer n, and returns true iff it
;; is a balanced prime. 

(= false (__ 4))

(= true (__ 563))

(= 1103 (nth (filter __ (range)) 15))

* ;; 4Clojure Question 117
;; A mad scientist with tenure has created an experiment tracking mice
;; in a maze. Several mazes have been randomly generated, and you've
;; been tasked with writing a program to determine the mazes in which
;; it's possible for the mouse to reach the cheesy endpoint. Write a
;; function which accepts a maze in the form of a collection of rows,
;; each row is a string where: <ul> <li>spaces represent areas where
;; the mouse can walk freely</li> <li>hashes (#) represent walls where
;; the mouse can not walk</li> <li>M represents the mouse's starting
;; point</li> <li>C represents the cheese which the mouse must
;; reach</li> </ul> The mouse is not allowed to travel diagonally in
;; the maze (only up/down/left/right), nor can he escape the edge of
;; the maze. Your function must return true iff the maze is solvable
;; by the mouse. Use M-x 4clojure-check-answers when you're done!

(= true  (__ ["M   C"]))

(= false (__ ["M # C"]))

(= true  (__ ["#######"
              "#     #"
              "#  #  #"
              "#M # C#"
              "#######"]))

(= false (__ ["########"
              "#M  #  #"
              "#   #  #"
              "# # #  #"
              "#   #  #"
              "#  #   #"
              "#  # # #"
              "#  #   #"
              "#  #  C#"
              "########"]))

(= false (__ ["M     "
              "      "
              "      "
              "      "
              "    ##"
              "    #C"]))

(= true  (__ ["C######"
              " #     "
              " #   # "
              " #   #M"
              "     # "]))

(= true  (__ ["C# # # #"
              "        "
              "# # # # "
              "        "
              " # # # #"
              "        "
              "# # # #M"]))

* ;; 4Clojure Question 118
;; <p>Map is one of the core elements of a functional programming
;; language. Given a function <code>f</code> and an input sequence
;; <code>s</code>, return a lazy sequence of <code>(f x)</code> for
;; each element <code>x</code> in <code>s</code>. Restrictions (please
;; don't use these function(s)): map, map-indexed, mapcat, for 

(= [3 4 5 6 7]
   (__ inc [2 3 4 5 6]))

(= (repeat 10 nil)
   (__ (fn [_] nil) (range 10)))

(= [1000000 1000001]
   (->> (__ inc (range))
        (drop (dec 1000000))
        (take 2)))

* ;; 4Clojure Question 119
;; <p>As in <a href="/problem/73">Problem 73</a>, a tic-tac-toe board
;; is represented by a two dimensional vector. X is represented by :x,
;; O is represented by :o, and empty is represented by :e. Create a
;; function that accepts a game piece and board as arguments, and
;; returns a set (possibly empty) of all valid board placements of the
;; game piece which would result in an immediate win.</p> <p>Board
;; coordinates should be as in calls to <code>get-in</code>. For
;; example, <code>[0 1]</code> is the topmost row, center
;; position.</p> Use M-x 4clojure-check-answers when you're done!

(= (__ :x [[:o :e :e] 
           [:o :x :o] 
           [:x :x :e]])
   #{[2 2] [0 1] [0 2]})

(= (__ :x [[:x :o :o] 
           [:x :x :e] 
           [:e :o :e]])
   #{[2 2] [1 2] [2 0]})

(= (__ :x [[:x :e :x] 
           [:o :x :o] 
           [:e :o :e]])
   #{[2 2] [0 1] [2 0]})

(= (__ :x [[:x :x :o] 
           [:e :e :e] 
           [:e :e :e]])
   #{})

(= (__ :o [[:x :x :o] 
           [:o :e :o] 
           [:x :e :e]])
   #{[2 2] [1 1]})

* ;; 4Clojure Question 120
;; Write a function which takes a collection of integers as an
;; argument. Return the count of how many elements are smaller than
;; the sum of their squared component digits. For example: 10 is
;; larger than 1 squared plus 0 squared; whereas 15 is smaller than 1
;; squared plus 5 squared. 

(= 8 (__ (range 10)))

(= 19 (__ (range 30)))

(= 50 (__ (range 100)))

(= 50 (__ (range 1000)))

* ;; 4Clojure Question 121
;; Given a mathematical formula in prefix notation, return a function
;; 	 that calculates the value of the formula. The formula can
;; 	 contain nested calculations using the four basic mathematical
;; 	 operators, numeric constants, and symbols representing
;; 	 variables. The returned function has to accept a single
;; 	 parameter containing the map of variable names to their
;; 	 values. Use M-x 4clojure-check-answers when you're done!

(= 2 ((__ '(/ a b))
      '{b 8 a 16}))

(= 8 ((__ '(+ a b 2))
      '{a 2 b 4}))

(= [6 0 -4]
     (map (__ '(* (+ 2 a)
  	              (- 10 b)))
	        '[{a 1 b 8}
	          {b 5 a -2}
	          {a 2 b 11}]))

(= 1 ((__ '(/ (+ x 2)
              (* 3 (+ y 1))))
      '{x 4 y 1}))


* ;; 4Clojure Question 122
;; Convert a binary number, provided in the form of a string, to its
;; numerical value. Use M-x 4clojure-check-answers when you're done!

(= 0     (__ "0"))

(= 7     (__ "111"))

(= 8     (__ "1000"))

(= 9     (__ "1001"))

(= 255   (__ "11111111"))

(= 1365  (__ "10101010101"))

(= 65535 (__ "1111111111111111"))

* ;; 4Clojure Question 123
;; Convert a binary number, provided in the form of a string, to its
;; numerical value. Use M-x 4clojure-check-answers when you're done!

(= 0     (__ "0"))

(= 7     (__ "111"))

(= 8     (__ "1000"))

(= 9     (__ "1001"))

(= 255   (__ "11111111"))

(= 1365  (__ "10101010101"))

(= 65535 (__ "1111111111111111"))

* ;; 4Clojure Question 124
;; <p><a href="http://en.wikipedia.org/wiki/Reversi">Reversi</a> is
;; normally played on an 8 by 8 board. In this problem, a 4 by 4 board
;; is represented as a two-dimensional vector with black, white, and
;; empty pieces represented by 'b, 'w, and 'e, respectively. Create a
;; function that accepts a game board and color as arguments, and
;; returns a map of legal moves for that color. Each key should be the
;; coordinates of a legal move, and its value a set of the coordinates
;; of the pieces flipped by that move.</p> <p>Board coordinates should
;; be as in calls to get-in. For example, <code>[0 1]</code> is the
;; topmost row, second column from the left.</p> 

(= {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}
   (__ '[[e e e e]
         [e w b e]
         [e b w e]
         [e e e e]] 'w))

(= {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}
   (__ '[[e e e e]
         [e w b e]
         [w w w e]
         [e e e e]] 'b))

(= {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}
   (__ '[[e e e e]
         [e w b e]
         [w w b e]
         [e e b e]] 'w))

(= {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}
   (__ '[[e e w e]
         [b b w e]
         [b w w e]
         [b w w w]] 'b))


* ;; 4Clojure Question 125
;; Create a function of no arguments which returns a string that is an
;; <i>exact</i> copy of the function itself. <br /><br /> Hint: read
;; <a href="http://en.wikipedia.org/wiki/Quine_(computing)">this</a>
;; if you get stuck (this question is harder than it first appears);
;; but it's worth the effort to solve it independently if you can! <br
;; /><br /> Fun fact: Gus is the name of the <a
;; href="http://i.imgur.com/FBd8z.png">4Clojure dragon</a>. 

(= (str '__) (__))

* ;; 4Clojure Question 126
;; Enter a value which satisfies the following: 

(let [x __]
  (and (= (class x) x) x))

* ;; 4Clojure Question 127
;; Everyone loves triangles, and it's easy to understand
;; why&mdash;they're so wonderfully symmetric (except scalenes, they
;; suck). <br/><br/> Your passion for triangles has led you to become
;; a miner (and part-time Clojure programmer) where you work all day
;; to chip out isosceles-shaped minerals from rocks gathered in a
;; nearby open-pit mine. There are too many rocks coming from the mine
;; to harvest them all so you've been tasked with writing a program to
;; analyze the mineral patterns of each rock, and determine which
;; rocks have the biggest minerals. <br/><br/> Someone has already
;; written a <a
;; href="http://en.wikipedia.org/wiki/Computer_vision">computer-vision</a>
;; system for the mine. It images each rock as it comes into the
;; processing centre and creates a cross-sectional <a
;; href="http://en.wikipedia.org/wiki/Bit_array">bitmap</a> of mineral
;; (1) and rock (0) concentrations for each one. <br/><br/> You must
;; now create a function which accepts a collection of integers, each
;; integer when read in base-2 gives the bit-representation of the
;; rock (again, 1s are mineral and 0s are worthless scalene-like
;; rock). You must return the cross-sectional area of the largest
;; harvestable mineral from the input rock, as follows: <br> <ul>
;; <li>The minerals only have smooth faces when sheared vertically or
;; horizontally from the rock's cross-section</li> <li>The mine is
;; only concerned with harvesting isosceles triangles (such that one
;; or two sides can be sheared)</li> <li>If only one face of the
;; mineral is sheared, its opposing vertex must be a point (ie. the
;; smooth face must be of odd length), and its two equal-length sides
;; must intersect the shear face at 45&deg; (ie. those sides must cut
;; even-diagonally)</li> <li>The harvested mineral may not contain any
;; traces of rock</li> <li>The mineral may lie in any orientation in
;; the plane</li> <li>Area should be calculated as the sum of 1s that
;; comprise the mineral</li> <li>Minerals must have a minimum of three
;; measures of area to be harvested</li> <li>If no minerals can be
;; harvested from the rock, your function should return nil</li> </ul>
;; Use M-x 4clojure-check-answers when you're done!

(= 10 (__ [15 15 15 15 15]))
; 1111      1111
; 1111      *111
; 1111  ->  **11
; 1111      ***1
; 1111      ****

(= 15 (__ [1 3 7 15 31]))
; 00001      0000*
; 00011      000**
; 00111  ->  00***
; 01111      0****
; 11111      *****

(= 3 (__ [3 3]))
; 11      *1
; 11  ->  **

(= 4 (__ [7 3]))
; 111      ***
; 011  ->  0*1

(= 6 (__ [17 22 6 14 22]))
; 10001      10001
; 10110      101*0
; 00110  ->  00**0
; 01110      0***0
; 10110      10110

(= 9 (__ [18 7 14 14 6 3]))
; 10010      10010
; 00111      001*0
; 01110      01**0
; 01110  ->  0***0
; 00110      00**0
; 00011      000*1

(= nil (__ [21 10 21 10]))
; 10101      10101
; 01010      01010
; 10101  ->  10101
; 01010      01010

(= nil (__ [0 31 0 31 0]))
; 00000      00000
; 11111      11111
; 00000  ->  00000
; 11111      11111
; 00000      00000

* ;; 4Clojure Question 128
;; <p>A standard American deck of playing cards has four suits -
;; spades, hearts, diamonds, and clubs - and thirteen cards in each
;; suit. Two is the lowest rank, followed by other integers up to ten;
;; then the jack, queen, king, and ace.</p> <p>It's convenient for
;; humans to represent these cards as suit/rank pairs, such as H5 or
;; DQ: the heart five and diamond queen respectively. But these forms
;; are not convenient for programmers, so to write a card game you
;; need some way to parse an input string into meaningful components.
;; For purposes of determining rank, we will define the cards to be
;; valued from 0 (the two) to 12 (the ace)</p> <p>Write a function
;; which converts (for example) the string "SJ" into a map of
;; <code>{:suit :spade, :rank 9}</code>. A ten will always be
;; represented with the single character "T", rather than the two
;; characters "10".</p> 

(= {:suit :diamond :rank 10} (__ "DQ"))

(= {:suit :heart :rank 3} (__ "H5"))

(= {:suit :club :rank 12} (__ "CA"))

(= (range 13) (map (comp :rank __ str)
                   '[S2 S3 S4 S5 S6 S7
                     S8 S9 ST SJ SQ SK SA]))

* ;; 4Clojure Question 129
;; <p>A standard American deck of playing cards has four suits -
;; spades, hearts, diamonds, and clubs - and thirteen cards in each
;; suit. Two is the lowest rank, followed by other integers up to ten;
;; then the jack, queen, king, and ace.</p> <p>It's convenient for
;; humans to represent these cards as suit/rank pairs, such as H5 or
;; DQ: the heart five and diamond queen respectively. But these forms
;; are not convenient for programmers, so to write a card game you
;; need some way to parse an input string into meaningful components.
;; For purposes of determining rank, we will define the cards to be
;; valued from 0 (the two) to 12 (the ace)</p> <p>Write a function
;; which converts (for example) the string "SJ" into a map of
;; <code>{:suit :spade, :rank 9}</code>. A ten will always be
;; represented with the single character "T", rather than the two
;; characters "10".</p> 

(= {:suit :diamond :rank 10} (__ "DQ"))

(= {:suit :heart :rank 3} (__ "H5"))

(= {:suit :club :rank 12} (__ "CA"))

(= (range 13) (map (comp :rank __ str)
                   '[S2 S3 S4 S5 S6 S7
                     S8 S9 ST SJ SQ SK SA]))

* ;; 4Clojure Question 130
;; Every node of a tree is connected to each of its children as well
;; as its parent. One can imagine grabbing one node of a tree and
;; dragging it up to the root position, leaving all connections
;; intact. For example, below on the left is a binary tree. By pulling
;; the "c" node up to the root, we obtain the tree on the right. <br/>
;; <img src="http://i.imgur.com/UtD2T.png"> <br/> Note it is no longer
;; binary as "c" had three connections total -- two children and one
;; parent. Each node is represented as a vector, which always has at
;; least one element giving the name of the node as a symbol.
;; Subsequent items in the vector represent the children of the node.
;; Because the children are ordered it's important that the tree you
;; return keeps the children of each node in order and that the old
;; parent node, if any, is appended on the right. Your function will
;; be given two args -- the name of the node that should become the
;; new root, and the tree to transform. Use M-x 4clojure-check-answers
;; when you're done!

(= '(n)
   (__ 'n '(n)))

(= '(a (t (e)))
   (__ 'a '(t (e) (a))))

(= '(e (t (a)))
   (__ 'e '(a (t (e)))))

(= '(a (b (c)))
   (__ 'a '(c (b (a)))))

(= '(d 
      (b
        (c)
        (e)
        (a 
          (f 
            (g) 
            (h)))))
  (__ 'd '(a
            (b 
              (c) 
              (d) 
              (e))
            (f 
              (g)
              (h)))))

(= '(c 
      (d) 
      (e) 
      (b
        (f 
          (g) 
          (h))
        (a
          (i
          (j
            (k)
            (l))
          (m
            (n)
            (o))))))
   (__ 'c '(a
             (b
               (c
                 (d)
                 (e))
               (f
                 (g)
                 (h)))
             (i
               (j
                 (k)
                 (l))
               (m
                 (n)
                 (o))))))


* ;; 4Clojure Question 131
;; Given a variable number of sets of integers, create a function
;; which returns true iff all of the sets have a non-empty subset with
;; an equivalent summation. 

(= true  (__ #{-1 1 99} 
             #{-2 2 888}
             #{-3 3 7777})) ; ex. all sets have a subset which sums to zero

(= false (__ #{1}
             #{2}
             #{3}
             #{4}))

(= true  (__ #{1}))

(= false (__ #{1 -3 51 9} 
             #{0} 
             #{9 2 81 33}))

(= true  (__ #{1 3 5}
             #{9 11 4}
             #{-3 12 3}
             #{-3 4 -2 10}))

(= false (__ #{-1 -2 -3 -4 -5 -6}
             #{1 2 3 4 5 6 7 8 9}))

(= true  (__ #{1 3 5 7}
             #{2 4 6 8}))

(= true  (__ #{-1 3 -5 7 -9 11 -13 15}
             #{1 -3 5 -7 9 -11 13 -15}
             #{1 -1 2 -2 4 -4 8 -8}))

(= true  (__ #{-10 9 -8 7 -6 5 -4 3 -2 1}
             #{10 -9 8 -7 6 -5 4 -3 2 -1}))

* ;; 4Clojure Question 132
;; Write a function that takes a two-argument predicate, a value, and
;; a collection; and returns a new collection where the
;; <code>value</code> is inserted between every two items that satisfy
;; the predicate. Use M-x 4clojure-check-answers when you're done!

(= '(1 :less 6 :less 7 4 3) (__ < :less [1 6 7 4 3]))

(= '(2) (__ > :more [2]))

(= [0 1 :x 2 :x 3 :x 4]  (__ #(and (pos? %) (< % %2)) :x (range 5)))

(empty? (__ > :more ()))

(= [0 1 :same 1 2 3 :same 5 8 13 :same 21]
   (take 12 (->> [0 1]
                 (iterate (fn [[a b]] [b (+ a b)]))
                 (map first) ; fibonacci numbers
                 (__ (fn [a b] ; both even or both odd
                       (= (mod a 2) (mod b 2)))
                     :same))))

* ;; 4Clojure Question 133
;; Write a function that takes a two-argument predicate, a value, and
;; a collection; and returns a new collection where the
;; <code>value</code> is inserted between every two items that satisfy
;; the predicate. Use M-x 4clojure-check-answers when you're done!

(= '(1 :less 6 :less 7 4 3) (__ < :less [1 6 7 4 3]))

(= '(2) (__ > :more [2]))

(= [0 1 :x 2 :x 3 :x 4]  (__ #(and (pos? %) (< % %2)) :x (range 5)))

(empty? (__ > :more ()))

(= [0 1 :same 1 2 3 :same 5 8 13 :same 21]
   (take 12 (->> [0 1]
                 (iterate (fn [[a b]] [b (+ a b)]))
                 (map first) ; fibonacci numbers
                 (__ (fn [a b] ; both even or both odd
                       (= (mod a 2) (mod b 2)))
                     :same))))

* ;; 4Clojure Question 134
;; Write a function which, given a key and map, returns true <a
;; href="http://en.wikipedia.org/wiki/If_and_only_if">iff</a> the map
;; contains an entry with that key and its value is nil. 

(true?  (__ :a {:a nil :b 2}))

(false? (__ :b {:a nil :b 2}))

(false? (__ :c {:a nil :b 2}))

* ;; 4Clojure Question 135
;; Your friend Joe is always whining about Lisps using the prefix
;; notation for math. Show him how you could easily write a function
;; that does math using the infix notation. Is your favorite language
;; that flexible, Joe? Write a function that accepts a variable length
;; mathematical expression consisting of numbers and the operations +,
;; -, *, and /. Assume a simple calculator that does not do precedence
;; and instead just calculates left to right. 

(= 7  (__ 2 + 5))

(= 42 (__ 38 + 48 - 2 / 2))

(= 8  (__ 10 / 2 - 1 * 2))

(= 72 (__ 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9))

* ;; 4Clojure Question 136
;; Your friend Joe is always whining about Lisps using the prefix
;; notation for math. Show him how you could easily write a function
;; that does math using the infix notation. Is your favorite language
;; that flexible, Joe? Write a function that accepts a variable length
;; mathematical expression consisting of numbers and the operations +,
;; -, *, and /. Assume a simple calculator that does not do precedence
;; and instead just calculates left to right. 

(= 7  (__ 2 + 5))

(= 42 (__ 38 + 48 - 2 / 2))

(= 8  (__ 10 / 2 - 1 * 2))

(= 72 (__ 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9))

* ;; 4Clojure Question 137
;; Write a function which returns a sequence of digits of a
;; non-negative number (first argument) in numerical system with an
;; arbitrary base (second argument). Digits should be represented with
;; their integer values, e.g. 15 would be [1 5] in base 10, [1 1 1 1]
;; in base 2 and [15] in base 16. 

(= [1 2 3 4 5 0 1] (__ 1234501 10))

(= [0] (__ 0 11))

(= [1 0 0 1] (__ 9 2))

(= [1 0] (let [n (rand-int 100000)](__ n n)))

(= [16 18 5 24 15 1] (__ Integer/MAX_VALUE 42))

* ;; 4Clojure Question 138
;; Create a function of two integer arguments: the start and end,
;; respectively. You must create a vector of strings which renders a
;; 45&deg; rotated square of integers which are successive squares
;; from the start point up to and including the end point. If a number
;; comprises multiple digits, wrap them around the shape individually.
;; If there are not enough digits to complete the shape, fill in the
;; rest with asterisk characters. The direction of the drawing should
;; be clockwise, starting from the center of the shape and working
;; outwards, with the initial direction being down and to the right.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2 2) ["2"])

(= (__ 2 4) [" 2 "
             "* 4"
             " * "])

(= (__ 3 81) [" 3 "
              "1 9"
              " 8 "])

(= (__ 4 20) [" 4 "
              "* 1"
              " 6 "])

(= (__ 2 256) ["  6  "
               " 5 * "
               "2 2 *"
               " 6 4 "
               "  1  "])

(= (__ 10 10000) ["   0   "
                  "  1 0  "
                  " 0 1 0 "
                  "* 0 0 0"
                  " * 1 * "
                  "  * *  "
                  "   *   "])

* ;; 4Clojure Question 139
;; Create a function of two integer arguments: the start and end,
;; respectively. You must create a vector of strings which renders a
;; 45&deg; rotated square of integers which are successive squares
;; from the start point up to and including the end point. If a number
;; comprises multiple digits, wrap them around the shape individually.
;; If there are not enough digits to complete the shape, fill in the
;; rest with asterisk characters. The direction of the drawing should
;; be clockwise, starting from the center of the shape and working
;; outwards, with the initial direction being down and to the right.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2 2) ["2"])

(= (__ 2 4) [" 2 "
             "* 4"
             " * "])

(= (__ 3 81) [" 3 "
              "1 9"
              " 8 "])

(= (__ 4 20) [" 4 "
              "* 1"
              " 6 "])

(= (__ 2 256) ["  6  "
               " 5 * "
               "2 2 *"
               " 6 4 "
               "  1  "])

(= (__ 10 10000) ["   0   "
                  "  1 0  "
                  " 0 1 0 "
                  "* 0 0 0"
                  " * 1 * "
                  "  * *  "
                  "   *   "])

* ;; 4Clojure Question 140
;; Create a function which accepts as input a boolean algebra function
;; in the form of a set of sets, where the inner sets are collections
;; of symbols corresponding to the input boolean variables which
;; satisfy the function (the inputs of the inner sets are conjoint,
;; and the sets themselves are disjoint... also known as canonical
;; minterms). Note:&nbsp;capitalized symbols represent truth, and
;; lower-case symbols represent negation of the inputs. Your function
;; must return the minimal function which is logically equivalent to
;; the input. </br></br> PS &mdash; You may want to give this a read
;; before proceeding: <a
;; href="http://en.wikipedia.org/wiki/K_map">K-Maps</a> </br> PPS
;; &mdash; If you're interested in logic programming more generally,
;; you should also check out: <a
;; href="https://github.com/clojure/core.logic">core.logic</a> 

(= (__ #{#{'a 'B 'C 'd}
         #{'A 'b 'c 'd}
         #{'A 'b 'c 'D}
         #{'A 'b 'C 'd}
         #{'A 'b 'C 'D}
         #{'A 'B 'c 'd}
         #{'A 'B 'c 'D}
         #{'A 'B 'C 'd}})
   #{#{'A 'c} 
     #{'A 'b}
     #{'B 'C 'd}})

(= (__ #{#{'A 'B 'C 'D}
         #{'A 'B 'C 'd}})
   #{#{'A 'B 'C}})

(= (__ #{#{'a 'b 'c 'd}
         #{'a 'B 'c 'd}
         #{'a 'b 'c 'D}
         #{'a 'B 'c 'D}
         #{'A 'B 'C 'd}
         #{'A 'B 'C 'D}
         #{'A 'b 'C 'd}
         #{'A 'b 'C 'D}})
   #{#{'a 'c}
     #{'A 'C}})

(= (__ #{#{'a 'b 'c} 
         #{'a 'B 'c}
         #{'a 'b 'C}
         #{'a 'B 'C}})
   #{#{'a}})

(= (__ #{#{'a 'B 'c 'd}
         #{'A 'B 'c 'D}
         #{'A 'b 'C 'D}
         #{'a 'b 'c 'D}
         #{'a 'B 'C 'D}
         #{'A 'B 'C 'd}})
   #{#{'a 'B 'c 'd}
     #{'A 'B 'c 'D}
     #{'A 'b 'C 'D}
     #{'a 'b 'c 'D}
     #{'a 'B 'C 'D}
     #{'A 'B 'C 'd}})

(= (__ #{#{'a 'b 'c 'd}
         #{'a 'B 'c 'd}
         #{'A 'B 'c 'd}
         #{'a 'b 'c 'D}
         #{'a 'B 'c 'D}
         #{'A 'B 'c 'D}})
   #{#{'a 'c}
     #{'B 'c}})

(= (__ #{#{'a 'B 'c 'd}
         #{'A 'B 'c 'd}
         #{'a 'b 'c 'D}
         #{'a 'b 'C 'D}
         #{'A 'b 'c 'D}
         #{'A 'b 'C 'D}
         #{'a 'B 'C 'd}
         #{'A 'B 'C 'd}})
   #{#{'B 'd}
     #{'b 'D}})

(= (__ #{#{'a 'b 'c 'd}
         #{'A 'b 'c 'd}
         #{'a 'B 'c 'D}
         #{'A 'B 'c 'D}
         #{'a 'B 'C 'D}
         #{'A 'B 'C 'D}
         #{'a 'b 'C 'd}
         #{'A 'b 'C 'd}})
   #{#{'B 'D}
     #{'b 'd}})

* ;; 4Clojure Question 141
;; <p> In <a
;; href="http://en.wikipedia.org/wiki/Trick-taking_game">trick-taking
;; card games</a> such as bridge, spades, or hearts, cards are played
;; in groups known as "tricks" - each player plays a single card, in
;; order; the first player is said to "lead" to the trick. After all
;; players have played, one card is said to have "won" the trick. How
;; the winner is determined will vary by game, but generally the
;; winner is the highest card played <i>in the suit that was led</i>.
;; Sometimes (again varying by game), a particular suit will be
;; designated "trump", meaning that its cards are more powerful than
;; any others: if there is a trump suit, and any trumps are played,
;; then the highest trump wins regardless of what was led. </p> <p>
;; Your goal is to devise a function that can determine which of a
;; number of cards has won a trick. You should accept a trump suit,
;; and return a function <code>winner</code>. Winner will be called on
;; a sequence of cards, and should return the one which wins the
;; trick. Cards will be represented in the format returned by <a
;; href="/problem/128/">Problem 128, Recognize Playing Cards</a>: a
;; hash-map of <code>:suit</code> and a numeric <code>:rank</code>.
;; Cards with a larger rank are stronger. </p> 

(let [notrump (__ nil)]
  (and (= {:suit :club :rank 9}  (notrump [{:suit :club :rank 4}
                                           {:suit :club :rank 9}]))
       (= {:suit :spade :rank 2} (notrump [{:suit :spade :rank 2}
                                           {:suit :club :rank 10}]))))

(= {:suit :club :rank 10} ((__ :club) [{:suit :spade :rank 2}
                                       {:suit :club :rank 10}]))

(= {:suit :heart :rank 8}
   ((__ :heart) [{:suit :heart :rank 6} {:suit :heart :rank 8}
                 {:suit :diamond :rank 10} {:suit :heart :rank 4}]))

* ;; 4Clojure Question 142
;; <p> In <a
;; href="http://en.wikipedia.org/wiki/Trick-taking_game">trick-taking
;; card games</a> such as bridge, spades, or hearts, cards are played
;; in groups known as "tricks" - each player plays a single card, in
;; order; the first player is said to "lead" to the trick. After all
;; players have played, one card is said to have "won" the trick. How
;; the winner is determined will vary by game, but generally the
;; winner is the highest card played <i>in the suit that was led</i>.
;; Sometimes (again varying by game), a particular suit will be
;; designated "trump", meaning that its cards are more powerful than
;; any others: if there is a trump suit, and any trumps are played,
;; then the highest trump wins regardless of what was led. </p> <p>
;; Your goal is to devise a function that can determine which of a
;; number of cards has won a trick. You should accept a trump suit,
;; and return a function <code>winner</code>. Winner will be called on
;; a sequence of cards, and should return the one which wins the
;; trick. Cards will be represented in the format returned by <a
;; href="/problem/128/">Problem 128, Recognize Playing Cards</a>: a
;; hash-map of <code>:suit</code> and a numeric <code>:rank</code>.
;; Cards with a larger rank are stronger. </p> 

(let [notrump (__ nil)]
  (and (= {:suit :club :rank 9}  (notrump [{:suit :club :rank 4}
                                           {:suit :club :rank 9}]))
       (= {:suit :spade :rank 2} (notrump [{:suit :spade :rank 2}
                                           {:suit :club :rank 10}]))))

(= {:suit :club :rank 10} ((__ :club) [{:suit :spade :rank 2}
                                       {:suit :club :rank 10}]))

(= {:suit :heart :rank 8}
   ((__ :heart) [{:suit :heart :rank 6} {:suit :heart :rank 8}
                 {:suit :diamond :rank 10} {:suit :heart :rank 4}]))

* ;; 4Clojure Question 143
;; Create a function that computes the <a
;; href="http://en.wikipedia.org/wiki/Dot_product#Definition">dot
;; product</a> of two sequences. You may assume that the vectors will
;; have the same length. 

(= 0 (__ [0 1 0] [1 0 0]))

(= 3 (__ [1 1 1] [1 1 1]))

(= 32 (__ [1 2 3] [4 5 6]))

(= 256 (__ [2 5 6] [100 10 1]))

* ;; 4Clojure Question 144
;; Write an oscillating iterate: a function that takes an initial
;; value and a variable number of functions. It should return a lazy
;; sequence of the functions applied to the value in order, restarting
;; from the first function after it hits the end. 

(= (take 3 (__ 3.14 int double)) [3.14 3 3.0])

(= (take 5 (__ 3 #(- % 3) #(+ 5 %))) [3 0 5 2 7])

(= (take 12 (__ 0 inc dec inc dec inc)) [0 1 0 1 0 1 2 1 2 1 2 3])


* ;; 4Clojure Question 145
;; Clojure's <a
;; href="http://clojuredocs.org/clojure_core/clojure.core/for">for</a>
;; macro is a tremendously versatile mechanism for producing a
;; sequence based on some other sequence(s). It can take some time to
;; understand how to use it properly, but that investment will be paid
;; back with clear, concise sequence-wrangling later. With that in
;; mind, read over these <code>for</code> expressions and try to see
;; how each of them produces the same result. 

(= __ (for [x (range 40)
            :when (= 1 (rem x 4))]
        x))

(= __ (for [x (iterate #(+ 4 %) 0)
            :let [z (inc x)]
            :while (< z 40)]
        z))

(= __ (for [[x y] (partition 2 (range 20))]
        (+ x y)))

* ;; 4Clojure Question 146
;; <p>Because Clojure's <code>for</code> macro allows you to "walk"
;; over multiple sequences in a nested fashion, it is excellent for
;; transforming all sorts of sequences. If you don't want a sequence
;; as your final output (say you want a map), you are often still
;; best-off using <code>for</code>, because you can produce a sequence
;; and feed it into a map, for example.</p> <p>For this problem, your
;; goal is to "flatten" a map of hashmaps. Each key in your output map
;; should be the "path"<sup>1</sup> that you would have to take in the
;; original map to get to a value, so for example <code>{1 {2
;; 3}}</code> should result in <code>{[1 2] 3}</code>. You only need
;; to flatten one level of maps: if one of the values is a map, just
;; leave it alone.</p> <p><sup>1</sup> That is, <code>(get-in original
;; [k1 k2])</code> should be the same as <code>(get result [k1
;; k2])</code></p> Use M-x 4clojure-check-answers when you're done!

(= (__ '{a {p 1, q 2}
         b {m 3, n 4}})
   '{[a p] 1, [a q] 2
     [b m] 3, [b n] 4})

(= (__ '{[1] {a b c d}
         [2] {q r s t u v w x}})
   '{[[1] a] b, [[1] c] d,
     [[2] q] r, [[2] s] t,
     [[2] u] v, [[2] w] x})

(= (__ '{m {1 [a b c] 3 nil}})
   '{[m 1] [a b c], [m 3] nil})

* ;; 4Clojure Question 147
;; Write a function that, for any given input vector of numbers,
;; returns an infinite lazy sequence of vectors, where each next one
;; is constructed from the previous following the rules used in <a
;; href="http://en.wikipedia.org/wiki/Pascal's_triangle">Pascal's
;; Triangle</a>. For example, for [3 1 2], the next row is [3 4 3 2].
;; Use M-x 4clojure-check-answers when you're done!

(= (second (__ [2 3 2])) [2 5 5 2])

(= (take 5 (__ [1])) [[1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1]])

(= (take 2 (__ [3 1 2])) [[3 1 2] [3 4 3 2]])

(= (take 100 (__ [2 4 2])) (rest (take 101 (__ [2 2]))))

* ;; 4Clojure Question 148
;; <p>Write a function which calculates the sum of all natural numbers
;; under <i>n</i> (first argument) which are evenly divisible by at
;; least one of <i>a</i> and <i>b</i> (second and third argument).
;; Numbers <i>a</i> and <i>b</i> are guaranteed to be <a
;; href="http://en.wikipedia.org/wiki/Coprime">coprimes</a>.</p>
;; <p>Note: Some test cases have a very large <i>n</i>, so the most
;; obvious solution will exceed the time limit.</p> 

(= 0 (__ 3 17 11))

(= 23 (__ 10 3 5))

(= 233168 (__ 1000 3 5))

(= "2333333316666668" (str (__ 100000000 3 5)))

(= "110389610389889610389610"
  (str (__ (* 10000 10000 10000) 7 11)))

(= "1277732511922987429116"
  (str (__ (* 10000 10000 10000) 757 809)))

(= "4530161696788274281"
  (str (__ (* 10000 10000 1000) 1597 3571)))

* ;; 4Clojure Question 149
;; <p>Write a function which calculates the sum of all natural numbers
;; under <i>n</i> (first argument) which are evenly divisible by at
;; least one of <i>a</i> and <i>b</i> (second and third argument).
;; Numbers <i>a</i> and <i>b</i> are guaranteed to be <a
;; href="http://en.wikipedia.org/wiki/Coprime">coprimes</a>.</p>
;; <p>Note: Some test cases have a very large <i>n</i>, so the most
;; obvious solution will exceed the time limit.</p> 

(= 0 (__ 3 17 11))

(= 23 (__ 10 3 5))

(= 233168 (__ 1000 3 5))

(= "2333333316666668" (str (__ 100000000 3 5)))

(= "110389610389889610389610"
  (str (__ (* 10000 10000 10000) 7 11)))

(= "1277732511922987429116"
  (str (__ (* 10000 10000 10000) 757 809)))

(= "4530161696788274281"
  (str (__ (* 10000 10000 1000) 1597 3571)))

* ;; 4Clojure Question 150
;; <p>A palindromic number is a number that is the same when written
;; forwards or backwards (e.g., 3, 99, 14341).</p> <p>Write a function
;; which takes an integer <code>n</code>, as its only argument, and
;; returns an increasing lazy sequence of all palindromic numbers that
;; are not less than <code>n</code>.</p> <p>The most simple solution
;; will exceed the time limit!</p> 

(= (take 26 (__ 0))
   [0 1 2 3 4 5 6 7 8 9 
    11 22 33 44 55 66 77 88 99 
    101 111 121 131 141 151 161])

(= (take 16 (__ 162))
   [171 181 191 202 
    212 222 232 242 
    252 262 272 282 
    292 303 313 323])

(= (take 6 (__ 1234550000))
   [1234554321 1234664321 1234774321 
    1234884321 1234994321 1235005321])

(= (first (__ (* 111111111 111111111)))
   (* 111111111 111111111))

(= (set (take 199 (__ 0)))
   (set (map #(first (__ %)) (range 0 10000))))

(= true 
   (apply < (take 6666 (__ 9999999))))

(= (nth (__ 0) 10101)
   9102019)

* ;; 4Clojure Question 151
;; <p>A palindromic number is a number that is the same when written
;; forwards or backwards (e.g., 3, 99, 14341).</p> <p>Write a function
;; which takes an integer <code>n</code>, as its only argument, and
;; returns an increasing lazy sequence of all palindromic numbers that
;; are not less than <code>n</code>.</p> <p>The most simple solution
;; will exceed the time limit!</p> 

(= (take 26 (__ 0))
   [0 1 2 3 4 5 6 7 8 9 
    11 22 33 44 55 66 77 88 99 
    101 111 121 131 141 151 161])

(= (take 16 (__ 162))
   [171 181 191 202 
    212 222 232 242 
    252 262 272 282 
    292 303 313 323])

(= (take 6 (__ 1234550000))
   [1234554321 1234664321 1234774321 
    1234884321 1234994321 1235005321])

(= (first (__ (* 111111111 111111111)))
   (* 111111111 111111111))

(= (set (take 199 (__ 0)))
   (set (map #(first (__ %)) (range 0 10000))))

(= true 
   (apply < (take 6666 (__ 9999999))))

(= (nth (__ 0) 10101)
   9102019)

* ;; 4Clojure Question 152
;; <p> A <a href="http://en.wikipedia.org/wiki/Latin_square">Latin
;; square</a> of order <code>n</code> is an <code>n x n</code> array
;; that contains <code>n</code> different elements, each occurring
;; exactly once in each row, and exactly once in each column. For
;; example, among the following arrays <i>only the first one</i> forms
;; a Latin square: <pre> A B C A B C A B C B C A B C A B D A C A B C A
;; C C A B </pre> </p> <p> Let <code>V</code> be a vector of such
;; vectors<sup>1</sup> that they may differ in length<sup>2</sup>. We
;; will say that an arrangement of vectors of <code>V</code> in
;; consecutive rows is an <em>alignment (of vectors) of</em>
;; <code>V</code> if the following conditions are satisfied: <ul>
;; <li>All vectors of <code>V</code> are used.</li> <li>Each row
;; contains just one vector.</li> <li>The order of <code>V</code> is
;; preserved.</li> <li>All vectors of maximal length are horizontally
;; aligned each other.</li> <li>If a vector is not of maximal length
;; then all its elements are aligned with elements of some <a
;; href="http://clojuredocs.org/clojure_core/clojure.core/subvec">subvector</a>
;; of a vector of maximal length.</li> </ul> Let <code>L</code> denote
;; a Latin square of order 2 or greater. We will say that
;; <code>L</code> <em>is included</em> in <code>V</code> or that
;; <code>V</code> <em>includes</em> <code>L</code> iff there exists an
;; alignment of <code>V</code> such that contains a subsquare that is
;; equal to <code>L</code>. </p> <p> For example, if <code>V</code>
;; equals <code>[[1 2 3][2 3 1 2 1][3 1 2]]</code> then there are nine
;; alignments of <code>V</code> (brackets omitted): <pre> 1 2 3 1 2 3
;; 1 2 3 1 2 3 A 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 3 1 2 3 1 2 3 1 2 1 2 3
;; 1 2 3 1 2 3 B 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 3 1 2 3 1 2 3 1 2 1 2 3
;; 1 2 3 1 2 3 C 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 3 1 2 3 1 2 3 1 2
;; </pre> Alignment <b>A1</b> contains Latin square <code>[[1 2 3][2 3
;; 1][3 1 2]]</code>, alignments <b>A2, A3, B1, B2, B3</b> contain no
;; Latin squares, and alignments <b>C1, C2, C3</b> contain <code>[[2
;; 1][1 2]]</code>. Thus in this case <code>V</code> includes one
;; Latin square of order 3 and one of order 2 which is included three
;; times. </p> <p> Our aim is to implement a function which accepts a
;; vector of vectors <code>V</code> as an argument, and returns a map
;; which keys and values are integers. Each key should be the order of
;; a Latin square included in <code>V</code>, and its value a count of
;; <i>different</i> Latin squares of that order included in
;; <code>V</code>. If <code>V</code> does not include any Latin
;; squares an empty map should be returned. In the previous example
;; the correct output of such a function is {3 1, 2 1} and <i>not</i>
;; {3 1, 2 3}. </p> <p> <sup>1</sup> Of course, we can consider
;; sequences instead of vectors. <br /> <sup>2</sup> Length of a
;; vector is the number of elements in the vector. </p> 

(= (__ '[[A B C D]
         [A C D B]
         [B A D C]
         [D C A B]])
   {})

(= (__ '[[A B C D E F]
         [B C D E F A]
         [C D E F A B]
         [D E F A B C]
         [E F A B C D]
         [F A B C D E]])
   {6 1})

(= (__ '[[A B C D]
         [B A D C]
         [D C B A]
         [C D A B]])
   {4 1, 2 4})

(= (__ '[[B D A C B]
         [D A B C A]
         [A B C A B]
         [B C A B C]
         [A D B C A]])
   {3 3})

(= (__ [  [2 4 6 3]
        [3 4 6 2]
          [6 2 4]  ])
   {})

(= (__ [[1]
        [1 2 1 2]
        [2 1 2 1]
        [1 2 1 2]
        []       ])
   {2 2})

(= (__ [[3 1 2]
        [1 2 3 1 3 4]
        [2 3 1 3]    ])
   {3 1, 2 2})

(= (__ [[8 6 7 3 2 5 1 4]
        [6 8 3 7]
        [7 3 8 6]
        [3 7 6 8 1 4 5 2]
              [1 8 5 2 4]
              [8 1 2 4 5]])
   {4 1, 3 1, 2 7})

* ;; 4Clojure Question 153
;; <p> Given a set of sets, create a function which returns
;; <code>true</code> if no two of those sets have any elements in
;; common<sup>1</sup> and <code>false</code> otherwise. Some of the
;; test cases are a bit tricky, so pay a little more attention to
;; them. </p> <p> <sup>1</sup>Such sets are usually called <i>pairwise
;; disjoint</i> or <i>mutually disjoint</i>. </p> 

(= (__ #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
   true)

(= (__ #{#{:a :b :c :d :e}
         #{:a :b :c :d}
         #{:a :b :c}
         #{:a :b}
         #{:a}})
   false)

(= (__ #{#{[1 2 3] [4 5]}
         #{[1 2] [3 4 5]}
         #{[1] [2] 3 4 5}
         #{1 2 [3 4] [5]}})
   true)

(= (__ #{#{'a 'b}
         #{'c 'd 'e}
         #{'f 'g 'h 'i}
         #{''a ''c ''f}})
   true)

(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}
         #{#{:x :y :z} #{:x :y} #{:z} #{}}
         #{'[:x :y :z] [:x :y] [:z] [] {}}})
   false)

(= (__ #{#{(= "true") false}
         #{:yes :no}
         #{(class 1) 0}
         #{(symbol "true") 'false}
         #{(keyword "yes") ::no}
         #{(class '1) (int \0)}})
   false)

(= (__ #{#{distinct?}
         #{#(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}})
   true)

(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}
         #{'+ '* mapcat (comment mapcat)}
         #{(do) set contains? nil?}
         #{, , , #_, , empty?}})
   false)

* ;; 4Clojure Question 154
;; <p> Given a set of sets, create a function which returns
;; <code>true</code> if no two of those sets have any elements in
;; common<sup>1</sup> and <code>false</code> otherwise. Some of the
;; test cases are a bit tricky, so pay a little more attention to
;; them. </p> <p> <sup>1</sup>Such sets are usually called <i>pairwise
;; disjoint</i> or <i>mutually disjoint</i>. </p> 

(= (__ #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
   true)

(= (__ #{#{:a :b :c :d :e}
         #{:a :b :c :d}
         #{:a :b :c}
         #{:a :b}
         #{:a}})
   false)

(= (__ #{#{[1 2 3] [4 5]}
         #{[1 2] [3 4 5]}
         #{[1] [2] 3 4 5}
         #{1 2 [3 4] [5]}})
   true)

(= (__ #{#{'a 'b}
         #{'c 'd 'e}
         #{'f 'g 'h 'i}
         #{''a ''c ''f}})
   true)

(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}
         #{#{:x :y :z} #{:x :y} #{:z} #{}}
         #{'[:x :y :z] [:x :y] [:z] [] {}}})
   false)

(= (__ #{#{(= "true") false}
         #{:yes :no}
         #{(class 1) 0}
         #{(symbol "true") 'false}
         #{(keyword "yes") ::no}
         #{(class '1) (int \0)}})
   false)

(= (__ #{#{distinct?}
         #{#(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}})
   true)

(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}
         #{'+ '* mapcat (comment mapcat)}
         #{(do) set contains? nil?}
         #{, , , #_, , empty?}})
   false)

* ;; 4Clojure Question 155
;; <p> Given a set of sets, create a function which returns
;; <code>true</code> if no two of those sets have any elements in
;; common<sup>1</sup> and <code>false</code> otherwise. Some of the
;; test cases are a bit tricky, so pay a little more attention to
;; them. </p> <p> <sup>1</sup>Such sets are usually called <i>pairwise
;; disjoint</i> or <i>mutually disjoint</i>. </p> 

(= (__ #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
   true)

(= (__ #{#{:a :b :c :d :e}
         #{:a :b :c :d}
         #{:a :b :c}
         #{:a :b}
         #{:a}})
   false)

(= (__ #{#{[1 2 3] [4 5]}
         #{[1 2] [3 4 5]}
         #{[1] [2] 3 4 5}
         #{1 2 [3 4] [5]}})
   true)

(= (__ #{#{'a 'b}
         #{'c 'd 'e}
         #{'f 'g 'h 'i}
         #{''a ''c ''f}})
   true)

(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}
         #{#{:x :y :z} #{:x :y} #{:z} #{}}
         #{'[:x :y :z] [:x :y] [:z] [] {}}})
   false)

(= (__ #{#{(= "true") false}
         #{:yes :no}
         #{(class 1) 0}
         #{(symbol "true") 'false}
         #{(keyword "yes") ::no}
         #{(class '1) (int \0)}})
   false)

(= (__ #{#{distinct?}
         #{#(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}})
   true)

(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}
         #{'+ '* mapcat (comment mapcat)}
         #{(do) set contains? nil?}
         #{, , , #_, , empty?}})
   false)

* ;; 4Clojure Question 156
;; When retrieving values from a map, you can specify default values
;; in case the key is not found:<br/><br/>(= 2 (:foo {:bar 0, :baz 1}
;; 2))<br/><br/>However, what if you want the map itself to contain
;; the default values? Write a function which takes a default value
;; and a sequence of keys and constructs a map. 

(= (__ 0 [:a :b :c]) {:a 0 :b 0 :c 0})

(= (__ "x" [1 2 3]) {1 "x" 2 "x" 3 "x"})

(= (__ [:a :b] [:foo :bar]) {:foo [:a :b] :bar [:a :b]})


* ;; 4Clojure Question 157
;; Transform a sequence into a sequence of pairs containing the
;; original elements along with their index. 

(= (__ [:a :b :c]) [[:a 0] [:b 1] [:c 2]])

(= (__ [0 1 3]) '((0 0) (1 1) (3 2)))

(= (__ [[:foo] {:bar :baz}]) [[[:foo] 0] [{:bar :baz} 1]])


* ;; 4Clojure Question 158
;; Write a function that accepts a curried function of unknown arity
;; <i>n</i>. Return an equivalent function of <i>n</i> arguments.
;; <br/> You may wish to read <a
;; href="http://en.wikipedia.org/wiki/Currying">this</a>. 

(= 10 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (+ a b c d))))))
       1 2 3 4))

(= 24 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (* a b c d))))))
       1 2 3 4))

(= 25 ((__ (fn [a]
             (fn [b]
               (* a b))))
       5 5))



* ;; 4Clojure Question 159
;; Write a function that accepts a curried function of unknown arity
;; <i>n</i>. Return an equivalent function of <i>n</i> arguments.
;; <br/> You may wish to read <a
;; href="http://en.wikipedia.org/wiki/Currying">this</a>. 

(= 10 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (+ a b c d))))))
       1 2 3 4))

(= 24 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (* a b c d))))))
       1 2 3 4))

(= 25 ((__ (fn [a]
             (fn [b]
               (* a b))))
       5 5))



* ;; 4Clojure Question 160
;; Write a function that accepts a curried function of unknown arity
;; <i>n</i>. Return an equivalent function of <i>n</i> arguments.
;; <br/> You may wish to read <a
;; href="http://en.wikipedia.org/wiki/Currying">this</a>. 

(= 10 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (+ a b c d))))))
       1 2 3 4))

(= 24 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (* a b c d))))))
       1 2 3 4))

(= 25 ((__ (fn [a]
             (fn [b]
               (* a b))))
       5 5))



* ;; 4Clojure Question 161
;; Set A is a subset of set B, or equivalently B is a superset of A,
;; if A is "contained" inside B. A and B may coincide. 

(clojure.set/superset? __ #{2})

(clojure.set/subset? #{1} __)

(clojure.set/superset? __ #{1 2})

(clojure.set/subset? #{1 2} __)


* ;; 4Clojure Question 162
;; In Clojure, only nil and false represent the values of logical
;; falsity in conditional tests - anything else is logical truth. Use
;; M-x 4clojure-check-answers when you're done!

(= __ (if-not false 1 0))

(= __ (if-not nil 1 0))

(= __ (if true 1 0))

(= __ (if [] 1 0))

(= __ (if [0] 1 0))

(= __ (if 0 1 0))

(= __ (if 1 1 0))


* ;; 4Clojure Question 163
;; In Clojure, only nil and false represent the values of logical
;; falsity in conditional tests - anything else is logical truth. Use
;; M-x 4clojure-check-answers when you're done!

(= __ (if-not false 1 0))

(= __ (if-not nil 1 0))

(= __ (if true 1 0))

(= __ (if [] 1 0))

(= __ (if [0] 1 0))

(= __ (if 0 1 0))

(= __ (if 1 1 0))


* ;; 4Clojure Question 164
;; A <a
;; href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic
;; finite automaton (DFA)</a> is an abstract machine that recognizes a
;; <a href=" http://en.wikipedia.org/wiki/Regular_language">regular
;; language</a>. Usually a DFA is defined by a 5-tuple, but instead
;; we'll use a map with 5 keys: <ul> <li><var>:states</var> is the set
;; of states for the DFA.</li> <li><var>:alphabet</var> is the set of
;; symbols included in the language recognized by the DFA. </li>
;; <li><var>:start</var> is the start state of the DFA. </li>
;; <li><var>:accepts</var> is the set of accept states in the DFA.
;; </li> <li><var>:transitions</var> is the transition function for
;; the DFA, mapping <var>:states</var> &#x2a2f <var>:alphabet</var>
;; onto <var>:states</var>.</li> </ul> Write a function that takes as
;; input a DFA definition (as described above) and returns a sequence
;; enumerating all strings in the language recognized by the DFA.
;; Note: Although the DFA itself is finite and only recognizes
;; finite-length strings it can still recognize an infinite set of
;; finite-length strings. And because stack space is finite, make sure
;; you don't get stuck in an infinite loop that's not producing
;; results every so often! 

(= #{"a" "ab" "abc"}
   (set (__ '{:states #{q0 q1 q2 q3}
              :alphabet #{a b c}
              :start q0
              :accepts #{q1 q2 q3}
              :transitions {q0 {a q1}
                            q1 {b q2}
                            q2 {c q3}}})))


(= #{"hi" "hey" "hello"}
   (set (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7}
              :alphabet #{e h i l o y}
              :start q0
              :accepts #{q2 q4 q7}
              :transitions {q0 {h q1}
                            q1 {i q2, e q3}
                            q3 {l q5, y q4}
                            q5 {l q6}
                            q6 {o q7}}})))

(= (set (let [ss "vwxyz"] (for [i ss, j ss, k ss, l ss] (str i j k l))))
   (set (__ '{:states #{q0 q1 q2 q3 q4}
              :alphabet #{v w x y z}
              :start q0
              :accepts #{q4}
              :transitions {q0 {v q1, w q1, x q1, y q1, z q1}
                            q1 {v q2, w q2, x q2, y q2, z q2}
                            q2 {v q3, w q3, x q3, y q3, z q3}
                            q3 {v q4, w q4, x q4, y q4, z q4}}})))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{0 1}
                           :start q0
                           :accepts #{q0}
                           :transitions {q0 {0 q0, 1 q1}
                                         q1 {0 q1, 1 q0}}}))]
  (and (every? (partial re-matches #"0*(?:10*10*)*") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{n m}
                           :start q0
                           :accepts #{q1}
                           :transitions {q0 {n q0, m q1}}}))]
  (and (every? (partial re-matches #"n*m") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7 q8 q9}
                           :alphabet #{i l o m p t}
                           :start q0
                           :accepts #{q5 q8}
                           :transitions {q0 {l q1}
                                         q1 {i q2, o q6}
                                         q2 {m q3}
                                         q3 {i q4}
                                         q4 {t q5}
                                         q6 {o q7}
                                         q7 {p q8}
                                         q8 {l q9}
                                         q9 {o q6}}}))]
  (and (every? (partial re-matches #"limit|(?:loop)+") res)
       (= res (distinct res))))



* ;; 4Clojure Question 165
;; A <a
;; href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic
;; finite automaton (DFA)</a> is an abstract machine that recognizes a
;; <a href=" http://en.wikipedia.org/wiki/Regular_language">regular
;; language</a>. Usually a DFA is defined by a 5-tuple, but instead
;; we'll use a map with 5 keys: <ul> <li><var>:states</var> is the set
;; of states for the DFA.</li> <li><var>:alphabet</var> is the set of
;; symbols included in the language recognized by the DFA. </li>
;; <li><var>:start</var> is the start state of the DFA. </li>
;; <li><var>:accepts</var> is the set of accept states in the DFA.
;; </li> <li><var>:transitions</var> is the transition function for
;; the DFA, mapping <var>:states</var> &#x2a2f <var>:alphabet</var>
;; onto <var>:states</var>.</li> </ul> Write a function that takes as
;; input a DFA definition (as described above) and returns a sequence
;; enumerating all strings in the language recognized by the DFA.
;; Note: Although the DFA itself is finite and only recognizes
;; finite-length strings it can still recognize an infinite set of
;; finite-length strings. And because stack space is finite, make sure
;; you don't get stuck in an infinite loop that's not producing
;; results every so often! 

(= #{"a" "ab" "abc"}
   (set (__ '{:states #{q0 q1 q2 q3}
              :alphabet #{a b c}
              :start q0
              :accepts #{q1 q2 q3}
              :transitions {q0 {a q1}
                            q1 {b q2}
                            q2 {c q3}}})))


(= #{"hi" "hey" "hello"}
   (set (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7}
              :alphabet #{e h i l o y}
              :start q0
              :accepts #{q2 q4 q7}
              :transitions {q0 {h q1}
                            q1 {i q2, e q3}
                            q3 {l q5, y q4}
                            q5 {l q6}
                            q6 {o q7}}})))

(= (set (let [ss "vwxyz"] (for [i ss, j ss, k ss, l ss] (str i j k l))))
   (set (__ '{:states #{q0 q1 q2 q3 q4}
              :alphabet #{v w x y z}
              :start q0
              :accepts #{q4}
              :transitions {q0 {v q1, w q1, x q1, y q1, z q1}
                            q1 {v q2, w q2, x q2, y q2, z q2}
                            q2 {v q3, w q3, x q3, y q3, z q3}
                            q3 {v q4, w q4, x q4, y q4, z q4}}})))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{0 1}
                           :start q0
                           :accepts #{q0}
                           :transitions {q0 {0 q0, 1 q1}
                                         q1 {0 q1, 1 q0}}}))]
  (and (every? (partial re-matches #"0*(?:10*10*)*") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{n m}
                           :start q0
                           :accepts #{q1}
                           :transitions {q0 {n q0, m q1}}}))]
  (and (every? (partial re-matches #"n*m") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7 q8 q9}
                           :alphabet #{i l o m p t}
                           :start q0
                           :accepts #{q5 q8}
                           :transitions {q0 {l q1}
                                         q1 {i q2, o q6}
                                         q2 {m q3}
                                         q3 {i q4}
                                         q4 {t q5}
                                         q6 {o q7}
                                         q7 {p q8}
                                         q8 {l q9}
                                         q9 {o q6}}}))]
  (and (every? (partial re-matches #"limit|(?:loop)+") res)
       (= res (distinct res))))



* ;; 4Clojure Question 166
;; For any orderable data type it's possible to derive all of the
;; basic comparison operations (&lt;, &le;, =, &ne;, &ge;, and &gt;)
;; from a single operation (any operator but = or &ne; will work).
;; Write a function that takes three arguments, a <var>less than</var>
;; operator for the data and two items to compare. The function should
;; return a keyword describing the relationship between the two items.
;; The keywords for the relationship between <var>x</var> and
;; <var>y</var> are as follows: <ul> <li><var>x</var> = <var>y</var>
;; &rarr; :eq</li> <li><var>x</var> &gt; <var>y</var> &rarr; :gt</li>
;; <li><var>x</var> &lt; <var>y</var> &rarr; :lt</li> </ul> 

(= :gt (__ < 5 1))

(= :eq (__ (fn [x y] (< (count x) (count y))) "pear" "plum"))

(= :lt (__ (fn [x y] (< (mod x 5) (mod y 5))) 21 3))

(= :gt (__ > 0 2))



* ;; 4Clojure Question 167
;; For any orderable data type it's possible to derive all of the
;; basic comparison operations (&lt;, &le;, =, &ne;, &ge;, and &gt;)
;; from a single operation (any operator but = or &ne; will work).
;; Write a function that takes three arguments, a <var>less than</var>
;; operator for the data and two items to compare. The function should
;; return a keyword describing the relationship between the two items.
;; The keywords for the relationship between <var>x</var> and
;; <var>y</var> are as follows: <ul> <li><var>x</var> = <var>y</var>
;; &rarr; :eq</li> <li><var>x</var> &gt; <var>y</var> &rarr; :gt</li>
;; <li><var>x</var> &lt; <var>y</var> &rarr; :lt</li> </ul> 

(= :gt (__ < 5 1))

(= :eq (__ (fn [x y] (< (count x) (count y))) "pear" "plum"))

(= :lt (__ (fn [x y] (< (mod x 5) (mod y 5))) 21 3))

(= :gt (__ > 0 2))



* ;; 4Clojure Question 168
;; <p> In what follows, <code>m</code>, <code>n</code>,
;; <code>s</code>, <code>t</code> denote nonnegative integers,
;; <code>f</code> denotes a function that accepts two arguments and is
;; defined for all nonnegative integers in both arguments. </p> <p> In
;; mathematics, the function <code>f</code> can be interpreted as an
;; infinite <a
;; href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrix</a>
;; with infinitely many rows and columns that, when written, looks
;; like an ordinary matrix but its rows and columns cannot be written
;; down completely, so are terminated with ellipses. In Clojure, such
;; infinite matrix can be represented as an infinite lazy sequence of
;; infinite lazy sequences, where the inner sequences represent rows.
;; </p> <p> Write a function that accepts 1, 3 and 5 arguments <ul>
;; <li> with the argument <code>f</code>, it returns the infinite
;; matrix <b>A</b> that has the entry in the <code>i</code>-th row and
;; the <code>j</code>-th column equal to <code>f(i,j)</code> for
;; <code>i,j = 0,1,2,...</code>;</li> <li> with the arguments
;; <code>f</code>, <code>m</code>, <code>n</code>, it returns the
;; infinite matrix <b>B</b> that equals the remainder of the matrix
;; <b>A</b> after the removal of the first <code>m</code> rows and the
;; first <code>n</code> columns;</li> <li> with the arguments
;; <code>f</code>, <code>m</code>, <code>n</code>, <code>s</code>,
;; <code>t</code>, it returns the finite s-by-t matrix that consists
;; of the first t entries of each of the first <code>s</code> rows of
;; the matrix <b>B</b> or, equivalently, that consists of the first s
;; entries of each of the first <code>t</code> columns of the matrix
;; <b>B</b>.</li> </ul> </p> Restrictions (please don't use these
;; function(s)): for, range, iterate, repeat, cycle, drop 

(= (take 5 (map #(take 6 %) (__ str)))
   [["00" "01" "02" "03" "04" "05"]
    ["10" "11" "12" "13" "14" "15"]
    ["20" "21" "22" "23" "24" "25"]
    ["30" "31" "32" "33" "34" "35"]
    ["40" "41" "42" "43" "44" "45"]])

(= (take 6 (map #(take 5 %) (__ str 3 2)))
   [["32" "33" "34" "35" "36"]
    ["42" "43" "44" "45" "46"]
    ["52" "53" "54" "55" "56"]
    ["62" "63" "64" "65" "66"]
    ["72" "73" "74" "75" "76"]
    ["82" "83" "84" "85" "86"]])

(= (__ * 3 5 5 7)
   [[15 18 21 24 27 30 33]
    [20 24 28 32 36 40 44]
    [25 30 35 40 45 50 55]
    [30 36 42 48 54 60 66]
    [35 42 49 56 63 70 77]])

(= (__ #(/ % (inc %2)) 1 0 6 4)
   [[1/1 1/2 1/3 1/4]
    [2/1 2/2 2/3 1/2]
    [3/1 3/2 3/3 3/4]
    [4/1 4/2 4/3 4/4]
    [5/1 5/2 5/3 5/4]
    [6/1 6/2 6/3 6/4]])

(= (class (__ (juxt bit-or bit-xor)))
   (class (__ (juxt quot mod) 13 21))
   (class (lazy-seq)))

(= (class (nth (__ (constantly 10946)) 34))
   (class (nth (__ (constantly 0) 5 8) 55))
   (class (lazy-seq)))

(= (let [m 377 n 610 w 987
         check (fn [f s] (every? true? (map-indexed f s)))
         row (take w (nth (__ vector) m))
         column (take w (map first (__ vector m n)))
         diagonal (map-indexed #(nth %2 %) (__ vector m n w w))]
     (and (check #(= %2 [m %]) row)
          (check #(= %2 [(+ m %) n]) column)
          (check #(= %2 [(+ m %) (+ n %)]) diagonal)))
   true)


* ;; 4Clojure Question 169
;;
;; <p>
;;
;; In what follows, <code>m</code>, <code>n</code>, <code>s</code>, <code>t</code> 
;;
;; denote nonnegative integers, <code>f</code> denotes a function that accepts two 
;;
;; arguments and is defined for all nonnegative integers in both arguments.
;;
;; </p>
;;
;; 
;;
;; <p>
;;
;; In mathematics, the function <code>f</code> can be interpreted as an infinite 
;;
;; <a href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrix</a>
;;
;; with infinitely many rows and columns that, when written, looks like an ordinary 
;;
;; matrix but its rows and columns cannot be written down completely, so are terminated 
;;
;; with ellipses. In Clojure, such infinite matrix can be represented 
;;
;; as an infinite lazy sequence of infinite lazy sequences, 
;;
;; where the inner sequences represent rows.
;;
;; </p> 
;;
;; 
;;
;; <p>
;;
;; Write a function that accepts 1, 3 and 5 arguments
;;
;; <ul>
;;
;; <li>
;;
;; with the argument <code>f</code>, it returns the infinite matrix <b>A</b>  
;;
;; that has the entry in the <code>i</code>-th row and the <code>j</code>-th column 
;;
;; equal to <code>f(i,j)</code> for <code>i,j = 0,1,2,...</code>;</li>
;;
;; <li>
;;
;; with the arguments <code>f</code>, <code>m</code>, <code>n</code>, it returns 
;;
;; the infinite matrix <b>B</b> that equals the remainder of the matrix <b>A</b> 
;;
;; after the removal of the first <code>m</code> rows and the first <code>n</code> columns;</li>
;;
;; <li>
;;
;; with the arguments <code>f</code>, <code>m</code>, <code>n</code>, <code>s</code>, <code>t</code>,
;;
;; it returns the finite s-by-t matrix that consists of the first t entries of each of the first 
;;
;; <code>s</code> rows of the matrix <b>B</b> or, equivalently, that consists of the first s entries 
;;
;; of each of the first <code>t</code> columns of the matrix <b>B</b>.</li>
;;
;; </ul>
;;
;; </p>
;;
;; Restrictions (please don't use these function(s)): for, range, iterate, repeat, cycle, drop
;;
;; Use M-x 4clojure-check-answers when you're done!

(= (take 5 (map #(take 6 %) (__ str)))
   [["00" "01" "02" "03" "04" "05"]
    ["10" "11" "12" "13" "14" "15"]
    ["20" "21" "22" "23" "24" "25"]
    ["30" "31" "32" "33" "34" "35"]
    ["40" "41" "42" "43" "44" "45"]])

(= (take 6 (map #(take 5 %) (__ str 3 2)))
   [["32" "33" "34" "35" "36"]
    ["42" "43" "44" "45" "46"]
    ["52" "53" "54" "55" "56"]
    ["62" "63" "64" "65" "66"]
    ["72" "73" "74" "75" "76"]
    ["82" "83" "84" "85" "86"]])

(= (__ * 3 5 5 7)
   [[15 18 21 24 27 30 33]
    [20 24 28 32 36 40 44]
    [25 30 35 40 45 50 55]
    [30 36 42 48 54 60 66]
    [35 42 49 56 63 70 77]])

(= (__ #(/ % (inc %2)) 1 0 6 4)
   [[1/1 1/2 1/3 1/4]
    [2/1 2/2 2/3 1/2]
    [3/1 3/2 3/3 3/4]
    [4/1 4/2 4/3 4/4]
    [5/1 5/2 5/3 5/4]
    [6/1 6/2 6/3 6/4]])

(= (class (__ (juxt bit-or bit-xor)))
   (class (__ (juxt quot mod) 13 21))
   (class (lazy-seq)))

(= (class (nth (__ (constantly 10946)) 34))
   (class (nth (__ (constantly 0) 5 8) 55))
   (class (lazy-seq)))

(= (let [m 377 n 610 w 987
         check (fn [f s] (every? true? (map-indexed f s)))
         row (take w (nth (__ vector) m))
         column (take w (map first (__ vector m n)))
         diagonal (map-indexed #(nth %2 %) (__ vector m n w w))]
     (and (check #(= %2 [m %]) row)
          (check #(= %2 [(+ m %) n]) column)
          (check #(= %2 [(+ m %) (+ n %)]) diagonal)))
   true)

