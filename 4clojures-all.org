* 1 (= __ true)					      :drill:
  
;; This is a clojure form. Enter a value which will make the form
;; evaluate to true. Don't over think it! If you are confused, see the
;; <a href='/directions'>getting started</a> page. Hint: true is equal
;; to true. Use M-x 4clojure-check-answers when you're done!

#+BEGIN_SRC clojure
(= __ true)
#+END_SRC

** solutions

Solutions:
#+BEGIN_SRC clojure
true
#+END_SRC

0x89's solution:
#+BEGIN_SRC clojure
true
#+END_SRC

_pcl's solution:
#+BEGIN_SRC clojure
(not false)
#+END_SRC


------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure


(reify Object (equals [_ _] (= _)))
#+END_SRC

------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(= (clojure-version) "1.4.0")
#+END_SRC

* 2 prefix arithmetic 			      
  :PROPERTIES:
  :ID:       3101A095-10A7-4057-A1CF-171916AD50D9
  :END:

(= (- 10 (* 2 3)) __)

** solutions


Solutions:

4
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure


(- 10 (* 2 3))
#+END_SRC

* 3 java string methods on clojure strings          

#+BEGIN_SRC clojure
;; Clojure strings are Java strings. This means that you can use any
;; of the Java string methods on Clojure strings. 

(= __ (.toUpperCase "hello world"))
#+END_SRC

** solutions

Solutions:

"HELLO WORLD"

------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(reify Object (equals [_ _] (= _)))
#+END_SRC
----------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
"HELLO WORLD"
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(.toUpperCase "hello world")
#+END_SRC
------------------------------------------------------------------------------------------------

* 4 list fn vs. quoted literal

#+BEGIN_SRC clojure
;; Lists can be constructed with either a function or a quoted form.
;; Use M-x 4clojure-check-answers when you're done!

(= (list __) '(:a :b :c))
#+END_SRC

** solutions

Solutions:

:a :b :c

* 5 conj-ing to a list

#+BEGIN_SRC clojure
;; When operating on a list, the conj function will return a new list
;; with one or more items "added" to the front. 

(= __ (conj '(2 3 4) 1))

(= __ (conj '(3 4) 2 1))
#+END_SRC

** solutions

Solutions:

'(1 2 3 4)
0x89's solution:
#+BEGIN_SRC clojure
[1 2 3 4]
#+END_SRC

* 6 vector creation--literal and fn

#+BEGIN_SRC clojure
;; Vectors can be constructed several ways. You can compare them with
;; lists. Use M-x 4clojure-check-answers when you're done!

(= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
#+END_SRC

** solutions

Solutions:

:a :b :c

* 7 conj-ing to a vector

#+BEGIN_SRC clojure
;; When operating on a Vector, the conj function will return a new
;; vector with one or more items "added" to the end. 

(= __ (conj [1 2 3] 4))

(= __ (conj [1 2] 3 4))
#+END_SRC

** solutions



Solutions:

[1 2 3 4]

* 8 set and clojure.set functions

#+BEGIN_SRC clojure
;; Sets are collections of unique values. 

(= __ (set '(:a :a :b :c :c :c :c :d :d)))

(= __ (clojure.set/union #{:a :b :c} #{:b :c :d}))
#+END_SRC

** solutions



Solutions:

#{:a :b :c :d}
0x89's solution:
#+BEGIN_SRC clojure
#{:a :b :c :d}
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(set '(:a :b :c :d))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#{:a :b :c :d}
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#{:a :b :c :d}
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#{:a :b :c :d}
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
'#{:a :b :c :d}
#+END_SRC

* 9 conj-ing to a set

#+BEGIN_SRC clojure
;; When operating on a set, the conj function returns a new set with
;; one or more keys "added". 


(= #{1 2 3 4} (conj #{1 4 3} __))
#+END_SRC

** solutions
Solutions:

2
0x89's solution:
#+BEGIN_SRC clojure
2
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
2
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
2
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
2
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
2
#+END_SRC 3
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
2
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
1
#+END_SRC 2 3
------------------------------------------------------------------------------------------------

* 10 maps and lookup

#+BEGIN_SRC clojure
;; Maps store key-value pairs. Both maps and keywords can be used as
;; lookup functions. Commas can be used to make maps more readable,
;; but they are not required. 

(= __ ((hash-map :a 10, :b 20, :c 30) :b))

(= __ (:b {:a 10, :b 20, :c 30}))
#+END_SRC

** solutions
Solutions:

20

* 11 conj-ing to a map

#+BEGIN_SRC clojure
;; When operating on a map, the conj function returns a new map with
;; one or more key-value pairs "added". Use M-x 4clojure-check-answers
;; when you're done!

(= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
#+END_SRC

** solutions

Solutions:

{:b 2}
0x89's solution:
#+BEGIN_SRC clojure

[:b 2]
#+END_SRC]]
* 12 "All Clojure collections support sequencing"

#+BEGIN_SRC clojure
;; All Clojure collections support sequencing. You can operate on
;; sequences with functions like first, second, and last. 

(= __ (first '(3 2 1)))

(= __ (second [2 3 4]))

(= __ (last (list 1 2 3)))
#+END_SRC

** solutions

Solutions:

3

* 13 rest fn of on a sequence

#+BEGIN_SRC clojure
;; The rest function will return all the items of a sequence except
;; the first. Use M-x 4clojure-check-answers when you're done!

(= __ (rest [10 20 30 40]))
#+END_SRC

** solutions



Solutions:

[20 30 40]

* 14 named, unnamed, literal and partial functions

#+BEGIN_SRC clojure
;; Clojure has many different ways to create functions. 

(= __ ((fn add-five [x] (+ x 5)) 3))

(= __ ((fn [x] (+ x 5)) 3))

(= __ (#(+ % 5) 3))

(= __ ((partial + 5) 3))
#+END_SRC

** solutions

Solutions:

8

* 15 function creation (doubler)

#+BEGIN_SRC clojure
;; Write a function which doubles a number. 

(= (__ 2) 4)

(= (__ 3) 6)

(= (__ 11) 22)

(= (__ 7) 14)
#+END_SRC

** solutions

#(* % 2)

------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [x] (* x 2))
#+END_SRC

------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#(* % 2)
------------------------------------------------------------------------------------------------
#+END_SRC
foantell's solution:
#+BEGIN_SRC clojure
(fn [x] (* x 2))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
\*
#+END_SRC 2
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
\*
#+END_SRC 2
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(partial * 2)
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(* 2 %)
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [n] (+ n n))
#+END_SRC

* 16 function creation (string greeter)

#+BEGIN_SRC clojure
;; Write a function which returns a personalized greeting. 

(= (__ "Dave") "Hello, Dave!")

(= (__ "Jenn") "Hello, Jenn!")

(= (__ "Rhea") "Hello, Rhea!")
#+END_SRC

** solutions

#(str "Hello," " " % "!")

0x89's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % \!)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [n] (str "Hello, " n "!"))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % \!)
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % \!)
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % "!" )
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [string] (str "Hello, " string "!"))
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % "!")
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [s] (str "Hello, " s "!"))
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % "!")
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % "!")
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(partial format "Hello, %s!")
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(str "Hello, " % "!")
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [n] (str "Hello, " n "!"))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [name]
  (str "Hello, " name "!"))
#+END_SRC

* 17 map-ing a function over a sequence

#+BEGIN_SRC clojure
;; The map function takes two arguments: a function (f) and a sequence
;; (s). Map returns a new sequence consisting of the result of
;; applying f to each item of s. Do not confuse the map function with
;; the map data structure. 

(= __ (map #(+ % 5) '(1 2 3)))
#+END_SRC

** solutions



Solutions:

'(6 7 8)
0x89's solution:
#+BEGIN_SRC clojure
#+END_SRC

* 18 filter-ing a sequence with a predicate function
 4Clojure Question 18

#+BEGIN_SRC clojure
;; The filter function takes two arguments: a predicate function (f)
;; and a sequence (s). Filter returns a new sequence consisting of all
;; the items of s for which (f item) returns true. 

(= __ (filter #(> % 5) '(3 4 5 6 7)))
#+END_SRC

** solutions



Solutions:

'(6 7)
0x89's solution:
#+BEGIN_SRC clojure
[6 7]
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
'(6 7)
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
[6 7]
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
[6 7]
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
'(6 7)
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
'(6 7)
#+END_SRC

* 19 function creation (my-last)

#+BEGIN_SRC clojure
;; Write a function which returns the last element in a sequence.
;; Restrictions (please don't use these function(s)): last 

(= (__ [1 2 3 4 5]) 5)

(= (__ '(5 4 3)) 3)

(= (__ ["b" "c" "d"]) "d")
#+END_SRC

** solutions

(fn [x] (first (reverse x)))

0x89's solution:
#+BEGIN_SRC clojure
(comp first reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [x] (first (reverse x)))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
(comp peek vec)
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(first (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [[x & more]]
  (if more
    (recur more)
    x))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [coll]
  (loop [remaining coll]
    (let [[head & rest] remaining]
    (if (empty? rest)
      head
      (recur rest)))))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(fn [s]
        (if (next s)
          (recur (next s))
          (first s)))
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(comp first reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(comp first reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [coll] (first (reverse coll)) )
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(first (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(comp first reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [ aseq ](first (reverse aseq)))
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(first (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(if (next %) (recur (next %)) (first %))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [coll] (first (reverse coll)))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(reduce (fn [a b] b) %)
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(nth % (dec (count %)))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(comp first reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [in]
  (if-let [r (next in)]
    (recur r)
    (first in)))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [lst]
  (reduce (fn [a b] b) nil lst))
#+END_SRC

* 20 function creation (second-to-last)

#+BEGIN_SRC clojure
;; Write a function which returns the second to last element from a
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= (__ (list 1 2 3 4 5)) 4)

(= (__ ["a" "b" "c"]) "b")

(= (__ [[1 2] [3 4]]) [1 2])
#+END_SRC

** solutions
#(first (rest (reverse %)))
0x89's solution:
#+BEGIN_SRC clojure
(comp peek pop vec)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [x] (first (rest (reverse x))))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(-> % vec pop peek)
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(nth (reverse %) 1)
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(comp second reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [coll]
  (loop [remaining coll]
    (let [[head & rest] remaining]
    (if (= 1 (count rest))
      head
      (recur rest)))))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(comp first next reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(comp second reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(comp first rest reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [x] (first (rest (reverse x))))
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(comp first rest reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(comp second reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [ aseq ](second (reverse aseq)))
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(last (butlast %))
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
(comp first last #(partition 2 1 %))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(second (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(first (drop 1 (reverse %)))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(nth % (dec (dec (count %))))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(comp second reverse)
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [[pu l & more :as in]]
  (if more
    (recur (next in))
    pu))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
#_
#+END_SRC(blech fn [lst]
  (loop [f (first lst)
         l (rest lst)]
    (if (< 1 (count l))
        (recur (first l) (rest l))
        f)))

(comp fnext reverse)

* 21 function creation (my-nth)

#+BEGIN_SRC clojure
;; Write a function which returns the Nth element from a sequence.
;; Restrictions (lpease don't use these function(s)): nth 
(= (__ '(4 5 6 7) 2) 6)

(= (__ [:a :b :c] 0) :a)

(= (__ [1 2 3 4] 1) 2)

(= (__ '([1 2] [3 4] [5 6]) 2) [5 6])
#+END_SRC

** solutions
(fn my-nth [lat n] 
  (cond (= n 0) (first lat)
      :else (my-nth (rest lat) (dec n))))

0x89's solution:
#+BEGIN_SRC clojure
#(first (drop %2 %))
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn self [xs i] (cond (= i 0) (first xs) true (self (rest xs) (- i 1))))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(first (drop %2 %))
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#((vec %) %2)
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [as pos]
(last (take (+ pos 1) as)))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [seq pos]
  (last (take (+ pos 1) seq)))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#((vec %1) %2)
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
#(first(drop %2 %1)
<sclojure)
------------------------------------------------------------------------------------------------

(fn [s n]
  (first (drop n s)))
austintaylor's solution:
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [coll n] 
  (if (= n 0)
    (first coll)
    (recur (rest coll) (dec n))
  )
)
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(last (take (+ %2 1) %1))
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(first (drop %2 %1))
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [s i] (if (= i 0) (first s) (recur (rest s) (- i 1))))
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(first (drop %2 %1))
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(first (drop %2 %))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(loop [count %2, coll %1]
  (if (zero? count) (first coll)
   (recur (dec count) (next coll))))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(first (drop %2 %1))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(loop [coll %1
        idx 0]
   (if (= idx %2)
     (first coll)
     (recur (rest coll) (inc idx))))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(comp first nthrest)
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [s n]
  (if (zero? n)
(first s)
(recur (next s) (dec n))))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [lst n]
  (loop [n n
         el (first lst)
         l (rest lst)]
    (if (zero? n)
        el
        (recur (dec n) (first l) (rest l)))))
#+END_SRC

* 22 function creation (my-count)

#+BEGIN_SRC clojure
;; Write a function which returns the total number of elements in a
;; sequence. Restrictions (please don't use these function(s)): count
;; Use M-x 4clojure-check-answers when you're done!

(= (__ '(1 2 3 3 1)) 5)

(= (__ "Hello World") 11)

(= (__ [[1 2] [3 4] [5 6]]) 3)

(= (__ '(13)) 1)

(= (__ '(:a :b :c)) 3)
#+END_SRC

** solutions

(fn size [lst]
  (if (empty? lst)
    0
    (inc (size (rest lst)))))

0x89's solution:
#+BEGIN_SRC clojure
#(reduce (fn [x _] (+ 1 x)) 0 %)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC (fn [m i] (+ m 1)) 0
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC (fn [c _] (+ c 1)) 0
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(-> (map-indexed list %) last first inc)
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x] 
  (loop [ans 0
         lst x]
    (if (empty? lst)
      ans
      (recur (inc ans) (rest lst)))))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [seq]
  (->> (map (fn [x] 1) seq)
       (reduce +)))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(comp (partial apply +) (partial map #(do % 1)))
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [sequence] (reduce (fn [acc v] (inc acc)) 0 sequence))
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [s]
  (reduce + (map (constantly 1) s)))
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [xs] (reduce + (map (fn [x] 1) xs) ) )
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(loop [s % n 0]
  (if (empty? s)
    n
    (recur (rest s) (inc n))
    )
  )
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(partial reduce (fn[x y] (inc x)) 0)
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(partial (fn [i s] (if (empty? s) i (recur (+ i 1) (rest s)))) 0)
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(reduce (fn [tot _] (inc tot)) 0 %)
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(-> % (interleave (range)) last inc)
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(reduce + (map (fn [_] 1) %))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(reduce + (map (fn [x] 1) %))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(fn [s] 
  (loop [idx 0]
    (if (= :not-found (nth s idx :not-found))
      idx
      (recur (inc idx)))))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC (fn [x _] (inc x)) 0
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [in]
  (reduce (fn [c _] (inc c)) 0  in))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [lst]
  (reduce + (map (constantly 1) lst)))
#+END_SRC

* 23 function creation (my-reverse)

#+BEGIN_SRC clojure
;; Write a function which reverses a sequence. Restrictions (please
;; don't use these function(s)): reverse, rseq 

(= (__ [1 2 3 4 5]) [5 4 3 2 1])

(= (__ (sorted-set 5 7 2 7)) '(7 5 2))

(= (__ [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]])
#+END_SRC

** solutions

#+BEGIN_SRC clojure
(fn my-reverse [lst]
  (cond (empty? lst)()
        :else (cons (last lst)
                    (my-reverse (butlast lst)))))
#+END_SRC

0x89's solution:
#+BEGIN_SRC clojure
#(into () %)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC #(conj %1 %2) '()
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
into
#+END_SRC ()
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
into
#+END_SRC ()
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC #(cons %2 %1) []
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(into '() %)
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#(map (vec %) (range (dec (count %)) -1 -1))
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [s]
  (loop [result []
         s s]
    (if (seq s)
      (recur (concat [(first s)] result) (rest s))
      result)))
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [s]
  (reduce conj '() s))
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [xs]
  (reduce 
    (fn [first second] (cons second first))
    nil
    xs
  )
)
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(loop [n (count %) ret [] res %]
  (if (zero? n)
    ret 
    (recur (dec n) (conj ret (last res)) (take (- n 1) res)))
)
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
apply
#+END_SRC (partial conj ())
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(partial (fn [rs is] (if (empty? is) rs (recur (conj rs (first is)) (rest is)))) ())
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(reduce conj () %)
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
into
#+END_SRC '()
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(loop [coll % v ()]
              (if coll (recur (next coll) (conj v (first coll)))
                v))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(reduce conj '() %)
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(fn [s] 
  (loop [idx (dec (count s))
         ret []]
    (if (not (neg? idx))
      (recur (dec idx) (conj ret (nth (vec s) idx)))
      ret)))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(reduce conj () %)
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
into
#+END_SRC '()
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [lst]
  (reduce conj '() lst))
#+END_SRC

* 24 function creation (add all numbers in a sequence)

#+BEGIN_SRC clojure;; Write a function which returns the sum of a sequence of numbers.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3]) 6)

(= (__ (list 0 -2 5 5)) 8)

(= (__ #{4 2 1}) 7)

(= (__ '(0 0 -1)) -1)

(= (__ '(1 10 3)) 14)
#+END_SRC

** solutions



Solutions:

reduce +
0x89's solution:
#+BEGIN_SRC clojure
#(apply + %)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
apply
#+END_SRC +
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
apply
#+END_SRC +
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(apply + %)
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC + 0
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(reduce + %1)
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
apply
#+END_SRC +
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
apply
#+END_SRC +
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC +
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC +
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
apply
#+END_SRC +
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC +
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC +
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(apply + %)
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC +
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(reduce + %)
#+END_SRC

* 25 function creation (filter out even numbers)

#+BEGIN_SRC clojure
;; Write a function which returns only the odd numbers from a
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= (__ #{1 2 3 4 5}) '(1 3 5))

(= (__ [4 2 1 6]) '(1))

(= (__ [2 2 4 6]) '())

(= (__ [1 1 1 3]) '(1 1 1 3))
#+END_SRC

** solutions

(fn build-odd [lst]
  (cond (empty? lst) ()
        (= 1 (mod (first lst) 2)) (cons (first lst) (build-odd (rest lst)))
        :else (build-odd (rest lst))))

0x89's solution:
#+BEGIN_SRC clojure
#(filter odd? %)
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC #(= 1 (mod % 2))
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC odd?
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(filter odd? %)
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC odd?
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC odd?
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC #(== (mod % 2) 1)
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC (fn [x] (= 1 (rem x 2)))
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC odd?
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC odd?
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC (fn [x] (= 1 (mod x 2)))
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(filter odd? %)
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(for [x % :when (odd? x)] x)
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(filter odd? %)
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC #(= 1 (rem % 2))
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
filter
#+END_SRC #(= 1 (rem % 2))

* 26 function creation (return n Fibonacci numbers)

#+BEGIN_SRC clojure
;; Write a function which returns the first X fibonacci numbers. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ 3) '(1 1 2))

(= (__ 6) '(1 1 2 3 5 8))

(= (__ 8) '(1 1 2 3 5 8 13 21))
#+END_SRC

** solutions
(fn fibs [x]
   (cond (= x 2) '(1 1)
         :else ((fn [x y] 
                  	(reverse (cons x (reverse y))))
                (+ (last (fibs (dec x)))
                   (last (butlast (fibs (dec x)))))
		(fibs (dec x)))))

0x89's solution:
#+BEGIN_SRC clojure
(fn* [p1__2673#] (take p1__2673# ((fn fibs [] (lazy-cat [1 1] (map + (fibs) (rest (fibs))))))))
#+END_SRC
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [i] (take i '(1 1 2 3 5 8 13 21)))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(letfn [(f [a b] (lazy-seq (cons a (f b (+ a b)))))]
    (take % (f 1 1)))
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(take %
   (concat [1 1]
     ((fn f [i j] (lazy-cat [(+ i j)] (f j (+ i j)))) 1 1)))
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x] 
  (loop [l 1
         c 1
   	     total_length (- x 2)
         result [1 1]]
    (if (= total_length 0)
      result
      (recur c (+ c l) (- total_length 1) (conj result (+ c l))))))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(take % (map first (iterate (fn [[x y]]
                        [y (+ x y)]) [1 1])))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#((apply comp (repeat (- % 2) (fn [x] (conj x (+ (peek x) (peek (pop x))))))) [1 1])
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
#(take %
  (map first
    (iterate (fn [[i1 i2]]
      [i2 (+ i1 i2)])
      [1 1])))
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [n]
  (map first (reductions
    (fn [[a b] _] [b (+ a b)]) [1 1] (range 1 n))))
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [n]   
 (reverse ((fn  [x coll] 
   (cond
     (= x 0) coll
     true (recur 
       (dec x)
       (cons 
         (+ (first coll) (first (rest coll)))
         coll
       )
     )
   )
 ) (- n 2) (list 1 1) )
))
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(take % (map first (iterate (fn [[a b]] [b (+ a b)]) [1 1])))
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(take % (map first (iterate (fn [[a b]] [b (+ a b)]) [1 1])))
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [ n ] 
    (take n ((fn fibonacci 
                ([] (cons 1 (lazy-seq (fibonacci 0 1))))
                ([a b] (cons (+ a b) (lazy-seq (fibonacci b (+ a b))))))))
)
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(take % (list* 1 (map first
    (iterate (fn [[m n]] [(+ m n) m]) [1 1]))))
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(take % (map first (iterate (fn [x] (list (second x) (+ (first x) (second x)))) '(1 1))))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(take % (drop 1 (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1]))))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(reduce (fn [a b] 
            (conj a (+ (nth a (- (count a) 2)) (last a)))) [1 1] (range (- % 2)))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(fn [n]
  (map first (take n (iterate (fn [v] [(apply + v) (first v)]) [1 0]))))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(take % ((fn fib [a b] (cons a (lazy-seq (fib b (+ a b))))) 1 1))
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [n]
    (take n (map first (iterate (fn [[l r]]
                                  [r (+ l r)])
                                [1 1]))))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [n]
  (loop [a 1
         b 1
         l [a b]
         n (- n 2)]
    (if (pos? n)
      (recur b (+ a b) (conj l (+ a b)) (dec n))
      l)))
#+END_SRC

* 27 function creation (palindrome?)

#+BEGIN_SRC clojure
;; Write a function which returns true if the given sequence is a
;; palindrome.<br/><br> Hint: "racecar" does not equal '(\r \a \c \e
;; \c \a \r) Use M-x 4clojure-check-answers when you're done!

(false? (__ '(1 2 3 4 5)))

(true? (__ "racecar"))

(true? (__ [:foo :bar :foo]))

(true? (__ '(1 1 3 3 1 1)))

(false? (__ '(:a :b :c)))
#+END_SRC

** solutions
(fn palin [lst] 
   (if 
     (string? lst)
     (cond 
      (= lst (clojure.string/join (reverse lst))) true
      :else false)
     (cond 
      (= lst (reverse lst)) true
      :else false)))

------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [xs] (= (map identity xs) (reverse xs)))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(= (seq %) (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(= (seq %) (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#( if (string? %)
    (= (str %) (reduce str (reverse %)))
    (= % (reverse %)))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(= (seq %) (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#(= (reverse %) (seq %))
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
#(= (reverse %) (seq %))
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
#(= (reverse %) (seq %))
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn palindrome [xs]
  ((fn helper [ys zs]
    (cond
      (and (empty? ys) (empty? zs)) true
      (or (empty? ys) (empty? zs)) false
      (= (first ys) (first zs)) (helper (rest ys) (rest zs))
      true false
    )
  )  xs (reverse xs) )
)
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(= (apply str (reverse %)) (apply str %))
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(= (apply str (reverse
#+END_SRC %)) (apply str %))
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [x] (= (reverse x) (seq x)))
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(= (seq %) (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(= (seq %) (reverse %))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(= (seq %) (reverse (seq %)))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s] 
  (let [v (vec s)] 
    (let [l (int (/ (count v) 2))] 
      (= (take l v) (reverse (take-last l v))))))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(fn [s]
  (let [s (vec s)]
  	(= (reverse s) s)))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(= (reverse %) (seq %))
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [in] (= (seq in) (reverse in)))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [lst]
  (loop [l (seq lst)]
    (cond
      (= (last l) (first l))
        (if (< 1 (count l))
          (recur (drop 1 (butlast l)))
          true)
      :else false)))
#+END_SRC

* 28 function creation (flattens a sequence)

#+BEGIN_SRC clojure
;; Write a function which flattens a sequence. Restrictions (please
;; don't use these function(s)): flatten 

(= (__ '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6))

(= (__ ["a" ["b"] "c"]) '("a" "b" "c"))

(= (__ '((((:a))))) '(:a))
#+END_SRC

** solutions



Solutions:

(fn [lst] (filter (complement sequential?)
          	(rest (tree-seq sequential? seq lst))))
0x89's solution:

Scored 118, before 4clojure started saving solutions.
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC
(fn self [xs e] (concat xs (cond (coll? e) (reduce self '() e) true (list e))))
'()
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(remove % (tree-seq % seq %2))
#+END_SRC sequential?
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
(fn f [r [a & b]]
  (if a
    (if (coll? a)
      (f (into r (f [] a)) b)
      (f (into r [a]) b))
    r)
#+END_SRC)
[]
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#(filter (complement sequential?)
   (rest (tree-seq sequential? seq %)))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [coll] 
  (filter (complement sequential?)
          (rest (tree-seq sequential? identity coll))))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [s]
  (loop [s s]
    (if (some sequential? s)
      (recur (reduce (fn [acc v]
                (if (sequential? v)
                  (concat acc v)
                  (concat acc [v])
                  ))
              []
              s))
      s)
    )
#+END_SRC
)
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [s]
  (filter (complement sequential?)
    (tree-seq sequential? seq s)))
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn fake [xs]
  (cond
    (empty? xs)
      (list )
    (or (list? (first xs)) (vector? (first xs)))
      (concat (fake (first xs)) (fake (rest xs)))
    true
      (concat (list (first xs)) (fake (rest xs)))
  )
)
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(fn fla [x]
  (if (coll? x)
    (when (seq x) (concat (fla (first x)) (fla (rest x))))
    [x])
  )
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(fn [a] (loop [t a]  
           (if (empty? (for [x t :when (coll? x)] x))
            t
            (recur (reduce concat (for [x t] (if(coll? x) x (list x)))))
           )
         )
)
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn my-flatten
    [ r s ]
#+END_SRC
    (if (not (or (list? s) (vector? s)))
        (conj r s)
        (reduce my-flatten r (reverse s)))) ()
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
(letfn [
  (myflatten [coll]
    (mapcat #(if (coll? %) (myflatten %) [%]) coll)
  )]
  #(myflatten %))
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(filter (complement sequential?) (tree-seq sequential? identity %))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [coll]
    (letfn [(f [coll]
              (loop [coll coll
                     answer []]
                (cond
                 (nil? coll) answer
                 (seq? (first coll)) (recur (next coll) (vec (concat (f (first coll)) answer)))
                 (vector? (first coll)) (recur (next coll) (vec (concat answer (f (first coll)))))
                 :else (recur (next coll) (conj answer (first coll))))))]
      (f coll)))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s]
  (loop [remaining s
         result []]
    (if (empty? remaining)
      result
      (let [x (first remaining)]
        (if (sequential? x)
          (recur (concat x (rest remaining)) result)
          (recur (rest remaining) (conj result x)))))))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(some (fn [s] (if (not-any? coll? s) s false)) (iterate 
                                (fn [s] 
                                  (loop [ret []
                                         tmp s]
                            		(if (empty? tmp)
                                      ret
                                      (recur (if (coll? (first tmp)) 
                                                (into ret (first tmp))
                                                (conj ret (first tmp)) )
                                             (rest tmp))))) 
                                %))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(fn flat [x]
   (mapcat 
    #(if (coll? %)
       (flat %)
       (list %))
    x))
#+END_SRC
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn fl [in]
  (mapcat (fn [item]
    (if (sequential? item)
(fl (seq item))
[item])) in))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [l]
  (loop [q l
         acc []]
    (if (empty? q)
      acc
      (let [f (first q)
            r (rest q)]
        (if (sequential? f)
          (recur (concat f r) acc)
          (recur r (conj acc f))))))
#+END_SRC)

* 29 function creation (takes a string and returns a new string)

#+BEGIN_SRC clojure
;; Write a function which takes a string and returns a new string
;; containing only the capital letters. Use M-x 4clojure-check-answers
;; when you're done!

(= (__ "HeLlO, WoRlD!") "HLOWRD")

(empty? (__ "nothing"))

(= (__ "$#A(*&987Zf") "AZ")
#+END_SRC

** solutions



Solutions:

(fn [x] (apply str (re-seq #"[A-Z]" x)))
0x89's solution:

Scored 115, before 4clojure started saving solutions.
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [s] (apply str (filter #(not= (.toLowerCase (str %)) (str %)) s)))
#+END_SRC
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(apply str (filter (fn [c] (< 64 (int c) 91)) %))
#+END_SRC
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(apply str (re-seq #"[A-Z]" %))
#+END_SRC
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x] 
     (loop [lst (re-seq #"[A-Z]" x)
            ans ""] 
        (if (empty? lst)
          ans
          (recur (rest lst) (str ans (first lst))))))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(apply str (re-seq #"[A-Z]" %))
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#(clojure.string/replace % #"[^A-Z]" "")
#+END_SRC
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [s] (reduce str (filter #(Character/isUpperCase %) s)))
#+END_SRC
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
#(apply str (re-seq #"[A-Z]" %))
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [x] (.replaceAll x "[^A-Z]" "") )
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(apply str (clojure.string/split % #"[^A-Z]"))
#+END_SRC
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(apply str (re-seq #"[A-Z]+" %))
#+END_SRC
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [s] (reduce str (re-seq #"[A-Z]" s)))
#+END_SRC
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(clojure.string/replace % #"[^A-Z]+" "")
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(reduce str (re-seq #"[A-Z]" %))
#+END_SRC
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [s]
    (apply str (for [c s :when (Character/isUpperCase c)] c)))
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s]
  (apply str (re-seq #"[A-Z]" s)))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(fn [s] (apply str (filter #(<= 65 (int %) 90) s)))
#+END_SRC
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(apply str (re-seq #"[A-Z]"
#+END_SRC %))
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
#(apply str (filter (fn [c] (Character/isUpperCase c)) %))
#+END_SRC
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
#(apply str (re-seq #"[A-Z]" %))
#+END_SRC

* 30 function creation (removes consecutive duplicates from a)

#+BEGIN_SRC clojure
;; Write a function which removes consecutive duplicates from a
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= (apply str (__ "Leeeeeerrroyyy")) "Leroy")

(= (__ [1 1 2 3 3 2 2 3]) '(1 2 3 2 3))

(= (__ [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2]))
#+END_SRC

** solutions



Solutions:

partition-by (fn [x] x)

0x89's solution: 

Scored 29, before 4clojure started saving solutions.
------------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC str
------------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x] (reverse 
                (reduce #(if (= (first (first %1)) %2)
                            (conj  (rest %) (cons %2 (first %)))
                            (conj % (list %2))) () x)))
#+END_SRC
------------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(partition-by identity %)
#+END_SRC
------------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(partial partition-by identity)
#+END_SRC
------------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn pack [xs]
   (reverse ((fn helper [xs last accu]
     (cond
      (empty? xs) (cons last accu)
      (= (first xs) (first last)) 
        (recur (rest xs) (cons (first xs) last) accu)
      :else 
        (recur (rest xs) (list (first xs)) (cons last accu))))
    (rest xs) (list (first xs)) nil)))
#+END_SRC
------------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(partition-by identity %)
#+END_SRC
------------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(partition-by identity %)
#+END_SRC
------------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s]
  (reduce 
    (fn [a b] 
      (if (= (last (last a)) b) 
        (conj (subvec a 0 (dec (count a))) (conj (last a) b))
        (conj a [b]))) [] s))
#+END_SRC
------------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
------------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
#(partition-by identity %)
#+END_SRC

* 31 function creation (packs consecutive duplicates into sub-lists)

#+BEGIN_SRC clojure
;; Write a function which packs consecutive duplicates into sub-lists.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ [1 1 2 1 1 1 3 3]) '((1 1) (2) (1 1 1) (3 3)))

(= (__ [:a :a :b :b :c]) '((:a :a) (:b :b) (:c)))

(= (__ [[1 2] [1 2] [3 4]]) '(([1 2] [1 2]) ([3 4])))
#+END_SRC

** solutions
Solutions:

partition-by (fn [x] x)
0x89's solution:

Scored 29, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC str
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x] (reverse 
                (reduce #(if (= (first (first %1)) %2)
                            (conj  (rest %) (cons %2 (first %)))
                            (conj % (list %2))) () x)))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(partition-by identity %)
#+END_SRC
----------------------------------------------------------------------------------------------


austintaylor's solution:
#+BEGIN_SRC clojure
(partial partition-by identity)
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn pack [xs]
   (reverse ((fn helper [xs last accu]
     (cond
      (empty? xs) (cons last accu)
      (= (first xs) (first last)) 
        (recur (rest xs) (cons (first xs) last) accu)
      :else 
        (recur (rest xs) (list (first xs)) (cons last accu))))
    (rest xs) (list (first xs)) nil)))
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
partition-by
#+END_SRC identity

----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s]
  (reduce 
    (fn [a b] 
      (if (= (last (last a)) b) 
        (conj (subvec a 0 (dec (count a))) (conj (last a) b))
        (conj a [b]))) [] s)
#+END_SRC)

* 32 function creation (duplicates each element of a sequence)

#+BEGIN_SRC clojure
;; Write a function which duplicates each element of a sequence. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3]) '(1 1 2 2 3 3))

(= (__ [:a :a :b :b]) '(:a :a :a :a :b :b :b :b))

(= (__ [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))

(= (__ [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))
#+END_SRC

** Solutions
Account SettingsLeaguesSubmit a Problem

Solutions:

(fn dupps [lst]
   (cond (empty? lst) ()
         :else (cons (first lst)
                     (cons (first lst)
                           (dupps (rest lst))))))
0x89's solution:

Scored 43, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC #(conj %1 %2 %2) []
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC #(list % %)
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(mapcat list % %)
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#(reduce (fn [lst x] (concat lst [x x])) [] %)
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(interleave % %)
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC #(list % %)
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [s] (loop [s s r '()]
          (if (seq s)
            (recur (rest s) (concat r [(first s) 
                                       (first s)]))
                                    
            r)
          )
  )
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
#(interleave % %)
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC (fn [x] (list x x))
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(interleave % %)
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC (partial repeat 2)
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
reduce
#+END_SRC (fn [l x] (concat l (list x x))) ()
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [x] [x x]) %)
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(interleave % %)
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [coll]
    (mapcat #(list % %) coll))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
#(reduce (fn [a b] (conj a b b)) [] %)
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(reduce 
   into
   (for [x %]
     [x x]))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(interleave % %)
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(partial mapcat (juxt identity identity))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [a] (list a a)) %)
#+END_SRC
* 33 function creation (replicates each element of a sequence)

#+BEGIN_SRC clojure
;; Write a function which replicates each element of a sequence a
;; variable number of times. 

(= (__ [1 2 3] 2) '(1 1 2 2 3 3))

(= (__ [:a :b] 4) '(:a :a :a :a :b :b :b :b))

(= (__ [4 5 6] 1) '(4 5 6))

(= (__ [[1 2] [3 4]] 2) '([1 2] [1 2] [3 4] [3 4]))

(= (__ [44 33] 2) [44 44 33 33])
#+END_SRC

** Solutions

Solutions:

(fn [lst n] 
  (if (> n 1) 
    (apply interleave (take n (repeat lst)))
  	lst))
0x89's solution:

Scored 44, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [xs i] (reduce #(concat %1 (replicate i %2)) [] xs))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(mapcat (partial repeat %2) %)
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(apply mapcat list (repeat %2 %))
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [lst n] (mapcat (fn [x] (repeat n x)) lst))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [x] (repeat %2 x)) %)
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(fn [x t] (mapcat (partial repeat t) x))
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [s n]
  (if (= n 1) s
  	(apply interleave (repeat n s))))
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [s n]
  (mapcat (partial repeat n) s))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [x] (repeat %2 x)) %)
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(mapcat (partial repeat %2) %)
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(fn [x n] (mapcat (partial
#+END_SRC repeat n) x))
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [l n](mapcat #(apply conj [] (repeat n %1)) l))
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [x] (repeat %2 x)) %1)
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [x] (repeat %2 x)) %1)
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [coll n]
    (mapcat #(repeat n %) coll))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s n]
  (for [x s i (range n)]
    x))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(apply concat (for [x %1]
   (repeat %2 x)))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(mapcat (partial repeat %2) %1)
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [items nrepeat]
  (mapcat (partial repeat nrepeat) items))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [lst n]
  (mapcat #(repeat n %) lst))
#+END_SRC

* 34 function creation (creates a list of all integers in a given...)

#+BEGIN_SRC clojure
;; Write a function which creates a list of all integers in a given
;; range. Restrictions (please don't use these function(s)): range Use
;; M-x 4clojure-check-answers when you're done!

(= (__ 1 4) '(1 2 3))

(= (__ -2 2) '(-2 -1 0 1))

(= (__ 5 8) '(5 6 7))
#+END_SRC

** Solutions

Solutions:

(fn rng [x y]
	  (cond (= x y) ()
    	    :else (cons x (rng (inc x) y))))
0x89's solution:

Scored 52, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [s e] (reduce #(conj %1 (+ s (count %1) %2)) [] (replicate (- e s) 0)))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(take (- %2 %) (iterate inc %))
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(take (- %2 %) (iterate inc %))
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x y]
   (loop [ans [x]
          x (inc x)]
     (if (< (first ans) (dec y))
       (recur (cons x ans) (inc x))
       (reverse ans))))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(take (- %2 %) (iterate inc %))
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(fn [s t] (reductions + (merge (repeat (dec (- t s)) 1) s)))
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [start end] (take-while #(< % end)
                            (iterate inc start)
                            )
  )
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [a b]
  (map-indexed + (repeat (- b a) a)))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn bob [min max]
  (if (>= min max) 
    nil
    (cons min (bob (inc min) max)
    )
  )
)
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(take (- %2 %1) (iterate (fn [x] (+ x 1)) %1))
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(reduce (fn [a b] (conj a (+ b (count a)))) [] (repeat (- %2 %1) %1))
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [b e] (take-while (partial > e) (iterate inc b)))
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(take-while (fn [x] (< x %2)) (iterate inc %1))
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(take (- %2 %) (iterate inc %))
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [start stop]
    (take (- stop start) (iterate inc start)))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [a b]
  (loop [x a r []]
    (if (< x b)
      (recur (inc x) (conj r x))
      r)))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(take (- %2 %1) (iterate inc %1))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(fn [a b] (take (- b a) (iterate #(inc %) a)))
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [lo up]
  (take-while #(< % up) (iterate inc lo)))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [low high]
  (loop [acc []
         n low]
    (if (= n high)
      acc
      (recur (conj acc n) (inc n)))))
#+END_SRC

* 35 let-ing local variables

#+BEGIN_SRC clojure
;; Clojure lets you give local names to values using the special
;; let-form. Use M-x 4clojure-check-answers when you're done!

(= __ (let [x 5] (+ 2 x)))

(= __ (let [x 3, y 10] (- y x)))

(= __ (let [x 21] (let [y 3] (/ x y))))
#+END_SRC

** Solutions

Solutions:

7
0x89's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
7
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
7
#+END_SRC

* 36 let-ing for correct arithmetic

#+BEGIN_SRC clojure
;; Can you bind x, y, and z so that these are all true? 

(= 10 (let __ (+ x y)))

(= 4 (let __ (+ y z)))

(= 1 (let __ z))
#+END_SRC

** Solutions

Solutions:

[z 1
 y 3
 x 7]
0x89's solution:
#+BEGIN_SRC clojure
[z 1
 y 3
 x 7]
#+END_SRC
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
[x 7, y 3, z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
[x 7
 y
#+END_SRC 3
 z 1]
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
[z 1 
 y 3 
 x 7]
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
[z 1 y 3 x 7]
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
[z 1 y 3 x 7]
----------------------------------------------------------------------------------------------
#+END_SRC
austintaylor's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
[z 1 y 3 x 7]
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
[x 7, y 3, z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
[ x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
[x 7, y 3, z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
[ x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
[z 1 y 3 x 7]
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
[z 1 y (- 4 z) x (- 10 y)]
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
[x 7 y 3 z 1]
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
[z 1 y 3 x 7]
#+END_SRC

* 37 re-seq and regex syntax

#+BEGIN_SRC clojure
;; Regex patterns are supported with a special reader macro. 

(= __ (apply str (re-seq #"[A-Z]+" "bA1B3Ce ")))
#+END_SRC

** Solutions

Solutions:

"ABC"
0x89's solution:
#+BEGIN_SRC clojure
"ABC"
----------------------------------------------------------------------------------------------
#+END_SRC
_pcl's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
"ABC"
#+END_SRC

* 38 function creation (takes a variable number of parameters)

#+BEGIN_SRC clojure
;; Write a function which takes a variable number of parameters and
;; returns the maximum value. Restrictions (please don't use these
;; function(s)): max, max-key 

(= (__ 1 8 3 4) 8)

(= (__ 30 20) 30)

(= (__ 45 67 11) 67)
#+END_SRC

** Solutions

Solutions:

(fn [& args]
	(first (sort > args)))
0x89's solution:

Scored 35, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [x & xs] (reduce #(if (> %2 %1) %2 %1) x xs))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(last (sort %&))
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(last (sort %&))
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn tess 
   ([x] x)
   ([x y] (if (> x y) x y))
   ([x y & more] (reduce tess (tess x y) more)))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [& args] (reduce #(if (> %1 %2) %1 %2) args))
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(comp - (partial apply min) (partial map -) list)
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [ & xs ]
  (reduce #(if (> %1 %2) %1 %2) xs))
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [& xs]
  (reduce #(if (> %2 %1) %2 %1) xs))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [& coll] 
  (reduce (fn [a b] (if (> a b) a b)) coll)
)
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(fn [& coll] (reduce #(if (> %1 %2) %1 %2) coll))
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(comp last sort list)
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [ & xs] (last (apply sorted-set xs)))
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
(comp (partial reduce #(if (>= %1 %2) %1 %2)) vector)
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(->> %& (reduce (fn [x y] (if (< x y) y x))))
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [& coll] (loop [c coll mx -99999]
                   (if c (recur (next c) (if (> (first c) mx) (first c)
                                             mx))
                       mx)))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [& s] 
  (reduce (fn [a b] (if (> a b) a b)) s))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
(fn [& args] (reduce #(if (> %1 %2) %1 %2) args))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(last (sort %&))
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [& args]
  (reduce (fn [a b] (if (< a b) b a)) args))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [& args]
  (reduce (fn [a b] (if (< a b) b a)) args))
#+END_SRC

* 39 function creation (takes two sequences and returns the first item from each)
#+begin_src clojure

#+END_SRC

#+BEGIN_SRC clojure
;; Write a function which takes two sequences and returns the first
;; item from each, then the second item from each, then the third,
;; etc. Restrictions (please don't use these function(s)): interleave
;; Use M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))

(= (__ [1 2] [3 4 5 6]) '(1 3 2 4))

(= (__ [1 2 3 4] [5]) [1 5])

(= (__ [30 20] [25 15]) [30 25 20 15])
#+END_SRC

** Solutions

Solutions:

mapcat #(vec [%1 %2])
0x89's solution:

Scored 42, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [xs ys]
    (reduce
      #(concat (rest %1) (list (first %1) %2))
      (take (count ys) xs)
      (take (count xs) ys)))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC list
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC list
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC (fn [x y] [x y])
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [coll1 coll2]
  (mapcat vector coll1 coll2))
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC #(list %1 %2)
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [s1 s2]
  (flatten (map list s1 s2)))
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [a0 b0]
  (loop [a a0 b b0 result '()]
    (if (and (seq a) (seq b))
      (recur
        (rest a)
        (rest b)
        (conj result (first a) (first b)))
      (reverse result))))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn [xs ys]
   (mapcat (fn [x y] (list x y)) xs ys)
 )
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(fn [c1 c2] (apply concat (map #(conj [] % %2) c1 c2)))
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC list
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC (fn [x y] [x y])
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(mapcat (fn [x y] [x y]) %1 %2)
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
(fn [l1 l2] (loop [c1 l1 c2 l2 res []]
              (cond (or (empty? c1) (empty? c2)) res 
                    :else (recur (rest c1) (rest c2) (conj (conj res (first c1)) (first c2))))))
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(comp flatten map)
#+END_SRC #(list %1 %2)
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [a b]
  (loop [x a
         y b
         result []]
    (let [v1 (first x)
          v2 (first y)]
      (if (and v1 v2)
        (recur (rest x) (rest y) (conj result v1 v2))
        result))))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC list
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC #(list %1 %2)
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
mapcat
#+END_SRC list
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [x y]
  (mapcat #(vector % %2) x y))
#+END_SRC

* 40 function creation (separates the items of a sequence by an arbitrary value)

#+BEGIN_SRC clojure
;; Write a function which separates the items of a sequence by an
;; arbitrary value. Restrictions (please don't use these function(s)):
;; interpose Use M-x 4clojure-check-answers when you're done!

(= (__ 0 [1 2 3]) [1 0 2 0 3])

(= (apply str (__ ", " ["one" "two" "three"])) "one, two, three")

(= (__ :z [:a :b :c :d]) [:a :z :b :z :c :z :d])
#+END_SRC

** Solutions

Solutions:

(fn [x lst] 
	 (butlast (mapcat  (fn [y] (vector y x))  lst)))
0x89's solution:

Scored 73, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [s xs] (drop-last (reduce #(concat %1 [%2 s]) [] xs)))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(rest (interleave (repeat %) %2))
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(butlast (mapcat (fn [i] [i %]) %2))
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
#(drop 1 (interleave (repeat %) %2))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
(fn [interposer coll]
  (butlast (mapcat (fn [x]
            [x interposer]) coll)))
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(fn [s x] (cons (first x) (mapcat #(list s %) (next x))))
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
#(butlast (interleave
#+END_SRC %2 (repeat %1)))
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [x s]
  (butlast (interleave s (repeat (count s) x))))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
#(into [] (drop-last 1 (mapcat (fn [x] (list x %)) %2)))
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(take (dec (* (count %2) 2)) (interleave %2 (repeat %)))
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(rest (mapcat (partial (fn [x y] (list x y)) %1) %2))
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
(fn [ v s ] (drop-last (mapcat (fn [x] [x v]) s)))
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(reduce (fn [v x] (conj v %1 x)) [(first %2)] (rest %2))
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(rest (mapcat (fn [x y] [y x]) %2 (repeat %)))
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [sep coll]
    (drop 1 (flatten (map #(list sep %) coll))))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [d s]
  (reduce (fn [a b] (conj a d b)) [(first s)] (rest s)))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(butlast (interleave %2 (repeat %1)))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(fn [s l] (rest (mapcat #(list s %) l)))
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [sep items] (rest (interleave (repeat sep) items)))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [sep xs]
  (loop [acc [(first xs)]
         left (rest xs)]
    (if (seq left)
      (recur (conj acc sep (first left)) (rest left))
      acc)))
#+END_SRC

* 41 function creation (drops every Nth item from a sequence)
;; Write a function which drops every Nth item from a sequence. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ [1 2 3 4 5 6 7 8] 3) [1 2 4 5 7 8])

(= (__ [:a :b :c :d :e :f] 2) [:a :c :e])

(= (__ [1 2 3 4 5 6] 4) [1 2 3 5 6])

** Solutions

Solutions:

#(mapcat (fn [lst]  
	     (if (= (count lst) %2)
	       (butlast lst)
	       lst))
	     (partition-all %2 %1))
0x89's solution:

Scored 70, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(fn [xs s]
  (map last
    (filter #(not= 0 (mod (first %1) s))
      (map-indexed #(list (+ 1 %1) %2) xs))))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(remove nil? (map-indexed (fn [i x] (if (= 0 (mod (inc i) %2)) nil x)) %))
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
(fn [c n]
  (mapcat #(take (dec n) %) (partition-all n c))
#+END_SRC)
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [coll pos] 
  (flatten (reduce (fn [coll x] (if (= (rem (inc (count coll)) pos) 0)
                   (conj coll '())
                   (conj coll x)))
          [] 
          coll)))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(apply concat (partition-all (dec %2) %2 %))
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
(fn [x s] (remove nil? (map #(if %2 %1 nil) x (cycle (concat (repeat (dec s) true) '(false))))))
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
(fn [coll n]
  (->> (partition-all n coll)
       (map (partial take (dec n)))
       (flatten)))
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [s x]
  (keep-indexed
    (fn [i a] (when (> (mod (inc i) x) 0) a))
    s))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
#(map first (filter (fn [pair] (not= 0 (mod (inc (last pair)) %2)))
           (map list % (range ))
 ))
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(fn [coll n]
  (loop [coll coll n n ret []]
    (if (empty? coll)
      ret
      (recur (drop n coll) n (into ret (take (dec n) coll))))))
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
(fn [c n] (mapcat identity (partition-all (dec n) n c)))
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
#(flatten (partition (- %2 1) %2 nil %1))
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(apply concat (partition-all (dec %2) %2 %1))
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(mapcat (partial take (dec %2)) (partition-all %2 %))
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
(fn [coll n]
    (loop [coll coll
           i 0
           answer []]
      (cond
       (nil? coll) answer
       (= (dec n) (mod i n)) (recur (next coll) (inc i) answer)
       :else (recur (next coll) (inc i) (conj answer (first coll))))))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [s n]
  (loop [remaining s
         result []]
    (if (empty? remaining)
      result
      (recur (drop n remaining) (concat result (take (dec n) remaining))))))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(mapcat (partial take (dec %2)) (partition-all %2 %1))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
(fn [s n] (keep-indexed #(if (< 0 (mod (inc %1) n)) %2) s))
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
(fn [col n]
  (->> col 
    (partition-all n)
    (mapcat (partial take (dec n)))))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn [list n]
  (loop [acc []
         i 1
         left list]
    (if (seq left)
      (recur (if (zero? (mod i n))
               acc
               (conj acc (first left)))
             (inc i)
             (rest left))
      acc))
#+END_SRC)

* 42 function creation (calculate factorials)
#+BEGIN_SRC clojure
;; Write a function which calculates factorials. 

(= (__ 1) 1)

(= (__ 3) 6)

(= (__ 5) 120)

(= (__ 8) 40320)
#+END_SRC


** Solutions

Solutions:

(fn [n]
  (reduce * (range 1 (inc n))))
0x89's solution:

Scored 30, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
((fn [r] 
  ((fn [f] (f f)) 
    (fn [y] 
      (r (fn [x] ((y y) x)))))) 
  (fn [fact] 
    (fn [n] 
      (if 
        (= 0 n) 1 
        (* n (fact (- n 1)))))))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
#(apply * % (range 2 %))
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
#(apply * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
(fn [x] 
  (loop [curr x
        total 1]
    (if (= curr 0)
      total
      (recur (dec curr) (* curr total)))))
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
#(reduce * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
#(reduce * (range % 0 -1))
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
#(reduce * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
(fn [x]
  (reduce * (range 1 (inc x))))
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(fn factorial [x]
  (if (= x 1) 
    1
    (* x (factorial (dec x)))
  )
)
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
#(apply * (range 2 (+ 1 %)))
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
#(reduce * (rest (range (inc %))))
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
#(apply * (map inc (range %1)))
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
#(apply * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
#(reduce * (map inc (range %)))
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
#(loop [cnt % acc 1]
     (if (or (zero? cnt) (== 1 cnt)) acc
         (recur (dec cnt) (* acc cnt))))
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
(fn [x]
  (loop [i 1 v 1]
    (if (<= i x)
      (recur (inc i) (* v i))
      v)))
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
#(reduce * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
#(reduce * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
#(reduce * (range 1 (inc %)))
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
(fn fac [x]
  (if (< x 2) x
    (* x (fac (dec x)))))
#+END_SRC

* 43 function creation (reverse interleave)

#+BEGIN_SRC clojure
;; Write a function which reverses the interleave process into x
;; number of subsequences. 

(= (__ [1 2 3 4 5 6] 2) '((1 3 5) (2 4 6)))

(= (__ (range 9) 3) '((0 3 6) (1 4 7) (2 5 8)))

(= (__ (range 10) 5) '((0 5) (1 6) (2 7) (3 8) (4 9)))

#+END_SRC
* 44 function creation (rotate sequences)

#+BEGIN_SRC clojure
;; Write a function which can rotate a sequence in either direction.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2 [1 2 3 4 5]) '(3 4 5 1 2))

(= (__ -2 [1 2 3 4 5]) '(4 5 1 2 3))

(= (__ 6 [1 2 3 4 5]) '(2 3 4 5 1))

(= (__ 1 '(:a :b :c)) '(:b :c :a))

(= (__ -4 '(:a :b :c)) '(:c :a :b))
#+END_SRC


* 45
;; The iterate function can be used to produce an infinite lazy
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= __ (take 5 (iterate #(+ 3 %) 1)))

** Solutions

Solutions:

'(1 4 7 10 13)
0x89's solution:

Scored 9, before 4clojure started saving solutions.
----------------------------------------------------------------------------------------------
_pcl's solution:
#+BEGIN_SRC clojure
(take 5 (iterate #(+ 3 %) 1))
#+END_SRC
----------------------------------------------------------------------------------------------
darren's solution:
#+BEGIN_SRC clojure
[1 4 7 10 13]
#+END_SRC
----------------------------------------------------------------------------------------------
amcnamara's solution:
#+BEGIN_SRC clojure
[1 4 7 10 13]
#+END_SRC
----------------------------------------------------------------------------------------------
wills's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
foantell's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
aceeca1's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
adereth's solution:
#+BEGIN_SRC clojure
[1 4 7 10 13]
#+END_SRC
----------------------------------------------------------------------------------------------
austintaylor's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
bradkaiser's solution:
#+BEGIN_SRC clojure
(list 1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
ctzsm's solution:
#+BEGIN_SRC clojure
(range 1 16 3)
#+END_SRC
----------------------------------------------------------------------------------------------
dlee's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
echevarria's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
glchapman's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
icamts's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
jimm's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
lllllllllllll's solution:
#+BEGIN_SRC clojure
[1 4 7 10 13]
#+END_SRC
----------------------------------------------------------------------------------------------
ming's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
ramo's solution:
#+BEGIN_SRC clojure
'(1 4 7 10 13)
#+END_SRC
----------------------------------------------------------------------------------------------
thegeez's solution:
#+BEGIN_SRC clojure
[1 4 7 10 13]
#+END_SRC
----------------------------------------------------------------------------------------------
benizi's solution:
#+BEGIN_SRC clojure
[1 4 7 10 13]
#+END_SRC

* 46
;; Write a higher-order function which flips the order of the
;; arguments of an input function. 

(= 3 ((__ nth) 2 [1 2 3 4 5]))

(= true ((__ >) 7 8))

(= 4 ((__ quot) 2 8))

(= [1 2 3] ((__ take) [1 2 3 4 5] 3))

* 47

#+begin_src clojure


;; 4Clojure Question 47
;; The contains? function checks if a KEY is present in a given
;; collection. This often leads beginner clojurians to use it
;; incorrectly with numerically indexed collections like vectors and
;; lists. Use M-x 4clojure-check-answers when you're done!

(contains? #{4 5 6} __)

(contains? [1 1 1 1 1] __)

(contains? {4 :a 2 :b} __)

(not (contains? '(1 2 4) __))
#+end_src
 
* 48
;; The some function takes a predicate function and a collection. It
;; returns the first logical true value of (predicate x) where x is an
;; item in the collection. 

(= __ (some #{2 7 6} [5 6 7 8]))

(= __ (some #(when (even? %) %) [5 6 7 8]))

* 49
;; Write a function which will split a sequence into two parts.
;; Restrictions (please don't use these function(s)): split-at 

(= (__ 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]])

(= (__ 1 [:a :b :c :d]) [[:a] [:b :c :d]])

(= (__ 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]])

* 50

;; 4Clojure Question 50
;; Write a function which takes a sequence consisting of items with
;; different types and splits them up into a set of homogeneous
;; sub-sequences. The internal order of each sub-sequence should be
;; maintained, but the sub-sequences themselves can be returned in any
;; order (this is why 'set' is used in the test cases). 

(= (set (__ [1 :a 2 :b 3 :c])) #{[1 2 3] [:a :b :c]})

(= (set (__ [:a "foo"  "bar" :b])) #{[:a :b] ["foo" "bar"]})

(= (set (__ [[1 2] :a [3 4] 5 6 :b])) #{[[1 2] [3 4]] [:a :b] [5 6]})

* 51
;; Here is an example of some more sophisticated destructuring. Use
;; M-x 4clojure-check-answers when you're done!

(= [1 2 [3 4 5] [1 2 3 4 5]] (let [[a b & c :as d] __] [a b c d]))

* 52
;; Let bindings and function parameter lists support destructuring.
;; Use M-x 4clojure-check-answers when you're done!

(= [2 4] (let [[a b c d e f g] (range)] __))

* 53
;; Given a vector of integers, find the longest consecutive
;; sub-sequence of increasing numbers. If two sub-sequences have the
;; same length, use the one that occurs first. An increasing
;; sub-sequence must have a length of 2 or greater to qualify. 

(= (__ [1 0 1 2 3 0 4 5]) [0 1 2 3])

(= (__ [5 6 1 3 2 7]) [5 6])

(= (__ [2 3 3 4 5]) [3 4 5])

(= (__ [7 6 5 4]) [])

* 54
;; Write a function which returns a sequence of lists of x items each.
;; Lists of less than x items should not be returned. Restrictions
;; (please don't use these function(s)): partition, partition-all Use
;; M-x 4clojure-check-answers when you're done!

(= (__ 3 (range 9)) '((0 1 2) (3 4 5) (6 7 8)))

(= (__ 2 (range 8)) '((0 1) (2 3) (4 5) (6 7)))

(= (__ 3 (range 8)) '((0 1 2) (3 4 5)))

* 55
;; Write a function which returns a map containing the number of
;; occurences of each distinct item in a sequence. Restrictions
;; (please don't use these function(s)): frequencies 

(= (__ [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})

(= (__ [:b :a :b :a :b]) {:a 2, :b 3})

(= (__ '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2})

* 56
;; Write a function which removes the duplicates from a sequence.
;; Order of the items must be maintained. Restrictions (please don't
;; use these function(s)): distinct Use M-x 4clojure-check-answers
;; when you're done!

(= (__ [1 2 1 3 1 2 4]) [1 2 3 4])

(= (__ [:a :a :b :b :c :c]) [:a :b :c])

(= (__ '([2 4] [1 2] [1 3] [1 3])) '([2 4] [1 2] [1 3]))

(= (__ (range 50)) (range 50))

* 57 value returned by a simple recursive fn
#+BEGIN_SRC clojure


;; A recursive function is a function which calls itself. This is one
;; of the fundamental techniques used in functional programming. Use
;; M-x 4clojure-check-answers when you're done!

(= __ ((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5))
#+END_SRC

* 58
;; Write a function which allows you to create function compositions.
;; The parameter list should take a variable number of functions, and
;; create a function applies them from right-to-left. Restrictions
;; (please don't use these function(s)): comp 

(= [3 2 1] ((__ rest reverse) [1 2 3 4]))

(= 5 ((__ (partial + 3) second) [1 2 3 4]))

(= true ((__ zero? #(mod % 8) +) 3 5 7 9))

(= "HELLO" ((__ #(.toUpperCase %) #(apply str %) take) 5 "hello world"))

* 59
;; Take a set of functions and return a new function that takes a
;; variable number of arguments and returns a sequence containing the
;; result of applying each function left-to-right to the argument
;; list. Restrictions (please don't use these function(s)): juxt Use
;; M-x 4clojure-check-answers when you're done!

(= [21 6 1] ((__ + max min) 2 3 5 1 6 4))

(= ["HELLO" 5] ((__ #(.toUpperCase %) count) "hello"))

(= [2 6 4] ((__ :a :c :b) {:a 2, :b 4, :c 6, :d 8 :e 10}))

* 60
;; Write a function which behaves like reduce, but returns each
;; intermediate value of the reduction. Your function must accept
;; either two or three arguments, and the return sequence must be
;; lazy. Restrictions (please don't use these function(s)): reductions
;; Use M-x 4clojure-check-answers when you're done!

(= (take 5 (__ + (range))) [0 1 3 6 10])

(= (__ conj [1] [2 3 4]) [[1] [1 2] [1 2 3] [1 2 3 4]])

(= (last (__ * 2 [3 4 5])) (reduce * 2 [3 4 5]) 120)

* 61
;; Write a function which takes a vector of keys and a vector of
;; values and constructs a map from them. Restrictions (please don't
;; use these function(s)): zipmap 

(= (__ [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3})

(= (__ [1 2 3 4] ["one" "two" "three"]) {1 "one", 2 "two", 3 "three"})

(= (__ [:foo :bar] ["foo" "bar" "baz"]) {:foo "foo", :bar "bar"})

* 62
;; Given a side-effect free function f and an initial value x write a
;; function which returns an infinite lazy sequence of x, (f x), (f (f
;; x)), (f (f (f x))), etc. Restrictions (please don't use these
;; function(s)): iterate 

(= (take 5 (__ #(* 2 %) 1)) [1 2 4 8 16])

(= (take 100 (__ inc 0)) (take 100 (range)))

(= (take 9 (__ #(inc (mod % 3)) 1)) (take 9 (cycle [1 2 3])))

* 63
;; Given a function f and a sequence s, write a function which returns
;; a map. The keys should be the values of f applied to each item
;; in s. The value at each key should be a vector of corresponding
;; items in the order they appear in s. Restrictions (please don't use
;; these function(s)): group-by 

(= (__ #(> % 5) [1 3 6 8]) {false [1 3], true [6 8]})

(= (__ #(apply / %) [[1 2] [2 4] [4 6] [3 6]])
   {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]})

(= (__ count [[1] [1 2] [3] [1 2 3] [2 3]])
   {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]})

* 64 use 'reduce' fn
;; <a
;; href='http://clojuredocs.org/clojure_core/clojure.core/reduce'>Reduce</a>
;; takes a 2 argument function and an optional starting value. It then
;; applies the function to the first 2 items in the sequence (or the
;; starting value and the first element of the sequence). In the next
;; iteration the function will be called on the previous return value
;; and the next item from the sequence, thus reducing the entire
;; collection to one value. Don't worry, it's not as complicated as it
;; sounds. Use M-x 4clojure-check-answers when you're done!

(= 15 (reduce __ [1 2 3 4 5]))

(=  0 (reduce __ []))

(=  6 (reduce __ 1 [2 3]))

** solution 
+

* 65
;; Clojure has many sequence types, which act in subtly different
;; ways. The core functions typically convert them into a uniform
;; "sequence" type and work with them that way, but it can be
;; important to understand the behavioral and performance differences
;; so that you know which kind is appropriate for your application.<br
;; /><br />Write a function which takes a collection and returns one
;; of :map, :set, :list, or :vector - describing the type of
;; collection it was given.<br />You won't be allowed to inspect their
;; class or use the built-in predicates like list? - the point is to
;; poke at them and understand their behavior. Restrictions (please
;; don't use these function(s)): class, type, Class, vector?,
;; sequential?, list?, seq?, map?, set?, instance?, getClass 

(= :map (__ {:a 1, :b 2}))

(= :list (__ (range (rand-int 20))))

(= :vector (__ [1 2 3 4 5 6]))

(= :set (__ #{10 (rand-int 5)}))

(= [:map :set :vector :list] (map __ [{} #{} [] ()]))

* 66
;; Given two integers, write a function which returns the greatest
;; common divisor. Use M-x 4clojure-check-answers when you're done!

(= (__ 2 4) 2)

(= (__ 10 5) 5)

(= (__ 5 7) 1)

(= (__ 1023 858) 33)

* 67
;; Write a function which returns the first x number of prime numbers.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2) [2 3])

(= (__ 5) [2 3 5 7 11])

(= (last (__ 100)) 541)

* 68
;; Clojure only has one non-stack-consuming looping construct: recur.
;; Either a function or a loop can be used as the recursion point.
;; Either way, recur rebinds the bindings of the recursion point to
;; the values it is passed. Recur must be called from the
;; tail-position, and calling it elsewhere will result in an error.
;; Use M-x 4clojure-check-answers when you're done!

(= __
  (loop [x 5
         result []]
    (if (> x 0)
      (recur (dec x) (conj result (+ 2 x)))
      result)))

* 69
;; Write a function which takes a function f and a variable number of
;; maps. Your function should return a map that consists of the rest
;; of the maps conj-ed onto the first. If a key occurs in more than
;; one map, the mapping(s) from the latter (left-to-right) should be
;; combined with the mapping in the result by calling (f val-in-result
;; val-in-latter) Restrictions (please don't use these function(s)):
;; merge-with Use M-x 4clojure-check-answers when you're done!

(= (__ * {:a 2, :b 3, :c 4} {:a 2} {:b 2} {:c 5})
   {:a 4, :b 6, :c 20})

(= (__ - {1 10, 2 20} {1 3, 2 10, 3 15})
   {1 7, 2 10, 3 15})

(= (__ concat {:a [3], :b [6]} {:a [4 5], :c [8 9]} {:b [7]})
   {:a [3 4 5], :b [6 7], :c [8 9]})

* 70
;; Write a function that splits a sentence up into a sorted list of
;; words. Capitalization should not affect sort order and punctuation
;; should be ignored. Use M-x 4clojure-check-answers when you're done!

(= (__  "Have a nice day.")
   ["a" "day" "Have" "nice"])

(= (__  "Clojure is a fun language!")
   ["a" "Clojure" "fun" "is" "language"])

(= (__  "Fools fall for foolish follies.")
   ["fall" "follies" "foolish" "Fools" "for"])

* 71 use 'thread-first' ->
;; The -> macro threads an expression x through a variable number of
;; forms. First, x is inserted as the second item in the first form,
;; making a list of it if it is not a list already. Then the first
;; form is inserted as the second item in the second form, making a
;; list of that form if necessary. This process continues for all the
;; forms. Using -> can sometimes make your code more readable. 

(= (__ (sort (rest (reverse [2 5 4 1 3 6]))))
   (-> [2 5 4 1 3 6] (reverse) (rest) (sort) (__))
   5)

* 72
;; The ->> macro threads an expression x through a variable number of
;; forms. First, x is inserted as the last item in the first form,
;; making a list of it if it is not a list already. Then the first
;; form is inserted as the last item in the second form, making a list
;; of that form if necessary. This process continues for all the
;; forms. Using ->> can sometimes make your code more readable. Use
;; M-x 4clojure-check-answers when you're done!

(= (__ (map inc (take 3 (drop 2 [2 5 4 1 3 6]))))
   (->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (__))
   11)

* 73
;; A <a
;; href="http://en.wikipedia.org/wiki/Tic-tac-toe">tic-tac-toe</a>
;; board is represented by a two dimensional vector. X is represented
;; by :x, O is represented by :o, and empty is represented by :e. A
;; player wins by placing three Xs or three Os in a horizontal,
;; vertical, or diagonal row. Write a function which analyzes a
;; tic-tac-toe board and returns :x if X has won, :o if O has won, and
;; nil if neither player has won. 

(= nil (__ [[:e :e :e]
            [:e :e :e]
            [:e :e :e]]))

(= :x (__ [[:x :e :o]
           [:x :e :e]
           [:x :e :o]]))

(= :o (__ [[:e :x :e]
           [:o :o :o]
           [:x :e :x]]))

(= nil (__ [[:x :e :o]
            [:x :x :e]
            [:o :x :o]]))

(= :x (__ [[:x :e :e]
           [:o :x :e]
           [:o :e :x]]))

(= :o (__ [[:x :e :o]
           [:x :o :e]
           [:o :e :x]]))

(= nil (__ [[:x :o :x]
            [:x :o :x]
            [:o :x :o]]))

* 74
;; Given a string of comma separated integers, write a function which
;; returns a new comma separated string that only contains the numbers
;; which are perfect squares. 

(= (__ "4,5,6,7,8,9") "4,9")

(= (__ "15,16,25,36,37") "16,25,36")

* 75
;; Two numbers are coprime if their greatest common divisor equals 1.
;; Euler's totient function f(x) is defined as the number of positive
;; integers less than x which are coprime to x. The special case f(1)
;; equals 1. Write a function which calculates Euler's totient
;; function. Use M-x 4clojure-check-answers when you're done!

(= (__ 1) 1)

(= (__ 10) (count '(1 3 7 9)) 4)

(= (__ 40) 16)

(= (__ 99) 60)

* 76
;; The trampoline function takes a function f and a variable number of
;; parameters. Trampoline calls f with any parameters that were
;; supplied. If f returns a function, trampoline calls that function
;; with no arguments. This is repeated, until the return value is not
;; a function, and then trampoline returns that non-function value.
;; This is useful for implementing mutually recursive algorithms in a
;; way that won't consume the stack. Use M-x 4clojure-check-answers
;; when you're done!

(= __
   (letfn
     [(foo [x y] #(bar (conj x y) y))
      (bar [x y] (if (> (last x) 10)
                   x
                   #(foo x (+ 2 y))))]
     (trampoline foo [] 1)))

* 77
;; Write a function which finds all the anagrams in a vector of words.
;; A word x is an anagram of word y if all the letters in x can be
;; rearranged in a different order to form y. Your function should
;; return a set of sets, where each sub-set is a group of words which
;; are anagrams of each other. Each sub-set should have at least two
;; words. Words without any anagrams should not be included in the
;; result. Use M-x 4clojure-check-answers when you're done!

(= (__ ["meat" "mat" "team" "mate" "eat"])
   #{#{"meat" "team" "mate"}})

(= (__ ["veer" "lake" "item" "kale" "mite" "ever"])
   #{#{"veer" "ever"} #{"lake" "kale"} #{"mite" "item"}})

* 78
;; Reimplement the function described in <a href="76"> "Intro to
;; Trampoline"</a>. Restrictions (please don't use these function(s)):
;; trampoline Use M-x 4clojure-check-answers when you're done!

(= (letfn [(triple [x] #(sub-two (* 3 x)))
          (sub-two [x] #(stop?(- x 2)))
          (stop? [x] (if (> x 50) x #(triple x)))]
    (__ triple 2))
  82)

(= (letfn [(my-even? [x] (if (zero? x) true #(my-odd? (dec x))))
          (my-odd? [x] (if (zero? x) false #(my-even? (dec x))))]
    (map (partial __ my-even?) (range 6)))
  [true false true false true false])

* 79
;; Write a function which calculates the sum of the minimal path
;; through a triangle. The triangle is represented as a collection of
;; vectors. The path should start at the top of the triangle and move
;; to an adjacent number on the next row until the bottom of the
;; triangle is reached. 

(= 7 (__ '([1]
          [2 4]
         [5 1 4]
        [2 3 4 5]))) ; 1->2->1->3

(= 20 (__ '([3]
           [2 4]
          [1 9 3]
         [9 9 2 4]
        [4 6 6 7 8]
       [5 7 3 5 1 4]))) ; 3->4->3->2->7->1

* 80
;; A number is "perfect" if the sum of its divisors equal the number
;; itself. 6 is a perfect number because 1+2+3=6. Write a function
;; which returns true for perfect numbers and false otherwise. 

(= (__ 6) true)

(= (__ 7) false)

(= (__ 496) true)

(= (__ 500) false)

(= (__ 8128) true)

* 81
;; Write a function which returns the intersection of two sets. The
;; intersection is the sub-set of items that each set has in common.
;; Restrictions (please don't use these function(s)): intersection Use
;; M-x 4clojure-check-answers when you're done!

(= (__ #{0 1 2 3} #{2 3 4 5}) #{2 3})

(= (__ #{0 1 2} #{3 4 5}) #{})

(= (__ #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})

* 82
;; A word chain consists of a set of words ordered so that each word
;; differs by only one letter from the words directly before and after
;; it. The one letter difference can be either an insertion, a
;; deletion, or a substitution. Here is an example word
;; chain:<br/><br/>cat -> cot -> coat -> oat -> hat -> hot -> hog ->
;; dog<br/><br/>Write a function which takes a sequence of words, and
;; returns true if they can be arranged into one continous word chain,
;; and false if they cannot. 

(= true (__ #{"hat" "coat" "dog" "cat" "oat" "cot" "hot" "hog"}))

(= false (__ #{"cot" "hot" "bat" "fat"}))

(= false (__ #{"to" "top" "stop" "tops" "toss"}))

(= true (__ #{"spout" "do" "pot" "pout" "spot" "dot"}))

(= true (__ #{"share" "hares" "shares" "hare" "are"}))

(= false (__ #{"share" "hares" "hare" "are"}))

* 83
;; Write a function which takes a variable number of booleans. Your
;; function should return true if some of the parameters are true, but
;; not all of the parameters are true. Otherwise your function should
;; return false. Use M-x 4clojure-check-answers when you're done!

(= false (__ false false))

(= true (__ true false))

(= false (__ true))

(= true (__ false true false))

(= false (__ true true true))

(= true (__ true true true false))

* 84
;; Write a function which generates the <a
;; href="http://en.wikipedia.org/wiki/Transitive_closure">transitive
;; closure</a> of a <a
;; href="http://en.wikipedia.org/wiki/Binary_relation">binary
;; relation</a>. The relation will be represented as a set of 2 item
;; vectors. Use M-x 4clojure-check-answers when you're done!

(let [divides #{[8 4] [9 3] [4 2] [27 9]}]
  (= (__ divides) #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}))

(let [more-legs
      #{["cat" "man"] ["man" "snake"] ["spider" "cat"]}]
  (= (__ more-legs)
     #{["cat" "man"] ["cat" "snake"] ["man" "snake"]
       ["spider" "cat"] ["spider" "man"] ["spider" "snake"]}))

(let [progeny
      #{["father" "son"] ["uncle" "cousin"] ["son" "grandson"]}]
  (= (__ progeny)
     #{["father" "son"] ["father" "grandson"]
       ["uncle" "cousin"] ["son" "grandson"]}))

* 85
;; Write a function which generates the <a
;; href="http://en.wikipedia.org/wiki/Power_set">power set</a> of a
;; given set. The power set of a set x is the set of all subsets of x,
;; including the empty set and x itself. 

(= (__ #{1 :a}) #{#{1 :a} #{:a} #{} #{1}})

(= (__ #{}) #{#{}})

(= (__ #{1 2 3})
   #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}})

(= (count (__ (into #{} (range 10)))) 1024)

* 86
;; Happy numbers are positive integers that follow a particular
;; formula: take each individual digit, square it, and then sum the
;; squares to get a new number. Repeat with the new number and
;; eventually, you might get to a number whose squared sum is 1. This
;; is a happy number. An unhappy number (or sad number) is one that
;; loops endlessly. Write a function that determines if a number is
;; happy or not. Use M-x 4clojure-check-answers when you're done!

(= (__ 7) true)

(= (__ 986543210) true)

(= (__ 2) false)

(= (__ 3) false)

* 87
;; Happy numbers are positive integers that follow a particular
;; formula: take each individual digit, square it, and then sum the
;; squares to get a new number. Repeat with the new number and
;; eventually, you might get to a number whose squared sum is 1. This
;; is a happy number. An unhappy number (or sad number) is one that
;; loops endlessly. Write a function that determines if a number is
;; happy or not. Use M-x 4clojure-check-answers when you're done!

(= (__ 7) true)

(= (__ 986543210) true)

(= (__ 2) false)

(= (__ 3) false)

* 88
;; Write a function which returns the symmetric difference of two
;; sets. The symmetric difference is the set of items belonging to one
;; but not both of the two sets. 

(= (__ #{1 2 3 4 5 6} #{1 3 5 7}) #{2 4 6 7})

(= (__ #{:a :b :c} #{}) #{:a :b :c})

(= (__ #{} #{4 5 6}) #{4 5 6})

(= (__ #{[1 2] [2 3]} #{[2 3] [3 4]}) #{[1 2] [3 4]})

* 89
;; Starting with a graph you must write a function that returns true
;; if it is possible to make a tour of the graph in which every edge
;; is visited exactly once.<br/><br/>The graph is represented by a
;; vector of tuples, where each tuple represents a single
;; edge.<br/><br/>The rules are:<br/><br/>- You can start at any
;; node.<br/>- You must visit each edge exactly once.</br>- All edges
;; are undirected. Use M-x 4clojure-check-answers when you're done!

(= true (__ [[:a :b]]))

(= false (__ [[:a :a] [:b :b]]))

(= false (__ [[:a :b] [:a :b] [:a :c] [:c :a]
               [:a :d] [:b :d] [:c :d]]))

(= true (__ [[1 2] [2 3] [3 4] [4 1]]))

(= true (__ [[:a :b] [:a :c] [:c :b] [:a :e]
              [:b :e] [:a :d] [:b :d] [:c :e]
              [:d :e] [:c :f] [:d :f]]))

(= false (__ [[1 2] [2 3] [2 4] [2 5]]))

* 90
;; Write a function which calculates the <a
;; href="http://en.wikipedia.org/wiki/Cartesian_product"> Cartesian
;; product</a> of two sets. 

(= (__ #{"ace" "king" "queen"} #{"&#9824;" "&#9829;" "&#9830;" "&#9827;"})
   #{["ace"   "&#9824;"] ["ace"   "&#9829;"] ["ace"   "&#9830;"] ["ace"   "&#9827;"]
     ["king"  "&#9824;"] ["king"  "&#9829;"] ["king"  "&#9830;"] ["king"  "&#9827;"]
     ["queen" "&#9824;"] ["queen" "&#9829;"] ["queen" "&#9830;"] ["queen" "&#9827;"]})

(= (__ #{1 2 3} #{4 5})
   #{[1 4] [2 4] [3 4] [1 5] [2 5] [3 5]})

(= 300 (count (__ (into #{} (range 10))
                  (into #{} (range 30)))))

* 91
;; Given a graph, determine whether the graph is connected. A
;; connected graph is such that a path exists between any two given
;; nodes.<br/><br/>-Your function must return true if the graph is
;; connected and false otherwise.<br/><br/>-You will be given a set of
;; tuples representing the edges of a graph. Each member of a tuple
;; being a vertex/node in the graph.<br/><br/>-Each edge is undirected
;; (can be traversed either direction). Use M-x 4clojure-check-answers
;; when you're done!

(= true (__ #{[:a :a]}))

(= true (__ #{[:a :b]}))

(= false (__ #{[1 2] [2 3] [3 1]
               [4 5] [5 6] [6 4]}))

(= true (__ #{[1 2] [2 3] [3 1]
              [4 5] [5 6] [6 4] [3 4]}))

(= false (__ #{[:a :b] [:b :c] [:c :d]
               [:x :y] [:d :a] [:b :e]}))

(= true (__ #{[:a :b] [:b :c] [:c :d]
              [:x :y] [:d :a] [:b :e] [:x :a]}))

* 92
;; Roman numerals are easy to recognize, but not everyone knows all
;; the rules necessary to work with them. Write a function to parse a
;; Roman-numeral string and return the number it represents. <br /><br
;; /> You can assume that the input will be well-formed, in
;; upper-case, and follow the <a
;; href="http://en.wikipedia.org/wiki/Roman_numerals#Subtractive_principle">subtractive
;; principle</a>. You don't need to handle any numbers greater than
;; MMMCMXCIX (3999), the largest number representable with ordinary
;; letters. Use M-x 4clojure-check-answers when you're done!

(= 14 (__ "XIV"))

(= 827 (__ "DCCCXXVII"))

(= 3999 (__ "MMMCMXCIX"))

(= 48 (__ "XLVIII"))


* 93
;; Write a function which flattens any nested combination of
;; sequential things (lists, vectors, etc.), but maintains the lowest
;; level sequential items. The result should be a sequence of
;; sequences with only one level of nesting. 

(= (__ [["Do"] ["Nothing"]])
   [["Do"] ["Nothing"]])

(= (__ [[[[:a :b]]] [[:c :d]] [:e :f]])
   [[:a :b] [:c :d] [:e :f]])

(= (__ '((1 2)((3 4)((((5 6)))))))
   '((1 2)(3 4)(5 6)))

* 94
;; The <a
;; href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">game of
;; life</a> is a cellular automaton devised by mathematician John
;; Conway. <br/><br/>The 'board' consists of both live (#) and dead (
;; ) cells. Each cell interacts with its eight neighbours (horizontal,
;; vertical, diagonal), and its next state is dependent on the
;; following rules:<br/><br/>1) Any live cell with fewer than two live
;; neighbours dies, as if caused by under-population.<br/>2) Any live
;; cell with two or three live neighbours lives on to the next
;; generation.<br/>3) Any live cell with more than three live
;; neighbours dies, as if by overcrowding.<br/>4) Any dead cell with
;; exactly three live neighbours becomes a live cell, as if by
;; reproduction.<br/><br/>Write a function that accepts a board, and
;; returns a board representing the next generation of cells. 

(= (__ ["      "  
        " ##   "
        " ##   "
        "   ## "
        "   ## "
        "      "])
   ["      "  
    " ##   "
    " #    "
    "    # "
    "   ## "
    "      "])

(= (__ ["     "
        "     "
        " ### "
        "     "
        "     "])
   ["     "
    "  #  "
    "  #  "
    "  #  "
    "     "])

(= (__ ["      "
        "      "
        "  ### "
        " ###  "
        "      "
        "      "])
   ["      "
    "   #  "
    " #  # "
    " #  # "
    "  #   "
    "      "])

* 95
;; Write a predicate which checks whether or not a given sequence
;; represents a <a
;; href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a>.
;; Each node in the tree must have a value, a left child, and a right
;; child. Use M-x 4clojure-check-answers when you're done!

(= (__ '(:a (:b nil nil) nil))
   true)

(= (__ '(:a (:b nil nil)))
   false)

(= (__ [1 nil [2 [3 nil nil] [4 nil nil]]])
   true)

(= (__ [1 [2 nil nil] [3 nil nil] [4 nil nil]])
   false)

(= (__ [1 [2 [3 [4 nil nil] nil] nil] nil])
   true)

(= (__ [1 [2 [3 [4 false nil] nil] nil] nil])
   false)

(= (__ '(:a nil ()))
   false)


* 96
;; Let us define a binary tree as "symmetric" if the left half of the
;; tree is the mirror image of the right half of the tree. Write a
;; predicate to determine whether or not a given binary tree is
;; symmetric. (see <a href='/problem/95'>To Tree, or not to Tree</a>
;; for a reminder on the tree representation we're using). 

(= (__ '(:a (:b nil nil) (:b nil nil))) true)

(= (__ '(:a (:b nil nil) nil)) false)

(= (__ '(:a (:b nil nil) (:c nil nil))) false)

(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])
   true)

(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
          [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])
   false)

(= (__ [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
          [2 [3 nil [4 [6 nil nil] nil]] nil]])
   false)

* 97
;; <a href="http://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's
;; triangle</a> is a triangle of numbers computed using the following
;; rules:<br/></br>- The first row is 1.</br>- Each successive row is
;; computed by adding together adjacent numbers in the row above, and
;; adding a 1 to the beginning and end of the row.<br/><br/>Write a
;; function which returns the nth row of Pascal's Triangle. 

(= (__ 1) [1])

(= (map __ (range 1 6))
   [     [1]
        [1 1]
       [1 2 1]
      [1 3 3 1]
     [1 4 6 4 1]])

(= (__ 11)
   [1 10 45 120 210 252 210 120 45 10 1])

* 98
;; A function f defined on a domain D induces an <a
;; href="http://en.wikipedia.org/wiki/Equivalence_relation">equivalence
;; relation</a> on D, as follows: a is equivalent to b with respect to
;; f if and only if (f a) is equal to (f b). Write a function with
;; arguments f and D that computes the <a
;; href="http://en.wikipedia.org/wiki/Equivalence_class">equivalence
;; classes</a> of D with respect to f. Use M-x 4clojure-check-answers
;; when you're done!

(= (__ #(* % %) #{-2 -1 0 1 2})
   #{#{0} #{1 -1} #{2 -2}})

(= (__ #(rem % 3) #{0 1 2 3 4 5 })
   #{#{0 3} #{1 4} #{2 5}})

(= (__ identity #{0 1 2 3 4})
   #{#{0} #{1} #{2} #{3} #{4}})

(= (__ (constantly true) #{0 1 2 3 4})
   #{#{0 1 2 3 4}})


* 99
;; Write a function which multiplies two numbers and returns the
;; result as a sequence of its digits. Use M-x 4clojure-check-answers
;; when you're done!

(= (__ 1 1) [1])

(= (__ 99 9) [8 9 1])

(= (__ 999 99) [9 8 9 0 1])

* 100
;; Write a function which calculates the <a
;; href="http://en.wikipedia.org/wiki/Least_common_multiple">least
;; common multiple</a>. Your function should accept a variable number
;; of positive integers or ratios. 

(== (__ 2 3) 6)

(== (__ 5 3 7) 105)

(== (__ 1/3 2/5) 2)

(== (__ 3/4 1/6) 3/2)

(== (__ 7 5/7 2 3/5) 210)

* 101
;; Given two sequences x and y, calculate the <a
;; href="https://secure.wikimedia.org/wikipedia/en/wiki/Levenshtein_distance">Levenshtein
;; distance</a> of x and y, i. e. the minimum number of edits needed
;; to transform x into y. The allowed edits are:<br/><br/>- insert a
;; single item<br/>- delete a single item<br/>- replace a single item
;; with another item<br/><br/>WARNING: Some of the test cases may
;; timeout if you write an inefficient solution! 

(= (__ "kitten" "sitting") 3)

(= (__ "closure" "clojure") (__ "clojure" "closure") 1)

(= (__ "xyx" "xyyyx") 2)

(= (__ "" "123456") 6)

(= (__ "Clojure" "Clojure") (__ "" "") (__ [] []) 0)

(= (__ [1 2 3 4] [0 2 3 4 5]) 2)

(= (__ '(:a :b :c :d) '(:a :d)) 2)

(= (__ "ttttattttctg" "tcaaccctaccat") 10)

(= (__ "gaattctaatctc" "caaacaaaaaattt") 9)

* 102
;; When working with java, you often need to create an object with
;; <code>fieldsLikeThis</code>, but you'd rather work with a hashmap
;; that has <code>:keys-like-this</code> until it's time to convert.
;; Write a function which takes lower-case hyphen-separated strings
;; and converts them to camel-case strings. 

(= (__ "something") "something")

(= (__ "multi-word-key") "multiWordKey")

(= (__ "leaveMeAlone") "leaveMeAlone")

* 103
;; Given a sequence S consisting of n elements generate all <a
;; href="https://secure.wikimedia.org/wikipedia/en/wiki/Combination">k-combinations</a>
;; of S, i. e. generate all possible sets consisting of k distinct
;; elements taken from S. The number of k-combinations for a sequence
;; is equal to the <a
;; href="https://secure.wikimedia.org/wikipedia/en/wiki/Binomial_coefficient">binomial
;; coefficient</a>. Use M-x 4clojure-check-answers when you're done!

(= (__ 1 #{4 5 6}) #{#{4} #{5} #{6}})

(= (__ 10 #{4 5 6}) #{})

(= (__ 2 #{0 1 2}) #{#{0 1} #{0 2} #{1 2}})

(= (__ 3 #{0 1 2 3 4}) #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4}
                         #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}})

(= (__ 4 #{[1 2 3] :a "abc" "efg"}) #{#{[1 2 3] :a "abc" "efg"}})

(= (__ 2 #{[1 2 3] :a "abc" "efg"}) #{#{[1 2 3] :a} #{[1 2 3] "abc"} #{[1 2 3] "efg"}
                                    #{:a "abc"} #{:a "efg"} #{"abc" "efg"}})

* 104
;; This is the inverse of <a href='92'>Problem 92</a>, but much
;; easier. Given an integer smaller than 4000, return the
;; corresponding roman numeral in uppercase, adhering to the <a
;; href='http://www.numericana.com/answer/roman.htm#valid'>subtractive
;; principle</a>. Use M-x 4clojure-check-answers when you're done!

(= "I" (__ 1))

(= "XXX" (__ 30))

(= "IV" (__ 4))

(= "CXL" (__ 140))

(= "DCCCXXVII" (__ 827))

(= "MMMCMXCIX" (__ 3999))

(= "XLVIII" (__ 48))

* 105
;; Given an input sequence of keywords and numbers, create a map such
;; that each key in the map is a keyword, and the value is a sequence
;; of all the numbers (if any) between it and the next keyword in the
;; sequence. Use M-x 4clojure-check-answers when you're done!

(= {} (__ []))

(= {:a [1]} (__ [:a 1]))

(= {:a [1], :b [2]} (__ [:a 1, :b 2]))

(= {:a [1 2 3], :b [], :c [4]} (__ [:a 1 2 3 :b :c 4]))

* 106
;; Given a pair of numbers, the start and end point, find a path
;; between the two using only three possible operations:<ul>
;; <li>double</li> <li>halve (odd numbers cannot be halved)</li>
;; <li>add 2</li></ul> Find the shortest path through the "maze".
;; Because there are multiple shortest paths, you must return the
;; length of the shortest path, not the path itself. 

(= 1 (__ 1 1))  ; 1

(= 3 (__ 3 12)) ; 3 6 12

(= 3 (__ 12 3)) ; 12 6 3

(= 3 (__ 5 9))  ; 5 7 9

(= 9 (__ 9 2))  ; 9 18 20 10 12 6 8 4 2

(= 5 (__ 9 12)) ; 9 11 22 24 12


* 107
;; <p>Lexical scope and first-class functions are two of the most
;; basic building blocks of a functional language like Clojure. When
;; you combine the two together, you get something very powerful
;; called <strong>lexical closures</strong>. With these, you can
;; exercise a great deal of control over the lifetime of your local
;; bindings, saving their values for use later, long after the code
;; you're running now has finished.</p> <p>It can be hard to follow in
;; the abstract, so let's build a simple closure. Given a positive
;; integer <i>n</i>, return a function <code>(f x)</code> which
;; computes <i>x<sup>n</sup></i>. Observe that the effect of this is
;; to preserve the value of <i>n</i> for use outside the scope in
;; which it is defined.</p> 

(= 256 ((__ 2) 16),
       ((__ 8) 2))

(= [1 8 27 64] (map (__ 3) [1 2 3 4]))

(= [1 2 4 8 16] (map #((__ %) 2) [0 1 2 3 4]))

* 108
;; <p>Given any number of sequences, each sorted from smallest to
;; largest, find the smallest single number which appears in all of
;; the sequences. The sequences may be infinite, so be careful to
;; search lazily.</p> Use M-x 4clojure-check-answers when you're done!

(= 3 (__ [3 4 5]))

(= 4 (__ [1 2 3 4 5 6 7] [0.5 3/2 4 19]))

(= 7 (__ (range) (range 0 100 7/6) [2 3 5 7 11 13]))

(= 64 (__ (map #(* % % %) (range)) ;; perfect cubes
          (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2
          (iterate inc 20))) ;; at least as large as 20

* 109
;; <p>Given any number of sequences, each sorted from smallest to
;; largest, find the smallest single number which appears in all of
;; the sequences. The sequences may be infinite, so be careful to
;; search lazily.</p> Use M-x 4clojure-check-answers when you're done!

(= 3 (__ [3 4 5]))

(= 4 (__ [1 2 3 4 5 6 7] [0.5 3/2 4 19]))

(= 7 (__ (range) (range 0 100 7/6) [2 3 5 7 11 13]))

(= 64 (__ (map #(* % % %) (range)) ;; perfect cubes
          (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2
          (iterate inc 20))) ;; at least as large as 20

* 110
;; <p>Write a function that returns a lazy sequence of
;; "pronunciations" of a sequence of numbers. A pronunciation of each
;; element in the sequence consists of the number of repeating
;; identical numbers and the number itself. For example, <code>[1
;; 1]</code> is pronounced as <code>[2 1]</code> ("two ones"), which
;; in turn is pronounced as <code>[1 2 1 1]</code> ("one two, one
;; one").</p><p>Your function should accept an initial sequence of
;; numbers, and return an infinite lazy sequence of pronunciations,
;; each element being a pronunciation of the previous element.</p> Use
;; M-x 4clojure-check-answers when you're done!

(= [[1 1] [2 1] [1 2 1 1]] (take 3 (__ [1])))

(= [3 1 2 4] (first (__ [1 1 1 4 4])))

(= [1 1 1 3 2 1 3 2 1 1] (nth (__ [1]) 6))

(= 338 (count (nth (__ [3 2]) 15)))


* 111
;; Write a function that takes a string and a partially-filled
;; crossword puzzle board, and determines if the input string can be
;; legally placed onto the board. </br></br> The crossword puzzle
;; board consists of a collection of partially-filled rows. Empty
;; spaces are denoted with an underscore (_), unusable spaces are
;; denoted with a hash symbol (#), and pre-filled spaces have a
;; character in place; the whitespace characters are for legibility
;; and should be ignored. </br></br> For a word to be legally placed
;; on the board: </br> - It may use empty spaces (underscores) </br> -
;; It may use but must not conflict with any pre-filled characters.
;; </br> - It must not use any unusable spaces (hashes). </br> - There
;; must be no empty spaces (underscores) or extra characters before or
;; after the word (the word may be bound by unusable spaces though).
;; </br> - Characters are not case-sensitive. </br> - Words may be
;; placed vertically (proceeding top-down only), or horizontally
;; (proceeding left-right only). 

(= true  (__ "the" ["_ # _ _ e"]))

(= false (__ "the" ["c _ _ _"
                    "d _ # e"
                    "r y _ _"]))

(= true  (__ "joy" ["c _ _ _"
                    "d _ # e"
                    "r y _ _"]))

(= false (__ "joy" ["c o n j"
                    "_ _ y _"
                    "r _ _ #"]))

(= true  (__ "clojure" ["_ _ _ # j o y"
                        "_ _ o _ _ _ _"
                        "_ _ f _ # _ _"]))


* 112
;; Create a function which takes an integer and a nested collection of
;; integers as arguments. Analyze the elements of the input collection
;; and return a sequence which maintains the nested structure, and
;; which includes all elements starting from the head whose sum is
;; less than or equal to the input integer. 

(=  (__ 10 [1 2 [3 [4 5] 6] 7])
   '(1 2 (3 (4))))

(=  (__ 30 [1 2 [3 [4 [5 [6 [7 8]] 9]] 10] 11])
   '(1 2 (3 (4 (5 (6 (7)))))))

(=  (__ 9 (range))
   '(0 1 2 3))

(=  (__ 1 [[[[[1]]]]])
   '(((((1))))))

(=  (__ 0 [1 2 [3 [4 5] 6] 7])
   '())

(=  (__ 0 [0 0 [0 [0]]])
   '(0 0 (0 (0))))

(=  (__ 1 [-10 [1 [2 3 [4 5 [6 7 [8]]]]]])
   '(-10 (1 (2 3 (4)))))

* 113
;; Write a function that takes a variable number of integer arguments.
;; If the output is coerced into a string, it should return a comma
;; (and space) separated list of the inputs sorted smallest to
;; largest. If the output is coerced into a sequence, it should return
;; a seq of unique input elements in the same order as they were
;; entered. Restrictions (please don't use these function(s)): proxy
;; Use M-x 4clojure-check-answers when you're done!

(= "1, 2, 3" (str (__ 2 1 3)))

(= '(2 1 3) (seq (__ 2 1 3)))

(= '(2 1 3) (seq (__ 2 1 3 3 1 2)))

(= '(1) (seq (apply __ (repeat 5 1))))

(= "1, 1, 1, 1, 1" (str (apply __ (repeat 5 1))))

(and (= nil (seq (__)))
     (=  "" (str (__))))

* 114
;; <p><a
;; href="http://clojuredocs.org/clojure_core/clojure.core/take-while">take-while</a>
;; is great for filtering sequences, but it limited: you can only
;; examine a single item of the sequence at a time. What if you need
;; to keep track of some state as you go over the sequence?</p>
;; <p>Write a function which accepts an integer <code>n</code>, a
;; predicate <code>p</code>, and a sequence. It should return a lazy
;; sequence of items in the list up to, but not including, the
;; <code>n</code>th item that satisfies the predicate.</p> 

(= [2 3 5 7 11 13]
   (__ 4 #(= 2 (mod % 3))
         [2 3 5 7 11 13 17 19 23]))

(= ["this" "is" "a" "sentence"]
   (__ 3 #(some #{\i} %)
         ["this" "is" "a" "sentence" "i" "wrote"]))

(= ["this" "is"]
   (__ 1 #{"a"}
         ["this" "is" "a" "sentence" "i" "wrote"]))

* 115
;; A balanced number is one whose component digits have the same sum
;; on the left and right halves of the number. Write a function which
;; accepts an integer n, and returns true iff n is balanced. 

(= true (__ 11))

(= true (__ 121))

(= false (__ 123))

(= true (__ 0))

(= false (__ 88099))

(= true (__ 89098))

(= true (__ 89089))

(= (take 20 (filter __ (range)))
   [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101])  

* 116
;; A <a href="http://en.wikipedia.org/wiki/Balanced_prime">balanced
;; prime</a> is a prime number which is also the mean of the primes
;; directly before and after it in the sequence of valid primes.
;; Create a function which takes an integer n, and returns true iff it
;; is a balanced prime. 

(= false (__ 4))

(= true (__ 563))

(= 1103 (nth (filter __ (range)) 15))

* 117
;; A mad scientist with tenure has created an experiment tracking mice
;; in a maze. Several mazes have been randomly generated, and you've
;; been tasked with writing a program to determine the mazes in which
;; it's possible for the mouse to reach the cheesy endpoint. Write a
;; function which accepts a maze in the form of a collection of rows,
;; each row is a string where: <ul> <li>spaces represent areas where
;; the mouse can walk freely</li> <li>hashes (#) represent walls where
;; the mouse can not walk</li> <li>M represents the mouse's starting
;; point</li> <li>C represents the cheese which the mouse must
;; reach</li> </ul> The mouse is not allowed to travel diagonally in
;; the maze (only up/down/left/right), nor can he escape the edge of
;; the maze. Your function must return true iff the maze is solvable
;; by the mouse. Use M-x 4clojure-check-answers when you're done!

(= true  (__ ["M   C"]))

(= false (__ ["M # C"]))

(= true  (__ ["#######"
              "#     #"
              "#  #  #"
              "#M # C#"
              "#######"]))

(= false (__ ["########"
              "#M  #  #"
              "#   #  #"
              "# # #  #"
              "#   #  #"
              "#  #   #"
              "#  # # #"
              "#  #   #"
              "#  #  C#"
              "########"]))

(= false (__ ["M     "
              "      "
              "      "
              "      "
              "    ##"
              "    #C"]))

(= true  (__ ["C######"
              " #     "
              " #   # "
              " #   #M"
              "     # "]))

(= true  (__ ["C# # # #"
              "        "
              "# # # # "
              "        "
              " # # # #"
              "        "
              "# # # #M"]))

* 118
;; <p>Map is one of the core elements of a functional programming
;; language. Given a function <code>f</code> and an input sequence
;; <code>s</code>, return a lazy sequence of <code>(f x)</code> for
;; each element <code>x</code> in <code>s</code>. Restrictions (please
;; don't use these function(s)): map, map-indexed, mapcat, for 

(= [3 4 5 6 7]
   (__ inc [2 3 4 5 6]))

(= (repeat 10 nil)
   (__ (fn [_] nil) (range 10)))

(= [1000000 1000001]
   (->> (__ inc (range))
        (drop (dec 1000000))
        (take 2)))

* 119
;; <p>As in <a href="/problem/73">Problem 73</a>, a tic-tac-toe board
;; is represented by a two dimensional vector. X is represented by :x,
;; O is represented by :o, and empty is represented by :e. Create a
;; function that accepts a game piece and board as arguments, and
;; returns a set (possibly empty) of all valid board placements of the
;; game piece which would result in an immediate win.</p> <p>Board
;; coordinates should be as in calls to <code>get-in</code>. For
;; example, <code>[0 1]</code> is the topmost row, center
;; position.</p> Use M-x 4clojure-check-answers when you're done!

(= (__ :x [[:o :e :e] 
           [:o :x :o] 
           [:x :x :e]])
   #{[2 2] [0 1] [0 2]})

(= (__ :x [[:x :o :o] 
           [:x :x :e] 
           [:e :o :e]])
   #{[2 2] [1 2] [2 0]})

(= (__ :x [[:x :e :x] 
           [:o :x :o] 
           [:e :o :e]])
   #{[2 2] [0 1] [2 0]})

(= (__ :x [[:x :x :o] 
           [:e :e :e] 
           [:e :e :e]])
   #{})

(= (__ :o [[:x :x :o] 
           [:o :e :o] 
           [:x :e :e]])
   #{[2 2] [1 1]})

* 120
;; Write a function which takes a collection of integers as an
;; argument. Return the count of how many elements are smaller than
;; the sum of their squared component digits. For example: 10 is
;; larger than 1 squared plus 0 squared; whereas 15 is smaller than 1
;; squared plus 5 squared. 

(= 8 (__ (range 10)))

(= 19 (__ (range 30)))

(= 50 (__ (range 100)))

(= 50 (__ (range 1000)))

* 121
;; Given a mathematical formula in prefix notation, return a function
;; 	 that calculates the value of the formula. The formula can
;; 	 contain nested calculations using the four basic mathematical
;; 	 operators, numeric constants, and symbols representing
;; 	 variables. The returned function has to accept a single
;; 	 parameter containing the map of variable names to their
;; 	 values. Use M-x 4clojure-check-answers when you're done!

(= 2 ((__ '(/ a b))
      '{b 8 a 16}))

(= 8 ((__ '(+ a b 2))
      '{a 2 b 4}))

(= [6 0 -4]
     (map (__ '(* (+ 2 a)
  	              (- 10 b)))
	        '[{a 1 b 8}
	          {b 5 a -2}
	          {a 2 b 11}]))

(= 1 ((__ '(/ (+ x 2)
              (* 3 (+ y 1))))
      '{x 4 y 1}))


* 122
;; Convert a binary number, provided in the form of a string, to its
;; numerical value. Use M-x 4clojure-check-answers when you're done!

(= 0     (__ "0"))

(= 7     (__ "111"))

(= 8     (__ "1000"))

(= 9     (__ "1001"))

(= 255   (__ "11111111"))

(= 1365  (__ "10101010101"))

(= 65535 (__ "1111111111111111"))

* 123
;; Convert a binary number, provided in the form of a string, to its
;; numerical value. Use M-x 4clojure-check-answers when you're done!

(= 0     (__ "0"))

(= 7     (__ "111"))

(= 8     (__ "1000"))

(= 9     (__ "1001"))

(= 255   (__ "11111111"))

(= 1365  (__ "10101010101"))

(= 65535 (__ "1111111111111111"))

* 124
;; <p><a href="http://en.wikipedia.org/wiki/Reversi">Reversi</a> is
;; normally played on an 8 by 8 board. In this problem, a 4 by 4 board
;; is represented as a two-dimensional vector with black, white, and
;; empty pieces represented by 'b, 'w, and 'e, respectively. Create a
;; function that accepts a game board and color as arguments, and
;; returns a map of legal moves for that color. Each key should be the
;; coordinates of a legal move, and its value a set of the coordinates
;; of the pieces flipped by that move.</p> <p>Board coordinates should
;; be as in calls to get-in. For example, <code>[0 1]</code> is the
;; topmost row, second column from the left.</p> 

(= {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}
   (__ '[[e e e e]
         [e w b e]
         [e b w e]
         [e e e e]] 'w))

(= {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}
   (__ '[[e e e e]
         [e w b e]
         [w w w e]
         [e e e e]] 'b))

(= {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}
   (__ '[[e e e e]
         [e w b e]
         [w w b e]
         [e e b e]] 'w))

(= {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}
   (__ '[[e e w e]
         [b b w e]
         [b w w e]
         [b w w w]] 'b))


* 125
;; Create a function of no arguments which returns a string that is an
;; <i>exact</i> copy of the function itself. <br /><br /> Hint: read
;; <a href="http://en.wikipedia.org/wiki/Quine_(computing)">this</a>
;; if you get stuck (this question is harder than it first appears);
;; but it's worth the effort to solve it independently if you can! <br
;; /><br /> Fun fact: Gus is the name of the <a
;; href="http://i.imgur.com/FBd8z.png">4Clojure dragon</a>. 

(= (str '__) (__))

* 126
;; Enter a value which satisfies the following: 

(let [x __]
  (and (= (class x) x) x))

* 127
;; Everyone loves triangles, and it's easy to understand
;; why&mdash;they're so wonderfully symmetric (except scalenes, they
;; suck). <br/><br/> Your passion for triangles has led you to become
;; a miner (and part-time Clojure programmer) where you work all day
;; to chip out isosceles-shaped minerals from rocks gathered in a
;; nearby open-pit mine. There are too many rocks coming from the mine
;; to harvest them all so you've been tasked with writing a program to
;; analyze the mineral patterns of each rock, and determine which
;; rocks have the biggest minerals. <br/><br/> Someone has already
;; written a <a
;; href="http://en.wikipedia.org/wiki/Computer_vision">computer-vision</a>
;; system for the mine. It images each rock as it comes into the
;; processing centre and creates a cross-sectional <a
;; href="http://en.wikipedia.org/wiki/Bit_array">bitmap</a> of mineral
;; (1) and rock (0) concentrations for each one. <br/><br/> You must
;; now create a function which accepts a collection of integers, each
;; integer when read in base-2 gives the bit-representation of the
;; rock (again, 1s are mineral and 0s are worthless scalene-like
;; rock). You must return the cross-sectional area of the largest
;; harvestable mineral from the input rock, as follows: <br> <ul>
;; <li>The minerals only have smooth faces when sheared vertically or
;; horizontally from the rock's cross-section</li> <li>The mine is
;; only concerned with harvesting isosceles triangles (such that one
;; or two sides can be sheared)</li> <li>If only one face of the
;; mineral is sheared, its opposing vertex must be a point (ie. the
;; smooth face must be of odd length), and its two equal-length sides
;; must intersect the shear face at 45&deg; (ie. those sides must cut
;; even-diagonally)</li> <li>The harvested mineral may not contain any
;; traces of rock</li> <li>The mineral may lie in any orientation in
;; the plane</li> <li>Area should be calculated as the sum of 1s that
;; comprise the mineral</li> <li>Minerals must have a minimum of three
;; measures of area to be harvested</li> <li>If no minerals can be
;; harvested from the rock, your function should return nil</li> </ul>
;; Use M-x 4clojure-check-answers when you're done!

(= 10 (__ [15 15 15 15 15]))
; 1111      1111
; 1111      *111
; 1111  ->  **11
; 1111      ***1
; 1111      ****

(= 15 (__ [1 3 7 15 31]))
; 00001      0000*
; 00011      000**
; 00111  ->  00***
; 01111      0****
; 11111      *****

(= 3 (__ [3 3]))
; 11      *1
; 11  ->  **

(= 4 (__ [7 3]))
; 111      ***
; 011  ->  0*1

(= 6 (__ [17 22 6 14 22]))
; 10001      10001
; 10110      101*0
; 00110  ->  00**0
; 01110      0***0
; 10110      10110

(= 9 (__ [18 7 14 14 6 3]))
; 10010      10010
; 00111      001*0
; 01110      01**0
; 01110  ->  0***0
; 00110      00**0
; 00011      000*1

(= nil (__ [21 10 21 10]))
; 10101      10101
; 01010      01010
; 10101  ->  10101
; 01010      01010

(= nil (__ [0 31 0 31 0]))
; 00000      00000
; 11111      11111
; 00000  ->  00000
; 11111      11111
; 00000      00000

* 128
;; <p>A standard American deck of playing cards has four suits -
;; spades, hearts, diamonds, and clubs - and thirteen cards in each
;; suit. Two is the lowest rank, followed by other integers up to ten;
;; then the jack, queen, king, and ace.</p> <p>It's convenient for
;; humans to represent these cards as suit/rank pairs, such as H5 or
;; DQ: the heart five and diamond queen respectively. But these forms
;; are not convenient for programmers, so to write a card game you
;; need some way to parse an input string into meaningful components.
;; For purposes of determining rank, we will define the cards to be
;; valued from 0 (the two) to 12 (the ace)</p> <p>Write a function
;; which converts (for example) the string "SJ" into a map of
;; <code>{:suit :spade, :rank 9}</code>. A ten will always be
;; represented with the single character "T", rather than the two
;; characters "10".</p> 

(= {:suit :diamond :rank 10} (__ "DQ"))

(= {:suit :heart :rank 3} (__ "H5"))

(= {:suit :club :rank 12} (__ "CA"))

(= (range 13) (map (comp :rank __ str)
                   '[S2 S3 S4 S5 S6 S7
                     S8 S9 ST SJ SQ SK SA]))

* 129
;; <p>A standard American deck of playing cards has four suits -
;; spades, hearts, diamonds, and clubs - and thirteen cards in each
;; suit. Two is the lowest rank, followed by other integers up to ten;
;; then the jack, queen, king, and ace.</p> <p>It's convenient for
;; humans to represent these cards as suit/rank pairs, such as H5 or
;; DQ: the heart five and diamond queen respectively. But these forms
;; are not convenient for programmers, so to write a card game you
;; need some way to parse an input string into meaningful components.
;; For purposes of determining rank, we will define the cards to be
;; valued from 0 (the two) to 12 (the ace)</p> <p>Write a function
;; which converts (for example) the string "SJ" into a map of
;; <code>{:suit :spade, :rank 9}</code>. A ten will always be
;; represented with the single character "T", rather than the two
;; characters "10".</p> 

(= {:suit :diamond :rank 10} (__ "DQ"))

(= {:suit :heart :rank 3} (__ "H5"))

(= {:suit :club :rank 12} (__ "CA"))

(= (range 13) (map (comp :rank __ str)
                   '[S2 S3 S4 S5 S6 S7
                     S8 S9 ST SJ SQ SK SA]))

* 130
;; Every node of a tree is connected to each of its children as well
;; as its parent. One can imagine grabbing one node of a tree and
;; dragging it up to the root position, leaving all connections
;; intact. For example, below on the left is a binary tree. By pulling
;; the "c" node up to the root, we obtain the tree on the right. <br/>
;; <img src="http://i.imgur.com/UtD2T.png"> <br/> Note it is no longer
;; binary as "c" had three connections total -- two children and one
;; parent. Each node is represented as a vector, which always has at
;; least one element giving the name of the node as a symbol.
;; Subsequent items in the vector represent the children of the node.
;; Because the children are ordered it's important that the tree you
;; return keeps the children of each node in order and that the old
;; parent node, if any, is appended on the right. Your function will
;; be given two args -- the name of the node that should become the
;; new root, and the tree to transform. Use M-x 4clojure-check-answers
;; when you're done!

(= '(n)
   (__ 'n '(n)))

(= '(a (t (e)))
   (__ 'a '(t (e) (a))))

(= '(e (t (a)))
   (__ 'e '(a (t (e)))))

(= '(a (b (c)))
   (__ 'a '(c (b (a)))))

(= '(d 
      (b
        (c)
        (e)
        (a 
          (f 
            (g) 
            (h)))))
  (__ 'd '(a
            (b 
              (c) 
              (d) 
              (e))
            (f 
              (g)
              (h)))))

(= '(c 
      (d) 
      (e) 
      (b
        (f 
          (g) 
          (h))
        (a
          (i
          (j
            (k)
            (l))
          (m
            (n)
            (o))))))
   (__ 'c '(a
             (b
               (c
                 (d)
                 (e))
               (f
                 (g)
                 (h)))
             (i
               (j
                 (k)
                 (l))
               (m
                 (n)
                 (o))))))


* 131
;; Given a variable number of sets of integers, create a function
;; which returns true iff all of the sets have a non-empty subset with
;; an equivalent summation. 

(= true  (__ #{-1 1 99} 
             #{-2 2 888}
             #{-3 3 7777})) ; ex. all sets have a subset which sums to zero

(= false (__ #{1}
             #{2}
             #{3}
             #{4}))

(= true  (__ #{1}))

(= false (__ #{1 -3 51 9} 
             #{0} 
             #{9 2 81 33}))

(= true  (__ #{1 3 5}
             #{9 11 4}
             #{-3 12 3}
             #{-3 4 -2 10}))

(= false (__ #{-1 -2 -3 -4 -5 -6}
             #{1 2 3 4 5 6 7 8 9}))

(= true  (__ #{1 3 5 7}
             #{2 4 6 8}))

(= true  (__ #{-1 3 -5 7 -9 11 -13 15}
             #{1 -3 5 -7 9 -11 13 -15}
             #{1 -1 2 -2 4 -4 8 -8}))

(= true  (__ #{-10 9 -8 7 -6 5 -4 3 -2 1}
             #{10 -9 8 -7 6 -5 4 -3 2 -1}))

* 132
;; Write a function that takes a two-argument predicate, a value, and
;; a collection; and returns a new collection where the
;; <code>value</code> is inserted between every two items that satisfy
;; the predicate. Use M-x 4clojure-check-answers when you're done!

(= '(1 :less 6 :less 7 4 3) (__ < :less [1 6 7 4 3]))

(= '(2) (__ > :more [2]))

(= [0 1 :x 2 :x 3 :x 4]  (__ #(and (pos? %) (< % %2)) :x (range 5)))

(empty? (__ > :more ()))

(= [0 1 :same 1 2 3 :same 5 8 13 :same 21]
   (take 12 (->> [0 1]
                 (iterate (fn [[a b]] [b (+ a b)]))
                 (map first) ; fibonacci numbers
                 (__ (fn [a b] ; both even or both odd
                       (= (mod a 2) (mod b 2)))
                     :same))))

* 133
;; Write a function that takes a two-argument predicate, a value, and
;; a collection; and returns a new collection where the
;; <code>value</code> is inserted between every two items that satisfy
;; the predicate. Use M-x 4clojure-check-answers when you're done!

(= '(1 :less 6 :less 7 4 3) (__ < :less [1 6 7 4 3]))

(= '(2) (__ > :more [2]))

(= [0 1 :x 2 :x 3 :x 4]  (__ #(and (pos? %) (< % %2)) :x (range 5)))

(empty? (__ > :more ()))

(= [0 1 :same 1 2 3 :same 5 8 13 :same 21]
   (take 12 (->> [0 1]
                 (iterate (fn [[a b]] [b (+ a b)]))
                 (map first) ; fibonacci numbers
                 (__ (fn [a b] ; both even or both odd
                       (= (mod a 2) (mod b 2)))
                     :same))))

* 134
;; Write a function which, given a key and map, returns true <a
;; href="http://en.wikipedia.org/wiki/If_and_only_if">iff</a> the map
;; contains an entry with that key and its value is nil. 

(true?  (__ :a {:a nil :b 2}))

(false? (__ :b {:a nil :b 2}))

(false? (__ :c {:a nil :b 2}))

* 135
;; Your friend Joe is always whining about Lisps using the prefix
;; notation for math. Show him how you could easily write a function
;; that does math using the infix notation. Is your favorite language
;; that flexible, Joe? Write a function that accepts a variable length
;; mathematical expression consisting of numbers and the operations +,
;; -, *, and /. Assume a simple calculator that does not do precedence
;; and instead just calculates left to right. 

(= 7  (__ 2 + 5))

(= 42 (__ 38 + 48 - 2 / 2))

(= 8  (__ 10 / 2 - 1 * 2))

(= 72 (__ 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9))

* 136
;; Your friend Joe is always whining about Lisps using the prefix
;; notation for math. Show him how you could easily write a function
;; that does math using the infix notation. Is your favorite language
;; that flexible, Joe? Write a function that accepts a variable length
;; mathematical expression consisting of numbers and the operations +,
;; -, *, and /. Assume a simple calculator that does not do precedence
;; and instead just calculates left to right. 

(= 7  (__ 2 + 5))

(= 42 (__ 38 + 48 - 2 / 2))

(= 8  (__ 10 / 2 - 1 * 2))

(= 72 (__ 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9))

* 137
;; Write a function which returns a sequence of digits of a
;; non-negative number (first argument) in numerical system with an
;; arbitrary base (second argument). Digits should be represented with
;; their integer values, e.g. 15 would be [1 5] in base 10, [1 1 1 1]
;; in base 2 and [15] in base 16. 

(= [1 2 3 4 5 0 1] (__ 1234501 10))

(= [0] (__ 0 11))

(= [1 0 0 1] (__ 9 2))

(= [1 0] (let [n (rand-int 100000)](__ n n)))

(= [16 18 5 24 15 1] (__ Integer/MAX_VALUE 42))

* 138
;; Create a function of two integer arguments: the start and end,
;; respectively. You must create a vector of strings which renders a
;; 45&deg; rotated square of integers which are successive squares
;; from the start point up to and including the end point. If a number
;; comprises multiple digits, wrap them around the shape individually.
;; If there are not enough digits to complete the shape, fill in the
;; rest with asterisk characters. The direction of the drawing should
;; be clockwise, starting from the center of the shape and working
;; outwards, with the initial direction being down and to the right.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2 2) ["2"])

(= (__ 2 4) [" 2 "
             "* 4"
             " * "])

(= (__ 3 81) [" 3 "
              "1 9"
              " 8 "])

(= (__ 4 20) [" 4 "
              "* 1"
              " 6 "])

(= (__ 2 256) ["  6  "
               " 5 * "
               "2 2 *"
               " 6 4 "
               "  1  "])

(= (__ 10 10000) ["   0   "
                  "  1 0  "
                  " 0 1 0 "
                  "* 0 0 0"
                  " * 1 * "
                  "  * *  "
                  "   *   "])

* 139
;; Create a function of two integer arguments: the start and end,
;; respectively. You must create a vector of strings which renders a
;; 45&deg; rotated square of integers which are successive squares
;; from the start point up to and including the end point. If a number
;; comprises multiple digits, wrap them around the shape individually.
;; If there are not enough digits to complete the shape, fill in the
;; rest with asterisk characters. The direction of the drawing should
;; be clockwise, starting from the center of the shape and working
;; outwards, with the initial direction being down and to the right.
;; Use M-x 4clojure-check-answers when you're done!

(= (__ 2 2) ["2"])

(= (__ 2 4) [" 2 "
             "* 4"
             " * "])

(= (__ 3 81) [" 3 "
              "1 9"
              " 8 "])

(= (__ 4 20) [" 4 "
              "* 1"
              " 6 "])

(= (__ 2 256) ["  6  "
               " 5 * "
               "2 2 *"
               " 6 4 "
               "  1  "])

(= (__ 10 10000) ["   0   "
                  "  1 0  "
                  " 0 1 0 "
                  "* 0 0 0"
                  " * 1 * "
                  "  * *  "
                  "   *   "])

* 140
;; Create a function which accepts as input a boolean algebra function
;; in the form of a set of sets, where the inner sets are collections
;; of symbols corresponding to the input boolean variables which
;; satisfy the function (the inputs of the inner sets are conjoint,
;; and the sets themselves are disjoint... also known as canonical
;; minterms). Note:&nbsp;capitalized symbols represent truth, and
;; lower-case symbols represent negation of the inputs. Your function
;; must return the minimal function which is logically equivalent to
;; the input. </br></br> PS &mdash; You may want to give this a read
;; before proceeding: <a
;; href="http://en.wikipedia.org/wiki/K_map">K-Maps</a> </br> PPS
;; &mdash; If you're interested in logic programming more generally,
;; you should also check out: <a
;; href="https://github.com/clojure/core.logic">core.logic</a> 

(= (__ #{#{'a 'B 'C 'd}
         #{'A 'b 'c 'd}
         #{'A 'b 'c 'D}
         #{'A 'b 'C 'd}
         #{'A 'b 'C 'D}
         #{'A 'B 'c 'd}
         #{'A 'B 'c 'D}
         #{'A 'B 'C 'd}})
   #{#{'A 'c} 
     #{'A 'b}
     #{'B 'C 'd}})

(= (__ #{#{'A 'B 'C 'D}
         #{'A 'B 'C 'd}})
   #{#{'A 'B 'C}})

(= (__ #{#{'a 'b 'c 'd}
         #{'a 'B 'c 'd}
         #{'a 'b 'c 'D}
         #{'a 'B 'c 'D}
         #{'A 'B 'C 'd}
         #{'A 'B 'C 'D}
         #{'A 'b 'C 'd}
         #{'A 'b 'C 'D}})
   #{#{'a 'c}
     #{'A 'C}})

(= (__ #{#{'a 'b 'c} 
         #{'a 'B 'c}
         #{'a 'b 'C}
         #{'a 'B 'C}})
   #{#{'a}})

(= (__ #{#{'a 'B 'c 'd}
         #{'A 'B 'c 'D}
         #{'A 'b 'C 'D}
         #{'a 'b 'c 'D}
         #{'a 'B 'C 'D}
         #{'A 'B 'C 'd}})
   #{#{'a 'B 'c 'd}
     #{'A 'B 'c 'D}
     #{'A 'b 'C 'D}
     #{'a 'b 'c 'D}
     #{'a 'B 'C 'D}
     #{'A 'B 'C 'd}})

(= (__ #{#{'a 'b 'c 'd}
         #{'a 'B 'c 'd}
         #{'A 'B 'c 'd}
         #{'a 'b 'c 'D}
         #{'a 'B 'c 'D}
         #{'A 'B 'c 'D}})
   #{#{'a 'c}
     #{'B 'c}})

(= (__ #{#{'a 'B 'c 'd}
         #{'A 'B 'c 'd}
         #{'a 'b 'c 'D}
         #{'a 'b 'C 'D}
         #{'A 'b 'c 'D}
         #{'A 'b 'C 'D}
         #{'a 'B 'C 'd}
         #{'A 'B 'C 'd}})
   #{#{'B 'd}
     #{'b 'D}})

(= (__ #{#{'a 'b 'c 'd}
         #{'A 'b 'c 'd}
         #{'a 'B 'c 'D}
         #{'A 'B 'c 'D}
         #{'a 'B 'C 'D}
         #{'A 'B 'C 'D}
         #{'a 'b 'C 'd}
         #{'A 'b 'C 'd}})
   #{#{'B 'D}
     #{'b 'd}})

* 141
;; <p> In <a
;; href="http://en.wikipedia.org/wiki/Trick-taking_game">trick-taking
;; card games</a> such as bridge, spades, or hearts, cards are played
;; in groups known as "tricks" - each player plays a single card, in
;; order; the first player is said to "lead" to the trick. After all
;; players have played, one card is said to have "won" the trick. How
;; the winner is determined will vary by game, but generally the
;; winner is the highest card played <i>in the suit that was led</i>.
;; Sometimes (again varying by game), a particular suit will be
;; designated "trump", meaning that its cards are more powerful than
;; any others: if there is a trump suit, and any trumps are played,
;; then the highest trump wins regardless of what was led. </p> <p>
;; Your goal is to devise a function that can determine which of a
;; number of cards has won a trick. You should accept a trump suit,
;; and return a function <code>winner</code>. Winner will be called on
;; a sequence of cards, and should return the one which wins the
;; trick. Cards will be represented in the format returned by <a
;; href="/problem/128/">Problem 128, Recognize Playing Cards</a>: a
;; hash-map of <code>:suit</code> and a numeric <code>:rank</code>.
;; Cards with a larger rank are stronger. </p> 

(let [notrump (__ nil)]
  (and (= {:suit :club :rank 9}  (notrump [{:suit :club :rank 4}
                                           {:suit :club :rank 9}]))
       (= {:suit :spade :rank 2} (notrump [{:suit :spade :rank 2}
                                           {:suit :club :rank 10}]))))

(= {:suit :club :rank 10} ((__ :club) [{:suit :spade :rank 2}
                                       {:suit :club :rank 10}]))

(= {:suit :heart :rank 8}
   ((__ :heart) [{:suit :heart :rank 6} {:suit :heart :rank 8}
                 {:suit :diamond :rank 10} {:suit :heart :rank 4}]))

* 142
;; <p> In <a
;; href="http://en.wikipedia.org/wiki/Trick-taking_game">trick-taking
;; card games</a> such as bridge, spades, or hearts, cards are played
;; in groups known as "tricks" - each player plays a single card, in
;; order; the first player is said to "lead" to the trick. After all
;; players have played, one card is said to have "won" the trick. How
;; the winner is determined will vary by game, but generally the
;; winner is the highest card played <i>in the suit that was led</i>.
;; Sometimes (again varying by game), a particular suit will be
;; designated "trump", meaning that its cards are more powerful than
;; any others: if there is a trump suit, and any trumps are played,
;; then the highest trump wins regardless of what was led. </p> <p>
;; Your goal is to devise a function that can determine which of a
;; number of cards has won a trick. You should accept a trump suit,
;; and return a function <code>winner</code>. Winner will be called on
;; a sequence of cards, and should return the one which wins the
;; trick. Cards will be represented in the format returned by <a
;; href="/problem/128/">Problem 128, Recognize Playing Cards</a>: a
;; hash-map of <code>:suit</code> and a numeric <code>:rank</code>.
;; Cards with a larger rank are stronger. </p> 

(let [notrump (__ nil)]
  (and (= {:suit :club :rank 9}  (notrump [{:suit :club :rank 4}
                                           {:suit :club :rank 9}]))
       (= {:suit :spade :rank 2} (notrump [{:suit :spade :rank 2}
                                           {:suit :club :rank 10}]))))

(= {:suit :club :rank 10} ((__ :club) [{:suit :spade :rank 2}
                                       {:suit :club :rank 10}]))

(= {:suit :heart :rank 8}
   ((__ :heart) [{:suit :heart :rank 6} {:suit :heart :rank 8}
                 {:suit :diamond :rank 10} {:suit :heart :rank 4}]))

* 143
;; Create a function that computes the <a
;; href="http://en.wikipedia.org/wiki/Dot_product#Definition">dot
;; product</a> of two sequences. You may assume that the vectors will
;; have the same length. 

(= 0 (__ [0 1 0] [1 0 0]))

(= 3 (__ [1 1 1] [1 1 1]))

(= 32 (__ [1 2 3] [4 5 6]))

(= 256 (__ [2 5 6] [100 10 1]))

* 144
;; Write an oscillating iterate: a function that takes an initial
;; value and a variable number of functions. It should return a lazy
;; sequence of the functions applied to the value in order, restarting
;; from the first function after it hits the end. 

(= (take 3 (__ 3.14 int double)) [3.14 3 3.0])

(= (take 5 (__ 3 #(- % 3) #(+ 5 %))) [3 0 5 2 7])

(= (take 12 (__ 0 inc dec inc dec inc)) [0 1 0 1 0 1 2 1 2 1 2 3])


* 145
;; Clojure's <a
;; href="http://clojuredocs.org/clojure_core/clojure.core/for">for</a>
;; macro is a tremendously versatile mechanism for producing a
;; sequence based on some other sequence(s). It can take some time to
;; understand how to use it properly, but that investment will be paid
;; back with clear, concise sequence-wrangling later. With that in
;; mind, read over these <code>for</code> expressions and try to see
;; how each of them produces the same result. 

(= __ (for [x (range 40)
            :when (= 1 (rem x 4))]
        x))

(= __ (for [x (iterate #(+ 4 %) 0)
            :let [z (inc x)]
            :while (< z 40)]
        z))

(= __ (for [[x y] (partition 2 (range 20))]
        (+ x y)))

* 146
;; <p>Because Clojure's <code>for</code> macro allows you to "walk"
;; over multiple sequences in a nested fashion, it is excellent for
;; transforming all sorts of sequences. If you don't want a sequence
;; as your final output (say you want a map), you are often still
;; best-off using <code>for</code>, because you can produce a sequence
;; and feed it into a map, for example.</p> <p>For this problem, your
;; goal is to "flatten" a map of hashmaps. Each key in your output map
;; should be the "path"<sup>1</sup> that you would have to take in the
;; original map to get to a value, so for example <code>{1 {2
;; 3}}</code> should result in <code>{[1 2] 3}</code>. You only need
;; to flatten one level of maps: if one of the values is a map, just
;; leave it alone.</p> <p><sup>1</sup> That is, <code>(get-in original
;; [k1 k2])</code> should be the same as <code>(get result [k1
;; k2])</code></p> Use M-x 4clojure-check-answers when you're done!

(= (__ '{a {p 1, q 2}
         b {m 3, n 4}})
   '{[a p] 1, [a q] 2
     [b m] 3, [b n] 4})

(= (__ '{[1] {a b c d}
         [2] {q r s t u v w x}})
   '{[[1] a] b, [[1] c] d,
     [[2] q] r, [[2] s] t,
     [[2] u] v, [[2] w] x})

(= (__ '{m {1 [a b c] 3 nil}})
   '{[m 1] [a b c], [m 3] nil})

* 147
;; Write a function that, for any given input vector of numbers,
;; returns an infinite lazy sequence of vectors, where each next one
;; is constructed from the previous following the rules used in <a
;; href="http://en.wikipedia.org/wiki/Pascal's_triangle">Pascal's
;; Triangle</a>. For example, for [3 1 2], the next row is [3 4 3 2].
;; Use M-x 4clojure-check-answers when you're done!

(= (second (__ [2 3 2])) [2 5 5 2])

(= (take 5 (__ [1])) [[1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1]])

(= (take 2 (__ [3 1 2])) [[3 1 2] [3 4 3 2]])

(= (take 100 (__ [2 4 2])) (rest (take 101 (__ [2 2]))))

* 148
;; <p>Write a function which calculates the sum of all natural numbers
;; under <i>n</i> (first argument) which are evenly divisible by at
;; least one of <i>a</i> and <i>b</i> (second and third argument).
;; Numbers <i>a</i> and <i>b</i> are guaranteed to be <a
;; href="http://en.wikipedia.org/wiki/Coprime">coprimes</a>.</p>
;; <p>Note: Some test cases have a very large <i>n</i>, so the most
;; obvious solution will exceed the time limit.</p> 

(= 0 (__ 3 17 11))

(= 23 (__ 10 3 5))

(= 233168 (__ 1000 3 5))

(= "2333333316666668" (str (__ 100000000 3 5)))

(= "110389610389889610389610"
  (str (__ (* 10000 10000 10000) 7 11)))

(= "1277732511922987429116"
  (str (__ (* 10000 10000 10000) 757 809)))

(= "4530161696788274281"
  (str (__ (* 10000 10000 1000) 1597 3571)))

* 149
;; <p>Write a function which calculates the sum of all natural numbers
;; under <i>n</i> (first argument) which are evenly divisible by at
;; least one of <i>a</i> and <i>b</i> (second and third argument).
;; Numbers <i>a</i> and <i>b</i> are guaranteed to be <a
;; href="http://en.wikipedia.org/wiki/Coprime">coprimes</a>.</p>
;; <p>Note: Some test cases have a very large <i>n</i>, so the most
;; obvious solution will exceed the time limit.</p> 

(= 0 (__ 3 17 11))

(= 23 (__ 10 3 5))

(= 233168 (__ 1000 3 5))

(= "2333333316666668" (str (__ 100000000 3 5)))

(= "110389610389889610389610"
  (str (__ (* 10000 10000 10000) 7 11)))

(= "1277732511922987429116"
  (str (__ (* 10000 10000 10000) 757 809)))

(= "4530161696788274281"
  (str (__ (* 10000 10000 1000) 1597 3571)))

* 150
;; <p>A palindromic number is a number that is the same when written
;; forwards or backwards (e.g., 3, 99, 14341).</p> <p>Write a function
;; which takes an integer <code>n</code>, as its only argument, and
;; returns an increasing lazy sequence of all palindromic numbers that
;; are not less than <code>n</code>.</p> <p>The most simple solution
;; will exceed the time limit!</p> 

(= (take 26 (__ 0))
   [0 1 2 3 4 5 6 7 8 9 
    11 22 33 44 55 66 77 88 99 
    101 111 121 131 141 151 161])

(= (take 16 (__ 162))
   [171 181 191 202 
    212 222 232 242 
    252 262 272 282 
    292 303 313 323])

(= (take 6 (__ 1234550000))
   [1234554321 1234664321 1234774321 
    1234884321 1234994321 1235005321])

(= (first (__ (* 111111111 111111111)))
   (* 111111111 111111111))

(= (set (take 199 (__ 0)))
   (set (map #(first (__ %)) (range 0 10000))))

(= true 
   (apply < (take 6666 (__ 9999999))))

(= (nth (__ 0) 10101)
   9102019)

* 151
;; <p>A palindromic number is a number that is the same when written
;; forwards or backwards (e.g., 3, 99, 14341).</p> <p>Write a function
;; which takes an integer <code>n</code>, as its only argument, and
;; returns an increasing lazy sequence of all palindromic numbers that
;; are not less than <code>n</code>.</p> <p>The most simple solution
;; will exceed the time limit!</p> 

(= (take 26 (__ 0))
   [0 1 2 3 4 5 6 7 8 9 
    11 22 33 44 55 66 77 88 99 
    101 111 121 131 141 151 161])

(= (take 16 (__ 162))
   [171 181 191 202 
    212 222 232 242 
    252 262 272 282 
    292 303 313 323])

(= (take 6 (__ 1234550000))
   [1234554321 1234664321 1234774321 
    1234884321 1234994321 1235005321])

(= (first (__ (* 111111111 111111111)))
   (* 111111111 111111111))

(= (set (take 199 (__ 0)))
   (set (map #(first (__ %)) (range 0 10000))))

(= true 
   (apply < (take 6666 (__ 9999999))))

(= (nth (__ 0) 10101)
   9102019)

* 152
;; <p> A <a href="http://en.wikipedia.org/wiki/Latin_square">Latin
;; square</a> of order <code>n</code> is an <code>n x n</code> array
;; that contains <code>n</code> different elements, each occurring
;; exactly once in each row, and exactly once in each column. For
;; example, among the following arrays <i>only the first one</i> forms
;; a Latin square: <pre> A B C A B C A B C B C A B C A B D A C A B C A
;; C C A B </pre> </p> <p> Let <code>V</code> be a vector of such
;; vectors<sup>1</sup> that they may differ in length<sup>2</sup>. We
;; will say that an arrangement of vectors of <code>V</code> in
;; consecutive rows is an <em>alignment (of vectors) of</em>
;; <code>V</code> if the following conditions are satisfied: <ul>
;; <li>All vectors of <code>V</code> are used.</li> <li>Each row
;; contains just one vector.</li> <li>The order of <code>V</code> is
;; preserved.</li> <li>All vectors of maximal length are horizontally
;; aligned each other.</li> <li>If a vector is not of maximal length
;; then all its elements are aligned with elements of some <a
;; href="http://clojuredocs.org/clojure_core/clojure.core/subvec">subvector</a>
;; of a vector of maximal length.</li> </ul> Let <code>L</code> denote
;; a Latin square of order 2 or greater. We will say that
;; <code>L</code> <em>is included</em> in <code>V</code> or that
;; <code>V</code> <em>includes</em> <code>L</code> iff there exists an
;; alignment of <code>V</code> such that contains a subsquare that is
;; equal to <code>L</code>. </p> <p> For example, if <code>V</code>
;; equals <code>[[1 2 3][2 3 1 2 1][3 1 2]]</code> then there are nine
;; alignments of <code>V</code> (brackets omitted): <pre> 1 2 3 1 2 3
;; 1 2 3 1 2 3 A 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 3 1 2 3 1 2 3 1 2 1 2 3
;; 1 2 3 1 2 3 B 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 3 1 2 3 1 2 3 1 2 1 2 3
;; 1 2 3 1 2 3 C 2 3 1 2 1 2 3 1 2 1 2 3 1 2 1 3 1 2 3 1 2 3 1 2
;; </pre> Alignment <b>A1</b> contains Latin square <code>[[1 2 3][2 3
;; 1][3 1 2]]</code>, alignments <b>A2, A3, B1, B2, B3</b> contain no
;; Latin squares, and alignments <b>C1, C2, C3</b> contain <code>[[2
;; 1][1 2]]</code>. Thus in this case <code>V</code> includes one
;; Latin square of order 3 and one of order 2 which is included three
;; times. </p> <p> Our aim is to implement a function which accepts a
;; vector of vectors <code>V</code> as an argument, and returns a map
;; which keys and values are integers. Each key should be the order of
;; a Latin square included in <code>V</code>, and its value a count of
;; <i>different</i> Latin squares of that order included in
;; <code>V</code>. If <code>V</code> does not include any Latin
;; squares an empty map should be returned. In the previous example
;; the correct output of such a function is {3 1, 2 1} and <i>not</i>
;; {3 1, 2 3}. </p> <p> <sup>1</sup> Of course, we can consider
;; sequences instead of vectors. <br /> <sup>2</sup> Length of a
;; vector is the number of elements in the vector. </p> 

(= (__ '[[A B C D]
         [A C D B]
         [B A D C]
         [D C A B]])
   {})

(= (__ '[[A B C D E F]
         [B C D E F A]
         [C D E F A B]
         [D E F A B C]
         [E F A B C D]
         [F A B C D E]])
   {6 1})

(= (__ '[[A B C D]
         [B A D C]
         [D C B A]
         [C D A B]])
   {4 1, 2 4})

(= (__ '[[B D A C B]
         [D A B C A]
         [A B C A B]
         [B C A B C]
         [A D B C A]])
   {3 3})

(= (__ [  [2 4 6 3]
        [3 4 6 2]
          [6 2 4]  ])
   {})

(= (__ [[1]
        [1 2 1 2]
        [2 1 2 1]
        [1 2 1 2]
        []       ])
   {2 2})

(= (__ [[3 1 2]
        [1 2 3 1 3 4]
        [2 3 1 3]    ])
   {3 1, 2 2})

(= (__ [[8 6 7 3 2 5 1 4]
        [6 8 3 7]
        [7 3 8 6]
        [3 7 6 8 1 4 5 2]
              [1 8 5 2 4]
              [8 1 2 4 5]])
   {4 1, 3 1, 2 7})

* 153
;; <p> Given a set of sets, create a function which returns
;; <code>true</code> if no two of those sets have any elements in
;; common<sup>1</sup> and <code>false</code> otherwise. Some of the
;; test cases are a bit tricky, so pay a little more attention to
;; them. </p> <p> <sup>1</sup>Such sets are usually called <i>pairwise
;; disjoint</i> or <i>mutually disjoint</i>. </p> 

(= (__ #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
   true)

(= (__ #{#{:a :b :c :d :e}
         #{:a :b :c :d}
         #{:a :b :c}
         #{:a :b}
         #{:a}})
   false)

(= (__ #{#{[1 2 3] [4 5]}
         #{[1 2] [3 4 5]}
         #{[1] [2] 3 4 5}
         #{1 2 [3 4] [5]}})
   true)

(= (__ #{#{'a 'b}
         #{'c 'd 'e}
         #{'f 'g 'h 'i}
         #{''a ''c ''f}})
   true)

(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}
         #{#{:x :y :z} #{:x :y} #{:z} #{}}
         #{'[:x :y :z] [:x :y] [:z] [] {}}})
   false)

(= (__ #{#{(= "true") false}
         #{:yes :no}
         #{(class 1) 0}
         #{(symbol "true") 'false}
         #{(keyword "yes") ::no}
         #{(class '1) (int \0)}})
   false)

(= (__ #{#{distinct?}
         #{#(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}})
   true)

(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}
         #{'+ '* mapcat (comment mapcat)}
         #{(do) set contains? nil?}
         #{, , , #_, , empty?}})
   false)

* 154
;; <p> Given a set of sets, create a function which returns
;; <code>true</code> if no two of those sets have any elements in
;; common<sup>1</sup> and <code>false</code> otherwise. Some of the
;; test cases are a bit tricky, so pay a little more attention to
;; them. </p> <p> <sup>1</sup>Such sets are usually called <i>pairwise
;; disjoint</i> or <i>mutually disjoint</i>. </p> 

(= (__ #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
   true)

(= (__ #{#{:a :b :c :d :e}
         #{:a :b :c :d}
         #{:a :b :c}
         #{:a :b}
         #{:a}})
   false)

(= (__ #{#{[1 2 3] [4 5]}
         #{[1 2] [3 4 5]}
         #{[1] [2] 3 4 5}
         #{1 2 [3 4] [5]}})
   true)

(= (__ #{#{'a 'b}
         #{'c 'd 'e}
         #{'f 'g 'h 'i}
         #{''a ''c ''f}})
   true)

(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}
         #{#{:x :y :z} #{:x :y} #{:z} #{}}
         #{'[:x :y :z] [:x :y] [:z] [] {}}})
   false)

(= (__ #{#{(= "true") false}
         #{:yes :no}
         #{(class 1) 0}
         #{(symbol "true") 'false}
         #{(keyword "yes") ::no}
         #{(class '1) (int \0)}})
   false)

(= (__ #{#{distinct?}
         #{#(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}})
   true)

(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}
         #{'+ '* mapcat (comment mapcat)}
         #{(do) set contains? nil?}
         #{, , , #_, , empty?}})
   false)

* 155
;; <p> Given a set of sets, create a function which returns
;; <code>true</code> if no two of those sets have any elements in
;; common<sup>1</sup> and <code>false</code> otherwise. Some of the
;; test cases are a bit tricky, so pay a little more attention to
;; them. </p> <p> <sup>1</sup>Such sets are usually called <i>pairwise
;; disjoint</i> or <i>mutually disjoint</i>. </p> 

(= (__ #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
   true)

(= (__ #{#{:a :b :c :d :e}
         #{:a :b :c :d}
         #{:a :b :c}
         #{:a :b}
         #{:a}})
   false)

(= (__ #{#{[1 2 3] [4 5]}
         #{[1 2] [3 4 5]}
         #{[1] [2] 3 4 5}
         #{1 2 [3 4] [5]}})
   true)

(= (__ #{#{'a 'b}
         #{'c 'd 'e}
         #{'f 'g 'h 'i}
         #{''a ''c ''f}})
   true)

(= (__ #{#{'(:x :y :z) '(:x :y) '(:z) '()}
         #{#{:x :y :z} #{:x :y} #{:z} #{}}
         #{'[:x :y :z] [:x :y] [:z] [] {}}})
   false)

(= (__ #{#{(= "true") false}
         #{:yes :no}
         #{(class 1) 0}
         #{(symbol "true") 'false}
         #{(keyword "yes") ::no}
         #{(class '1) (int \0)}})
   false)

(= (__ #{#{distinct?}
         #{#(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}
         #{#(-> %) #(-> %) #(-> %)}})
   true)

(= (__ #{#{(#(-> *)) + (quote mapcat) #_ nil}
         #{'+ '* mapcat (comment mapcat)}
         #{(do) set contains? nil?}
         #{, , , #_, , empty?}})
   false)

* 156
;; When retrieving values from a map, you can specify default values
;; in case the key is not found:<br/><br/>(= 2 (:foo {:bar 0, :baz 1}
;; 2))<br/><br/>However, what if you want the map itself to contain
;; the default values? Write a function which takes a default value
;; and a sequence of keys and constructs a map. 

(= (__ 0 [:a :b :c]) {:a 0 :b 0 :c 0})

(= (__ "x" [1 2 3]) {1 "x" 2 "x" 3 "x"})

(= (__ [:a :b] [:foo :bar]) {:foo [:a :b] :bar [:a :b]})


* 157
;; Transform a sequence into a sequence of pairs containing the
;; original elements along with their index. 

(= (__ [:a :b :c]) [[:a 0] [:b 1] [:c 2]])

(= (__ [0 1 3]) '((0 0) (1 1) (3 2)))

(= (__ [[:foo] {:bar :baz}]) [[[:foo] 0] [{:bar :baz} 1]])


* 158
;; Write a function that accepts a curried function of unknown arity
;; <i>n</i>. Return an equivalent function of <i>n</i> arguments.
;; <br/> You may wish to read <a
;; href="http://en.wikipedia.org/wiki/Currying">this</a>. 

(= 10 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (+ a b c d))))))
       1 2 3 4))

(= 24 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (* a b c d))))))
       1 2 3 4))

(= 25 ((__ (fn [a]
             (fn [b]
               (* a b))))
       5 5))



* 159
;; Write a function that accepts a curried function of unknown arity
;; <i>n</i>. Return an equivalent function of <i>n</i> arguments.
;; <br/> You may wish to read <a
;; href="http://en.wikipedia.org/wiki/Currying">this</a>. 

(= 10 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (+ a b c d))))))
       1 2 3 4))

(= 24 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (* a b c d))))))
       1 2 3 4))

(= 25 ((__ (fn [a]
             (fn [b]
               (* a b))))
       5 5))



* 160
;; Write a function that accepts a curried function of unknown arity
;; <i>n</i>. Return an equivalent function of <i>n</i> arguments.
;; <br/> You may wish to read <a
;; href="http://en.wikipedia.org/wiki/Currying">this</a>. 

(= 10 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (+ a b c d))))))
       1 2 3 4))

(= 24 ((__ (fn [a]
             (fn [b]
               (fn [c]
                 (fn [d]
                   (* a b c d))))))
       1 2 3 4))

(= 25 ((__ (fn [a]
             (fn [b]
               (* a b))))
       5 5))



* 161
;; Set A is a subset of set B, or equivalently B is a superset of A,
;; if A is "contained" inside B. A and B may coincide. 

(clojure.set/superset? __ #{2})

(clojure.set/subset? #{1} __)

(clojure.set/superset? __ #{1 2})

(clojure.set/subset? #{1 2} __)


* 162
;; In Clojure, only nil and false represent the values of logical
;; falsity in conditional tests - anything else is logical truth. Use
;; M-x 4clojure-check-answers when you're done!

(= __ (if-not false 1 0))

(= __ (if-not nil 1 0))

(= __ (if true 1 0))

(= __ (if [] 1 0))

(= __ (if [0] 1 0))

(= __ (if 0 1 0))

(= __ (if 1 1 0))


* 163
;; In Clojure, only nil and false represent the values of logical
;; falsity in conditional tests - anything else is logical truth. Use
;; M-x 4clojure-check-answers when you're done!

(= __ (if-not false 1 0))

(= __ (if-not nil 1 0))

(= __ (if true 1 0))

(= __ (if [] 1 0))

(= __ (if [0] 1 0))

(= __ (if 0 1 0))

(= __ (if 1 1 0))


* 164
;; A <a
;; href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic
;; finite automaton (DFA)</a> is an abstract machine that recognizes a
;; <a href=" http://en.wikipedia.org/wiki/Regular_language">regular
;; language</a>. Usually a DFA is defined by a 5-tuple, but instead
;; we'll use a map with 5 keys: <ul> <li><var>:states</var> is the set
;; of states for the DFA.</li> <li><var>:alphabet</var> is the set of
;; symbols included in the language recognized by the DFA. </li>
;; <li><var>:start</var> is the start state of the DFA. </li>
;; <li><var>:accepts</var> is the set of accept states in the DFA.
;; </li> <li><var>:transitions</var> is the transition function for
;; the DFA, mapping <var>:states</var> &#x2a2f <var>:alphabet</var>
;; onto <var>:states</var>.</li> </ul> Write a function that takes as
;; input a DFA definition (as described above) and returns a sequence
;; enumerating all strings in the language recognized by the DFA.
;; Note: Although the DFA itself is finite and only recognizes
;; finite-length strings it can still recognize an infinite set of
;; finite-length strings. And because stack space is finite, make sure
;; you don't get stuck in an infinite loop that's not producing
;; results every so often! 

(= #{"a" "ab" "abc"}
   (set (__ '{:states #{q0 q1 q2 q3}
              :alphabet #{a b c}
              :start q0
              :accepts #{q1 q2 q3}
              :transitions {q0 {a q1}
                            q1 {b q2}
                            q2 {c q3}}})))


(= #{"hi" "hey" "hello"}
   (set (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7}
              :alphabet #{e h i l o y}
              :start q0
              :accepts #{q2 q4 q7}
              :transitions {q0 {h q1}
                            q1 {i q2, e q3}
                            q3 {l q5, y q4}
                            q5 {l q6}
                            q6 {o q7}}})))

(= (set (let [ss "vwxyz"] (for [i ss, j ss, k ss, l ss] (str i j k l))))
   (set (__ '{:states #{q0 q1 q2 q3 q4}
              :alphabet #{v w x y z}
              :start q0
              :accepts #{q4}
              :transitions {q0 {v q1, w q1, x q1, y q1, z q1}
                            q1 {v q2, w q2, x q2, y q2, z q2}
                            q2 {v q3, w q3, x q3, y q3, z q3}
                            q3 {v q4, w q4, x q4, y q4, z q4}}})))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{0 1}
                           :start q0
                           :accepts #{q0}
                           :transitions {q0 {0 q0, 1 q1}
                                         q1 {0 q1, 1 q0}}}))]
  (and (every? (partial re-matches #"0*(?:10*10*)*") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{n m}
                           :start q0
                           :accepts #{q1}
                           :transitions {q0 {n q0, m q1}}}))]
  (and (every? (partial re-matches #"n*m") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7 q8 q9}
                           :alphabet #{i l o m p t}
                           :start q0
                           :accepts #{q5 q8}
                           :transitions {q0 {l q1}
                                         q1 {i q2, o q6}
                                         q2 {m q3}
                                         q3 {i q4}
                                         q4 {t q5}
                                         q6 {o q7}
                                         q7 {p q8}
                                         q8 {l q9}
                                         q9 {o q6}}}))]
  (and (every? (partial re-matches #"limit|(?:loop)+") res)
       (= res (distinct res))))



* 165
;; A <a
;; href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic
;; finite automaton (DFA)</a> is an abstract machine that recognizes a
;; <a href=" http://en.wikipedia.org/wiki/Regular_language">regular
;; language</a>. Usually a DFA is defined by a 5-tuple, but instead
;; we'll use a map with 5 keys: <ul> <li><var>:states</var> is the set
;; of states for the DFA.</li> <li><var>:alphabet</var> is the set of
;; symbols included in the language recognized by the DFA. </li>
;; <li><var>:start</var> is the start state of the DFA. </li>
;; <li><var>:accepts</var> is the set of accept states in the DFA.
;; </li> <li><var>:transitions</var> is the transition function for
;; the DFA, mapping <var>:states</var> &#x2a2f <var>:alphabet</var>
;; onto <var>:states</var>.</li> </ul> Write a function that takes as
;; input a DFA definition (as described above) and returns a sequence
;; enumerating all strings in the language recognized by the DFA.
;; Note: Although the DFA itself is finite and only recognizes
;; finite-length strings it can still recognize an infinite set of
;; finite-length strings. And because stack space is finite, make sure
;; you don't get stuck in an infinite loop that's not producing
;; results every so often! 

(= #{"a" "ab" "abc"}
   (set (__ '{:states #{q0 q1 q2 q3}
              :alphabet #{a b c}
              :start q0
              :accepts #{q1 q2 q3}
              :transitions {q0 {a q1}
                            q1 {b q2}
                            q2 {c q3}}})))


(= #{"hi" "hey" "hello"}
   (set (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7}
              :alphabet #{e h i l o y}
              :start q0
              :accepts #{q2 q4 q7}
              :transitions {q0 {h q1}
                            q1 {i q2, e q3}
                            q3 {l q5, y q4}
                            q5 {l q6}
                            q6 {o q7}}})))

(= (set (let [ss "vwxyz"] (for [i ss, j ss, k ss, l ss] (str i j k l))))
   (set (__ '{:states #{q0 q1 q2 q3 q4}
              :alphabet #{v w x y z}
              :start q0
              :accepts #{q4}
              :transitions {q0 {v q1, w q1, x q1, y q1, z q1}
                            q1 {v q2, w q2, x q2, y q2, z q2}
                            q2 {v q3, w q3, x q3, y q3, z q3}
                            q3 {v q4, w q4, x q4, y q4, z q4}}})))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{0 1}
                           :start q0
                           :accepts #{q0}
                           :transitions {q0 {0 q0, 1 q1}
                                         q1 {0 q1, 1 q0}}}))]
  (and (every? (partial re-matches #"0*(?:10*10*)*") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1}
                           :alphabet #{n m}
                           :start q0
                           :accepts #{q1}
                           :transitions {q0 {n q0, m q1}}}))]
  (and (every? (partial re-matches #"n*m") res)
       (= res (distinct res))))

(let [res (take 2000 (__ '{:states #{q0 q1 q2 q3 q4 q5 q6 q7 q8 q9}
                           :alphabet #{i l o m p t}
                           :start q0
                           :accepts #{q5 q8}
                           :transitions {q0 {l q1}
                                         q1 {i q2, o q6}
                                         q2 {m q3}
                                         q3 {i q4}
                                         q4 {t q5}
                                         q6 {o q7}
                                         q7 {p q8}
                                         q8 {l q9}
                                         q9 {o q6}}}))]
  (and (every? (partial re-matches #"limit|(?:loop)+") res)
       (= res (distinct res))))



* 166
;; For any orderable data type it's possible to derive all of the
;; basic comparison operations (&lt;, &le;, =, &ne;, &ge;, and &gt;)
;; from a single operation (any operator but = or &ne; will work).
;; Write a function that takes three arguments, a <var>less than</var>
;; operator for the data and two items to compare. The function should
;; return a keyword describing the relationship between the two items.
;; The keywords for the relationship between <var>x</var> and
;; <var>y</var> are as follows: <ul> <li><var>x</var> = <var>y</var>
;; &rarr; :eq</li> <li><var>x</var> &gt; <var>y</var> &rarr; :gt</li>
;; <li><var>x</var> &lt; <var>y</var> &rarr; :lt</li> </ul> 

(= :gt (__ < 5 1))

(= :eq (__ (fn [x y] (< (count x) (count y))) "pear" "plum"))

(= :lt (__ (fn [x y] (< (mod x 5) (mod y 5))) 21 3))

(= :gt (__ > 0 2))



* 167
;; For any orderable data type it's possible to derive all of the
;; basic comparison operations (&lt;, &le;, =, &ne;, &ge;, and &gt;)
;; from a single operation (any operator but = or &ne; will work).
;; Write a function that takes three arguments, a <var>less than</var>
;; operator for the data and two items to compare. The function should
;; return a keyword describing the relationship between the two items.
;; The keywords for the relationship between <var>x</var> and
;; <var>y</var> are as follows: <ul> <li><var>x</var> = <var>y</var>
;; &rarr; :eq</li> <li><var>x</var> &gt; <var>y</var> &rarr; :gt</li>
;; <li><var>x</var> &lt; <var>y</var> &rarr; :lt</li> </ul> 

(= :gt (__ < 5 1))

(= :eq (__ (fn [x y] (< (count x) (count y))) "pear" "plum"))

(= :lt (__ (fn [x y] (< (mod x 5) (mod y 5))) 21 3))

(= :gt (__ > 0 2))



* 168
;; <p> In what follows, <code>m</code>, <code>n</code>,
;; <code>s</code>, <code>t</code> denote nonnegative integers,
;; <code>f</code> denotes a function that accepts two arguments and is
;; defined for all nonnegative integers in both arguments. </p> <p> In
;; mathematics, the function <code>f</code> can be interpreted as an
;; infinite <a
;; href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrix</a>
;; with infinitely many rows and columns that, when written, looks
;; like an ordinary matrix but its rows and columns cannot be written
;; down completely, so are terminated with ellipses. In Clojure, such
;; infinite matrix can be represented as an infinite lazy sequence of
;; infinite lazy sequences, where the inner sequences represent rows.
;; </p> <p> Write a function that accepts 1, 3 and 5 arguments <ul>
;; <li> with the argument <code>f</code>, it returns the infinite
;; matrix <b>A</b> that has the entry in the <code>i</code>-th row and
;; the <code>j</code>-th column equal to <code>f(i,j)</code> for
;; <code>i,j = 0,1,2,...</code>;</li> <li> with the arguments
;; <code>f</code>, <code>m</code>, <code>n</code>, it returns the
;; infinite matrix <b>B</b> that equals the remainder of the matrix
;; <b>A</b> after the removal of the first <code>m</code> rows and the
;; first <code>n</code> columns;</li> <li> with the arguments
;; <code>f</code>, <code>m</code>, <code>n</code>, <code>s</code>,
;; <code>t</code>, it returns the finite s-by-t matrix that consists
;; of the first t entries of each of the first <code>s</code> rows of
;; the matrix <b>B</b> or, equivalently, that consists of the first s
;; entries of each of the first <code>t</code> columns of the matrix
;; <b>B</b>.</li> </ul> </p> Restrictions (please don't use these
;; function(s)): for, range, iterate, repeat, cycle, drop 

(= (take 5 (map #(take 6 %) (__ str)))
   [["00" "01" "02" "03" "04" "05"]
    ["10" "11" "12" "13" "14" "15"]
    ["20" "21" "22" "23" "24" "25"]
    ["30" "31" "32" "33" "34" "35"]
    ["40" "41" "42" "43" "44" "45"]])

(= (take 6 (map #(take 5 %) (__ str 3 2)))
   [["32" "33" "34" "35" "36"]
    ["42" "43" "44" "45" "46"]
    ["52" "53" "54" "55" "56"]
    ["62" "63" "64" "65" "66"]
    ["72" "73" "74" "75" "76"]
    ["82" "83" "84" "85" "86"]])

(= (__ * 3 5 5 7)
   [[15 18 21 24 27 30 33]
    [20 24 28 32 36 40 44]
    [25 30 35 40 45 50 55]
    [30 36 42 48 54 60 66]
    [35 42 49 56 63 70 77]])

(= (__ #(/ % (inc %2)) 1 0 6 4)
   [[1/1 1/2 1/3 1/4]
    [2/1 2/2 2/3 1/2]
    [3/1 3/2 3/3 3/4]
    [4/1 4/2 4/3 4/4]
    [5/1 5/2 5/3 5/4]
    [6/1 6/2 6/3 6/4]])

(= (class (__ (juxt bit-or bit-xor)))
   (class (__ (juxt quot mod) 13 21))
   (class (lazy-seq)))

(= (class (nth (__ (constantly 10946)) 34))
   (class (nth (__ (constantly 0) 5 8) 55))
   (class (lazy-seq)))

(= (let [m 377 n 610 w 987
         check (fn [f s] (every? true? (map-indexed f s)))
         row (take w (nth (__ vector) m))
         column (take w (map first (__ vector m n)))
         diagonal (map-indexed #(nth %2 %) (__ vector m n w w))]
     (and (check #(= %2 [m %]) row)
          (check #(= %2 [(+ m %) n]) column)
          (check #(= %2 [(+ m %) (+ n %)]) diagonal)))
   true)


* 169
;;
;; <p>
;;
;; In what follows, <code>m</code>, <code>n</code>, <code>s</code>, <code>t</code> 
;;
;; denote nonnegative integers, <code>f</code> denotes a function that accepts two 
;;
;; arguments and is defined for all nonnegative integers in both arguments.
;;
;; </p>
;;
;; 
;;
;; <p>
;;
;; In mathematics, the function <code>f</code> can be interpreted as an infinite 
;;
;; <a href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrix</a>
;;
;; with infinitely many rows and columns that, when written, looks like an ordinary 
;;
;; matrix but its rows and columns cannot be written down completely, so are terminated 
;;
;; with ellipses. In Clojure, such infinite matrix can be represented 
;;
;; as an infinite lazy sequence of infinite lazy sequences, 
;;
;; where the inner sequences represent rows.
;;
;; </p> 
;;
;; 
;;
;; <p>
;;
;; Write a function that accepts 1, 3 and 5 arguments
;;
;; <ul>
;;
;; <li>
;;
;; with the argument <code>f</code>, it returns the infinite matrix <b>A</b>  
;;
;; that has the entry in the <code>i</code>-th row and the <code>j</code>-th column 
;;
;; equal to <code>f(i,j)</code> for <code>i,j = 0,1,2,...</code>;</li>
;;
;; <li>
;;
;; with the arguments <code>f</code>, <code>m</code>, <code>n</code>, it returns 
;;
;; the infinite matrix <b>B</b> that equals the remainder of the matrix <b>A</b> 
;;
;; after the removal of the first <code>m</code> rows and the first <code>n</code> columns;</li>
;;
;; <li>
;;
;; with the arguments <code>f</code>, <code>m</code>, <code>n</code>, <code>s</code>, <code>t</code>,
;;
;; it returns the finite s-by-t matrix that consists of the first t entries of each of the first 
;;
;; <code>s</code> rows of the matrix <b>B</b> or, equivalently, that consists of the first s entries 
;;
;; of each of the first <code>t</code> columns of the matrix <b>B</b>.</li>
;;
;; </ul>
;;
;; </p>
;;
;; Restrictions (please don't use these function(s)): for, range, iterate, repeat, cycle, drop
;;
;; Use M-x 4clojure-check-answers when you're done!

(= (take 5 (map #(take 6 %) (__ str)))
   [["00" "01" "02" "03" "04" "05"]
    ["10" "11" "12" "13" "14" "15"]
    ["20" "21" "22" "23" "24" "25"]
    ["30" "31" "32" "33" "34" "35"]
    ["40" "41" "42" "43" "44" "45"]])

(= (take 6 (map #(take 5 %) (__ str 3 2)))
   [["32" "33" "34" "35" "36"]
    ["42" "43" "44" "45" "46"]
    ["52" "53" "54" "55" "56"]
    ["62" "63" "64" "65" "66"]
    ["72" "73" "74" "75" "76"]
    ["82" "83" "84" "85" "86"]])

(= (__ * 3 5 5 7)
   [[15 18 21 24 27 30 33]
    [20 24 28 32 36 40 44]
    [25 30 35 40 45 50 55]
    [30 36 42 48 54 60 66]
    [35 42 49 56 63 70 77]])

(= (__ #(/ % (inc %2)) 1 0 6 4)
   [[1/1 1/2 1/3 1/4]
    [2/1 2/2 2/3 1/2]
    [3/1 3/2 3/3 3/4]
    [4/1 4/2 4/3 4/4]
    [5/1 5/2 5/3 5/4]
    [6/1 6/2 6/3 6/4]])

(= (class (__ (juxt bit-or bit-xor)))
   (class (__ (juxt quot mod) 13 21))
   (class (lazy-seq)))

(= (class (nth (__ (constantly 10946)) 34))
   (class (nth (__ (constantly 0) 5 8) 55))
   (class (lazy-seq)))

(= (let [m 377 n 610 w 987
         check (fn [f s] (every? true? (map-indexed f s)))
         row (take w (nth (__ vector) m))
         column (take w (map first (__ vector m n)))
         diagonal (map-indexed #(nth %2 %) (__ vector m n w w))]
     (and (check #(= %2 [m %]) row)
          (check #(= %2 [(+ m %) n]) column)
          (check #(= %2 [(+ m %) (+ n %)]) diagonal)))
   true)



* question titles
  Nothing but the  Elementary    dbyrne  20539  incomple    
  Truth              
  Simple Math  Elementary    dbyrne  20158  incomple    
  Intro to Strings  Elementary    dbyrne  19933  incomple    
  Intro to Lists  Elementary    dbyrne  18843  incomple    
  Lists: conj  Elementary    dbyrne  18400  incomple    
  Intro to Vectors  Elementary    dbyrne  17360  incomple    
  Vectors: conj  Elementary    dbyrne  17313  incomple    
  Intro to Sets  Elementary    dbyrne  16932  incomple    
  Sets: conj  Elementary    dbyrne  16739  incomple    
  Intro to Maps  Elementary    dbyrne  16337  incomple    
  Maps: conj  Elementary    dbyrne  16141  incomple    
  Intro to  Elementary    dbyrne  16020  incomple    
  Sequences              
  Sequences: rest  Elementary    dbyrne  15949  incomple    
  Intro to  Elementary    dbyrne  15775  incomple    
  Functions              
  Double Down  Elementary    dbyrne  15594  incomple    
  Hello World  Elementary    dbyrne  14982  incomple    
  Sequences: map  Elementary    dbyrne  14895  incomple    
  Sequences: filter  Elementary    dbyrne  14803  incomple    
  Last Element  Easy  seqs core-functions  dbyrne  13333  incomple    
  Penultimate  Easy  seqs  dbyrne  12525  incomple    
  Element              
  Nth Element  Easy  seqs core-functions  dbyrne  10982  incomple    
  Count a Sequence  Easy  seqs core-functions  dbyrne  9949  incomple    
  Reverse a  Easy  seqs core-functions  dbyrne  8692  incomple    
  Sequence              
  Sum It All Up  Easy  seqs  dbyrne  9396  incomple    
  Find the odd  Easy  seqs  dbyrne  9078  incomple    
  numbers              
  Fibonacci  Easy  Fibonacci seqs  dbyrne  6999  incomple    
  Sequence              
  Palindrome  Easy  seqs  dbyrne  7311  incomple    
  Detector              
  Flatten a  Easy  seqs core-functions  dbyrne  5126  incomple    
  Sequence              
  Get the Caps  Easy  strings  dbyrne  6064  incomple    
  Compress a  Easy  seqs  dbyrne  4979  incomple    
  Sequence              
  Pack a Sequence  Easy  seqs  dbyrne  4376  incomple    
  Duplicate a  Easy  seqs  dbyrne  5460  incomple    
  Sequence              
  Replicate a  Easy  seqs  dbyrne  4734  incomple    
  Sequence              
  Implement range  Easy  seqs core-functions  dbyrne  5216  incomple    
  Local bindings  Elementary  syntax  amalloy  11243  incomple    
  Let it Be  Elementary  math syntax  amalloy  10678  incomple    
  Regular  Elementary  regex syntax  dbyrne  9815  incomple    
  Expressions              
  Maximum value  Easy  core-functions  dbyrne  6700  incomple    
  Interleave Two  Easy  seqs core-functions  dbyrne  5076  incomple    
  Seqs              
  Interpose a Seq  Easy  seqs core-functions  dbyrne  4627  incomple    
  Drop Every Nth  Easy  seqs  dbyrne  4263  incomple    
  Item              
  Factorial Fun  Easy  math  amalloy  5039  incomple    
  Reverse  Medium  seqs  amalloy  2864  incomple    
  Interleave              
  Rotate Sequence  Medium  seqs  dbyrne  2985  incomple    
  Intro to Iterate  Easy  seqs  dbyrne  4717  incomple    
  Flipping out  Medium  higher-order-functions  dbyrne  3398  incomple    
  Contain Yourself  Easy    dbyrne  4838  incomple    
  Intro to some  Easy    dbyrne  5303  incomple    
  Split a sequence  Easy  seqs core-functions  dbyrne  4012  incomple    
  Split by Type  Medium  seqs  dbyrne  2748  incomple    
  Advanced  Easy  destructuring  dbyrne  3807  incomple    
  Destructuring              
  Intro to  Easy  destructuring  amalloy  4162  incomple    
  Destructuring              
  Longest  Hard  seqs  dbyrne  1609  incomple    
  Increasing              
  Sub-Seq              
  Partition a  Medium  seqs core-functions  dbyrne  2010  incomple    
  Sequence              
  Count Occurrences  Medium  seqs core-functions  dbyrne  2370  incomple    
  Find Distinct  Medium  seqs core-functions  dbyrne  2167  incomple    
  Items              
  Simple Recursion  Elementary  recursion  dbyrne  8159  incomple    
  Function  Medium  higher-order-functions  dbyrne  2128  incomple    
  Composition    core-functions          
  Juxtaposition  Medium  higher-order-functions  dbyrne  2013  incomple    
      core-functions          
  Sequence  Medium  seqs core-functions  dbyrne  1370  incomple    
  Reductions              
  Map Construction  Easy  core-functions  dbyrne  3280  incomple    
  Re-implement  Easy  seqs core-functions  amalloy  2727  incomple    
  Iterate              
  Group a Sequence  Easy  core-functions  dbyrne  2430  incomple    
  Intro to Reduce  Elementary  seqs  citizen428  8911  incomple    
  Black Box Testing  Medium  seqs testing  amalloy  1569  incomple    
  Greatest Common  Easy    dbyrne  3003  incomple    
  Divisor              
  Prime Numbers  Medium  primes  dbyrne  1674  incomple    
  Recurring Theme  Elementary  recursion  dbyrne  6710  incomple    
  Merge with a  Medium  core-functions  dbyrne  1366  incomple    
  Function              
  Word Sorting  Medium  sorting  fotland  1758  incomple    
  Rearranging Code:  Elementary    amalloy  6990  incomple    
  ->              
  Rearranging Code:  Elementary    amalloy  6507  incomple    
  ->>              
  Analyze a  Hard  game  fotland  1124  incomple    
  Tic-Tac-Toe Board              
  Filter Perfect  Medium    dbyrne  1589  incomple    
  Squares              
  Euler's Totient  Medium    dbyrne  1146  incomple    
  Function              
  Intro to  Medium  recursion  dbyrne  1557  incomple    
  Trampoline              
  Anagram Finder  Medium    dbyrne  1390  incomple    
  Reimplement  Medium  core-functions  dbyrne  1069  incomple    
  Trampoline              
  Triangle Minimal  Hard  graph-theory  dbyrne  703  incomple    
  Path              
  Perfect Numbers  Medium    dbyrne  1441  incomple    
  Set Intersection  Easy  set-theory  dbyrne  2845  incomple    
  Word Chains  Hard  seqs  dbyrne  505  incomple    
  A Half-Truth  Easy    cmeier  3348  incomple    
  Transitive  Hard  set-theory  dbyrne  573  incomple    
  Closure              
  Power Set  Medium  set-theory  peteris  981  incomple    
  Happy numbers  Medium  math  daviddavis  1115  incomple    
  Symmetric  Easy  set-theory  dbyrne  2271  incomple    
  Difference              
  Graph Tour  Hard  graph-theory  lucas1000001  400  incomple    
  Cartesian Product  Easy  set-theory  dbyrne  2471  incomple    
  Graph  Hard  graph-theory  lucas1000001  508  incomple    
  Connectivity              
  Read Roman  Hard  strings math  amalloy  734  incomple    
  numerals              
  Partially Flatten  Medium  seqs  dbyrne  764  incomple    
  a Sequence              
  Game of Life  Hard  game  lucas1000001  437  incomple    
  To Tree, or not  Easy  trees  dbyrne  1785  incomple    
  to Tree              
  Beauty is  Easy  trees  dbyrne  1306  incomple    
  Symmetry              
  Pascal's Triangle  Easy    dbyrne  1915  incomple    
  Equivalence  Medium    drcabana  958  incomple    
  Classes              
  Product Digits  Easy  math seqs  jneira  2565  incomple    
  Least Common  Easy  math  dbyrne  1467  incomple    
  Multiple              
  Levenshtein  Hard  seqs  patsp  410  incomple    
  Distance              
  intoCamelCase  Medium  strings  amalloy  1309  incomple    
  Generating  Medium  seqs combinatorics  patsp  615  incomple    
  k-combinations              
  Write Roman  Medium  strings math  0x89  687  incomple    
  Numerals              
  Identify keys and  Medium  maps seqs  amalloy  924  incomple    
  values              
  Number Maze  Hard  numbers  lucas1000001  428  incomple    
  Simple closures  Easy  higher-order-functions  amalloy  2655  incomple    
      math          
  Lazy Searching  Medium  seqs sorting  amalloy  798  incomple    
  Sequence of  Medium  seqs  mlni  825  incomple    
  pronunciations              
  Crossword puzzle  Hard  game  mlni  312  incomple    
  Sequs Horribilis  Medium  seqs  ghoseb  465  incomple    
  Making Data Dance  Hard  types  amcnamara  351  incomple    
  Global take-while  Medium  seqs  amalloy  735  incomple    
      higher-order-functions          
  The Balance of N  Medium  math  amcnamara  969  incomple    
  Prime Sandwich  Medium  math  amcnamara  610  incomple    
  For Science!  Hard  game  amcnamara  353  incomple    
  Re-implement Map  Easy  core-seqs  semisight  1859  incomple    
  Win at  Hard  game  shockbob  362  incomple    
  Tic-Tac-Toe              
  Sum of square of  Easy  math  danilo  1815  incomple    
  digits              
  Universal  Medium  functions  mlni  589  incomple    
  Computation              
  Engine              
  Read a binary  Easy    mikera  2310  incomple    
  number              
  Analyze Reversi  Hard  game  shockbob  232  incomple    
  Gus' Quinundrum  Hard  logic fun brain-teaser  amcnamara  304  incomple    
  Through the  Easy  fun brain-teaser  amcnamara  2163  incomple    
  Looking Class              
  Love Triangle  Hard  search data-juggling  amcnamara  169  incomple    
  Recognize Playing  Easy  strings game  amalloy  1725  incomple    
  Cards              
  Tree reparenting  Hard  tree  chouser  236  incomple    
  Sum Some Set  Medium  math  amcnamara  481  incomple    
  Subsets              
  Insert between  Medium  seqs core-functions  srid  708  incomple    
  two items              
  A nil key  Elementary  maps  goranjovic  5968  incomple    
  Infix Calculator  Easy  higher-order-functions  fdaoud  2107  incomple    
      math          
  Digits and bases  Medium  math  goranjovic  898  incomple    
  Squares Squared  Hard  data-juggling  amcnamara  211  incomple    
  Veitch, Please!  Hard  math circuit-design  amcnamara  140  incomple    
  Tricky card games  Medium  game cards  amalloy  457  incomple    
  dot product  Easy  seqs math  bloop  2267  incomple    
  Oscilrate  Medium  sequences  bloop  818  incomple    
  For the win  Elementary  core-functions seqs  amalloy  5454  incomple    
  Trees into tables  Easy  seqs maps  amalloy  1247  incomple    
  Pascal's  Easy  seqs  narvius  1341  incomple    
  Trapezoid              
  The Big Divide  Medium  math  goranjovic  573  incomple    
  Palindromic  Medium  seqs math  maximental  348  incomple    
  Numbers              
  Latin Square  Hard  data-analysis math  maximental  139  incomple    
  Slicing              
  Pairwise Disjoint  Easy  set-theory  maximental  1163  incomple    
  Sets              
  Map Defaults  Elementary  seqs  jaycfields  4250  incomple    
  Indexing  Easy  seqs  jaycfields  1955  incomple    
  Sequences              
  Decurry  Medium  partial-functions  amcnamara  759  incomple    
  Subset and  Elementary  set-theory  hangkous  4878  incomple    
  Superset              
  Logical falsity  Elementary  logic  hangkous  5236  incomple    
  and truth              
  Language of a DFA  Hard  automata seqs  daowen  199  incomple    
  Comparisons  Easy    daowen  2933  incomple    
  Infinite Matrix  Medium  seqs recursion math  maximental  346  incomple    
  Intervals  Medium    aiba  521  incomple    
  Intro to  Easy  Destructuring  hangkous  1419  incomple    
  Destructuring 2              
  Balancing  Medium  parsing  daowen  441  incomple    
  Brackets              
  Best Hand  Hard  strings game  toolkit  216  incomple    
  Parentheses...  Medium  math combinatorics  djtrack16  48  incomple    
  Again              
